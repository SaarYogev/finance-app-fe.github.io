{"version":3,"file":"kotlinx-io.js","sources":["kotlin/UShort.kt","kotlin/UInt.kt","kotlin/ULong.kt","../../../../../common/src/kotlinx/io/charsets/Encoding.kt","text/StringBuilder.kt","util/Preconditions.kt","../../../../../common/src/kotlinx/io/core/Buffers.kt","generated/_ComparisonsJs.kt","../../../../../common/src/kotlinx/io/core/Input.kt","../../../../../common/src/kotlinx/io/core/Packet.kt","../../../../../js/src/kotlinx/io/bits/ByteOrderJS.kt","../../../../../common/src/kotlinx/io/bits/ByteOrder.kt","../../../../../common/src/kotlinx/io/core/Builder.kt","util/Standard.kt","../../../../../common/src/kotlinx/io/core/Output.kt","../../../../../common/src/kotlinx/io/core/internal/Require.kt","../../../../../common/src/kotlinx/io/core/ByteReadPacket.kt","../../../../../common/src/kotlinx/io/core/Closeable.kt","../../../../../common/src/kotlinx/io/core/Copy.kt","../../../../../common/src/kotlinx/io/core/Experimental.kt","../../../../../common/src/kotlinx/io/core/internal/UTF8.kt","../../../../../common/src/kotlinx/io/core/InputLittleEndian.kt","generated/_UArrays.kt","../../../../../common/src/kotlinx/io/core/InputPeek.kt","../../../../../common/src/kotlinx/io/core/OutputLittleEndian.kt","../../../../../common/src/kotlinx/io/core/Scanner.kt","../../../../../common/src/kotlinx/io/core/Strings.kt","../../../../../common/src/kotlinx/io/core/UnsignedTypes.kt","kotlin/UByte.kt","../../../../../common/src/kotlinx/io/core/Use.kt","../../../../../../../../../dummy.kt","../../../../../common/src/kotlinx/io/core/internal/Unsafe.kt","../../../../../common/src/kotlinx/io/pool/Pool.kt","../../../../../src/commonMain/kotlin/kotlinx/atomicfu/AtomicFU.common.kt","kotlin/numbers.kt","../../../../../js/src/kotlinx/io/charsets/CharsetJS.kt","kotlin/text/string.kt","text/Strings.kt","../../../../../js/src/kotlinx/io/js/TextDecoders.kt","../../../../../js/src/kotlinx/io/charsets/ISO88591.kt","../../../../../js/src/kotlinx/io/core/IoBufferJS.kt","org.w3c/org.khronos.webgl.kt","../../../../../js/src/kotlinx/io/core/ByteOrderJS.kt","../../../../../js/src/kotlinx/io/core/BytePacketBuilderJS.kt","../../../../../js/src/kotlinx/io/core/ByteReadPacket.kt","../../../../../js/src/kotlinx/io/core/CloseableJS.kt","../../../../../js/src/kotlinx/io/core/Input.kt","../../../../../js/src/kotlinx/io/core/PacketJS.kt","../../../../../js/src/kotlinx/io/core/ScannerJS.kt","../../../../../js/src/kotlinx/io/core/StringsJS.kt","../../../../../js/src/kotlinx/io/errors/IOException.kt","../../../../../js/src/kotlinx/io/js/TextEncoders.kt","../../../../../js/src/kotlinx/io/js/TypedArrays.kt","../../../../../js/src/kotlinx/io/js/WebSockets.kt","../../../../../js/src/kotlinx/io/js/XMLHttpRequest.kt","org.w3c/org.w3c.xhr.kt","../../../../../js/src/kotlinx/io/pool/DefaultPool.kt"],"sourcesContent":["/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class UShort @PublishedApi internal constructor(@PublishedApi internal val data: Short) : Comparable<UShort> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UShort can have.\n         */\n        public const val MIN_VALUE: UShort = UShort(0)\n\n        /**\n         * A constant holding the maximum value an instance of UShort can have.\n         */\n        public const val MAX_VALUE: UShort = UShort(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 2\n\n        /**\n         * The number of bits used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BITS: Int = 16\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UShort = UShort(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UShort = UShort(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UShort): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UShort): UShort = UShort(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UShort): UShort = UShort(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UShort): UShort = UShort(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UShort = UShort(data.inv())\n\n    /**\n     * Converts this [UShort] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UShort` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UShort] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UShort`. Otherwise the result is negative.\n     *\n     * The resulting `Short` value has the same binary representation as this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data\n    /**\n     * Converts this [UShort] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Int` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFFFF\n    /**\n     * Converts this [UShort] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Long` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF\n\n    /**\n     * Converts this [UShort] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = this\n    /**\n     * Converts this [UShort] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFFFF)\n    /**\n     * Converts this [UShort] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF)\n\n    /**\n     * Converts this [UShort] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UShort] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `Byte` value,\n * whereas the most significant 8 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Short] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Short`.\n *\n * The resulting `UShort` value has the same binary representation as this `Short` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUShort(): UShort = UShort(this)\n/**\n * Converts this [Int] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Int` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Long] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUShort(): UShort = UShort(this.toShort())\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class UInt @PublishedApi internal constructor(@PublishedApi internal val data: Int) : Comparable<UInt> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UInt can have.\n         */\n        public const val MIN_VALUE: UInt = UInt(0)\n\n        /**\n         * A constant holding the maximum value an instance of UInt can have.\n         */\n        public const val MAX_VALUE: UInt = UInt(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 4\n\n        /**\n         * The number of bits used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BITS: Int = 32\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UInt): Int = uintCompare(this.data, other.data)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = UInt(this.data.plus(other.data))\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = UInt(this.data.minus(other.data))\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = UInt(this.data.times(other.data))\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = uintDivide(this, other)\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = uintRemainder(this, other)\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UInt = UInt(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UInt = UInt(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UInt): UIntRange = UIntRange(this, other)\n\n    /** Shifts this value left by the [bitCount] number of bits. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): UInt = UInt(data shl bitCount)\n    /** Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): UInt = UInt(data ushr bitCount)\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UInt): UInt = UInt(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UInt): UInt = UInt(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UInt): UInt = UInt(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UInt = UInt(data.inv())\n\n    /**\n     * Converts this [UInt] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UInt` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UInt] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `UInt` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [UInt] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `UInt`. Otherwise the result is negative.\n     *\n     * The resulting `Int` value has the same binary representation as this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data\n    /**\n     * Converts this [UInt] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `Long` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF_FFFF\n\n    /**\n     * Converts this [UInt] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [UInt] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = this\n    /**\n     * Converts this [UInt] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF_FFFF)\n\n    /**\n     * Converts this [UInt] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `UInt` value.\n     * In case when this `UInt` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [UInt] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UInt`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = uintToDouble(data)\n\n    public override fun toString(): String = toLong().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `Byte` value,\n * whereas the most significant 24 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Short] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `Short` value,\n * whereas the most significant 16 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Int] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Int`.\n *\n * The resulting `UInt` value has the same binary representation as this `Int` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUInt(): UInt = UInt(this)\n/**\n * Converts this [Long] value to [UInt].\n *\n * If this value is positive and less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UInt` value is represented by the least significant 32 bits of this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUInt(): UInt = UInt(this.toInt())\n\n/**\n * Converts this [Float] value to [UInt].\n *\n * The fractional part, if any, is rounded down.\n * Returns zero if this `Float` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Float.toUInt(): UInt = doubleToUInt(this.toDouble())\n/**\n * Converts this [Double] value to [UInt].\n *\n * The fractional part, if any, is rounded down.\n * Returns zero if this `Double` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Double.toUInt(): UInt = doubleToUInt(this)\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class ULong @PublishedApi internal constructor(@PublishedApi internal val data: Long) : Comparable<ULong> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of ULong can have.\n         */\n        public const val MIN_VALUE: ULong = ULong(0)\n\n        /**\n         * A constant holding the maximum value an instance of ULong can have.\n         */\n        public const val MAX_VALUE: ULong = ULong(-1)\n\n        /**\n         * The number of bytes used to represent an instance of ULong in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 8\n\n        /**\n         * The number of bits used to represent an instance of ULong in a binary form.\n         */\n        public const val SIZE_BITS: Int = 64\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: ULong): Int = ulongCompare(this.data, other.data)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = ULong(this.data.plus(other.data))\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = ULong(this.data.minus(other.data))\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = ULong(this.data.times(other.data))\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): ULong = this.div(other.toULong())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): ULong = this.div(other.toULong())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): ULong = this.div(other.toULong())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = ulongDivide(this, other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): ULong = this.rem(other.toULong())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): ULong = this.rem(other.toULong())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): ULong = this.rem(other.toULong())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = ulongRemainder(this, other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): ULong = ULong(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): ULong = ULong(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: ULong): ULongRange = ULongRange(this, other)\n\n    /** Shifts this value left by the [bitCount] number of bits. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): ULong = ULong(data shl bitCount)\n    /** Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): ULong = ULong(data ushr bitCount)\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: ULong): ULong = ULong(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: ULong): ULong = ULong(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: ULong): ULong = ULong(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): ULong = ULong(data.inv())\n\n    /**\n     * Converts this [ULong] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `ULong` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [ULong] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `ULong` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [ULong] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Int` value is represented by the least significant 32 bits of this `ULong` value.\n     * Note that the resulting `Int` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt()\n    /**\n     * Converts this [ULong] value to [Long].\n     *\n     * If this value is less than or equals to [Long.MAX_VALUE], the resulting `Long` value represents\n     * the same numerical value as this `ULong`. Otherwise the result is negative.\n     *\n     * The resulting `Long` value has the same binary representation as this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data\n\n    /**\n     * Converts this [ULong] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [ULong] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /**\n     * Converts this [ULong] value to [UInt].\n     *\n     * If this value is less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UInt` value is represented by the least significant 32 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = data.toUInt()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = this\n\n    /**\n     * Converts this [ULong] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `ULong` value.\n     * In case when this `ULong` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [ULong] value to [Double].\n     *\n     * The resulting value is the closest `Double` to this `ULong` value.\n     * In case when this `ULong` value is exactly between two `Double`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = ulongToDouble(data)\n\n    public override fun toString(): String = ulongToString(data)\n\n}\n\n/**\n * Converts this [Byte] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `Byte` value,\n * whereas the most significant 56 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Short] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `Short` value,\n * whereas the most significant 48 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Int] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Int`.\n *\n * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `Int` value,\n * whereas the most significant 32 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Long] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Long`.\n *\n * The resulting `ULong` value has the same binary representation as this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toULong(): ULong = ULong(this)\n\n/**\n * Converts this [Float] value to [ULong].\n *\n * The fractional part, if any, is rounded down.\n * Returns zero if this `Float` value is negative or `NaN`, [ULong.MAX_VALUE] if it's bigger than `ULong.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Float.toULong(): ULong = doubleToULong(this.toDouble())\n/**\n * Converts this [Double] value to [ULong].\n *\n * The fractional part, if any, is rounded down.\n * Returns zero if this `Double` value is negative or `NaN`, [ULong.MAX_VALUE] if it's bigger than `ULong.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Double.toULong(): ULong = doubleToULong(this)\n","package kotlinx.io.charsets\n\nimport kotlinx.io.core.*\n\nexpect abstract class Charset {\n    @ExperimentalIoApi\n    abstract fun newEncoder(): CharsetEncoder\n\n    @ExperimentalIoApi\n    abstract fun newDecoder(): CharsetDecoder\n\n    companion object {\n        fun forName(name: String): Charset\n    }\n}\n\nexpect val Charset.name: String\n\n// ----------------------------- ENCODER -------------------------------------------------------------------------------\n@ExperimentalIoApi\nexpect abstract class CharsetEncoder\n\nexpect val CharsetEncoder.charset: Charset\n\n@Deprecated(\n    \"Use writeText on Output instead.\",\n    ReplaceWith(\"dst.writeText(input, fromIndex, toIndex, charset)\", \"kotlinx.io.core.writeText\")\n)\nfun CharsetEncoder.encode(input: CharSequence, fromIndex: Int, toIndex: Int, dst: Output) {\n     encodeToImpl(dst, input, fromIndex, toIndex)\n}\n\nprivate val EmptyByteArray = ByteArray(0)\n\n@ExperimentalIoApi\nexpect fun CharsetEncoder.encodeToByteArray(input: CharSequence,\n                                            fromIndex: Int = 0,\n                                            toIndex: Int = input.length): ByteArray\n\n@Deprecated(\n    \"Internal API. Will be hidden in future releases. Use encodeToByteArray instead.\",\n    replaceWith = ReplaceWith(\"encodeToByteArray(input, fromIndex, toIndex)\")\n)\nfun CharsetEncoder.encodeToByteArrayImpl(\n    input: CharSequence,\n    fromIndex: Int = 0,\n    toIndex: Int = input.length\n): ByteArray {\n    return encodeToByteArray(input, fromIndex, toIndex)\n}\n\n@ExperimentalIoApi\nexpect fun CharsetEncoder.encodeUTF8(input: ByteReadPacket, dst: Output)\n\n@ExperimentalIoApi\nfun CharsetEncoder.encode(input: CharSequence, fromIndex: Int = 0, toIndex: Int = input.length) = buildPacket {\n    encodeToImpl(this, input, fromIndex, toIndex)\n}\n\n@ExperimentalIoApi\nfun CharsetEncoder.encodeUTF8(input: ByteReadPacket) = buildPacket {\n    encodeUTF8(input, this)\n}\n\n// ----------------------------- DECODER -------------------------------------------------------------------------------\n\n@ExperimentalIoApi\nexpect abstract class CharsetDecoder\n\n/**\n * Decoder's charset it is created for.\n */\nexpect val CharsetDecoder.charset: Charset\n\n@ExperimentalIoApi\nfun CharsetDecoder.decode(input: Input, max: Int = Int.MAX_VALUE): String = buildString(minOf(max.toLong(), input.sizeEstimate()).toInt()) {\n    decode(input, this, max)\n}\n\n@ExperimentalIoApi\nexpect fun CharsetDecoder.decode(input: Input, dst: Appendable, max: Int): Int\n\n@ExperimentalIoApi\nexpect fun CharsetDecoder.decodeExactBytes(input: Input, inputLength: Int): String\n\n// ----------------------------- REGISTRY ------------------------------------------------------------------------------\nexpect object Charsets {\n    val UTF_8: Charset\n    val ISO_8859_1: Charset\n}\n\nexpect class MalformedInputException(message: String) : Throwable\n\n\n\n\n\n\n\n// ----------------------------- INTERNALS -----------------------------------------------------------------------------\n\n\ninternal expect fun CharsetEncoder.encodeImpl(input: CharSequence, fromIndex: Int, toIndex: Int, dst: IoBuffer): Int\n\ninternal expect fun CharsetEncoder.encodeComplete(dst: IoBuffer): Boolean\n\ninternal fun CharsetEncoder.encodeToByteArrayImpl1(\n    input: CharSequence,\n    fromIndex: Int = 0,\n    toIndex: Int = input.length\n): ByteArray {\n    var start = fromIndex\n    if (start >= toIndex) return EmptyByteArray\n    val single = IoBuffer.Pool.borrow()\n\n    try {\n        IoBuffer.NoPool\n        val rc = encodeImpl(input, start, toIndex, single)\n        start += rc\n        if (start == toIndex) {\n            val result = ByteArray(single.readRemaining)\n            single.readFully(result)\n            return result\n        }\n\n        val builder = BytePacketBuilder(0, IoBuffer.Pool)\n        builder.last(single.makeView())\n        encodeToImpl(builder, input, start, toIndex)\n        return builder.build().readBytes()\n    } finally {\n        single.release(IoBuffer.Pool)\n    }\n}\n\ninternal fun Input.sizeEstimate(): Long = when (this) {\n    is ByteReadPacket -> remaining\n    is ByteReadPacketBase -> maxOf(remaining, 16)\n    else -> 16\n}\n\n\nprivate fun CharsetEncoder.encodeCompleteImpl(dst: Output): Int {\n    var size = 1\n    var bytesWritten = 0\n\n    dst.writeWhile { view ->\n        val before = view.writeRemaining\n        if (encodeComplete(view)) {\n            size = 0\n        } else {\n            size++\n        }\n        bytesWritten += before - view.writeRemaining\n        size > 0\n    }\n\n    return bytesWritten\n}\n\n\ninternal fun CharsetEncoder.encodeToImpl(\n    destination: Output,\n    input: CharSequence,\n    fromIndex: Int,\n    toIndex: Int\n): Int {\n    var start = fromIndex\n    if (start >= toIndex) return 0\n\n    var bytesWritten = 0\n\n    destination.writeWhileSize(1) { view: IoBuffer ->\n        val before = view.writeRemaining\n        val rc = encodeImpl(input, start, toIndex, view)\n        check(rc >= 0)\n        start += rc\n        bytesWritten += before - view.writeRemaining\n\n        when {\n            start >= toIndex -> 0\n            rc == 0 -> 8\n            else -> 1\n        }\n    }\n\n    bytesWritten += encodeCompleteImpl(destination)\n    return bytesWritten\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * Builds new string by populating newly created [StringBuilder] using provided [builderAction]\n * and then converting it to [String].\n */\n@kotlin.internal.InlineOnly\npublic inline fun buildString(builderAction: StringBuilder.() -> Unit): String =\n    StringBuilder().apply(builderAction).toString()\n\n/**\n * Builds new string by populating newly created [StringBuilder] initialized with the given [capacity]\n * using provided [builderAction] and then converting it to [String].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun buildString(capacity: Int, builderAction: StringBuilder.() -> Unit): String =\n    StringBuilder(capacity).apply(builderAction).toString()\n\n/**\n * Appends all arguments to the given [Appendable].\n */\npublic fun <T : Appendable> T.append(vararg value: CharSequence?): T {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: String?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: Any?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n\ninternal fun <T> Appendable.appendElement(element: T, transform: ((T) -> CharSequence)?) {\n    when {\n        transform != null -> append(transform(element))\n        element is CharSequence? -> append(element)\n        element is Char -> append(element)\n        else -> append(element.toString())\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","@file:Suppress(\"RedundantModalityModifier\")\n\npackage kotlinx.io.core\n\nimport kotlinx.io.core.internal.*\nimport kotlinx.io.pool.*\n\n@Deprecated(\n    \"Use IoBuffer instead\",\n    replaceWith = ReplaceWith(\"IoBuffer\", \"kotlinx.io.core.IoBuffer\"),\n    level = DeprecationLevel.ERROR\n)\ntypealias BufferView = IoBuffer\n\n/**\n * A read-write facade to actual buffer of fixed size. Multiple views could share the same actual buffer.\n * Concurrent unsafe. The only concurrent-safe operation is [release].\n * In most cases [ByteReadPacket] and [BytePacketBuilder] should be used instead.\n */\nexpect class IoBuffer : Input, Output {\n    @Deprecated(\"Suppress warning.\", level = DeprecationLevel.HIDDEN)\n    final override val doNotImplementInputButExtendAbstractInputInstead: Nothing\n\n    @Deprecated(\"Suppress warning.\", level = DeprecationLevel.HIDDEN)\n    final override val doNotImplementOutputButExtendAbstractOutputInstead: Nothing\n\n    /**\n     * Reference to an origin buffer view this was copied from\n     */\n    internal val origin: IoBuffer?\n\n    /**\n     * Mutable reference to next buffer view. Useful to chain multiple views\n     */\n    var next: IoBuffer?\n\n    /**\n     * User data: could be a session, connection or anything useful\n     */\n    @ExperimentalIoApi\n    var attachment: Any?\n\n    /**\n     * Backing buffer capacity. Value for released buffer is unspecified\n     */\n    val capacity: Int\n\n    /**\n     * Amount of reserved bytes at the beginning\n     */\n    val startGap: Int\n\n    /**\n     * Amount of reserved bytes at the end\n     */\n    val endGap: Int\n\n    /**\n     * @return `true` if there are available bytes to be read\n     */\n    fun canRead(): Boolean\n\n    /**\n     * @return `true` if there is free room to for write\n     */\n    fun canWrite(): Boolean\n\n    /**\n     * Number of bytes available for read\n     */\n    val readRemaining: Int\n\n    /**\n     * Number of free bytes useful for writing. Doesn't include gaps.\n     */\n    val writeRemaining: Int\n\n    /**\n     * Reserves [n] bytes at the beginning. Could be invoked only once and only before writing.\n     */\n    fun reserveStartGap(n: Int)\n\n    /**\n     * Reserves [n] bytes at the end of buffer. Could be invoked only once and only if there are at least [n] bytes free\n     */\n    fun reserveEndGap(n: Int)\n\n    /**\n     * read and write operations byte-order (endianness)\n     */\n    @Deprecated(\"Read/write with readXXXLittleEndian/writeXXXLittleEndian or \" +\n        \"do readXXX/writeXXX with X.reverseByteOrder() instead.\")\n    final override var byteOrder: ByteOrder\n\n    final override fun readByte(): Byte\n    final override fun readShort(): Short\n    final override fun readInt(): Int\n    final override fun readLong(): Long\n    final override fun readFloat(): Float\n    final override fun readDouble(): Double\n\n    @Deprecated(\"Use readFully instead\", ReplaceWith(\"readFully(dst, offset, length)\"), level = DeprecationLevel.ERROR)\n    fun read(dst: ByteArray, offset: Int, length: Int)\n\n    final override fun readFully(dst: ByteArray, offset: Int, length: Int)\n    final override fun readFully(dst: ShortArray, offset: Int, length: Int)\n    final override fun readFully(dst: IntArray, offset: Int, length: Int)\n    final override fun readFully(dst: LongArray, offset: Int, length: Int)\n    final override fun readFully(dst: FloatArray, offset: Int, length: Int)\n    final override fun readFully(dst: DoubleArray, offset: Int, length: Int)\n    final override fun readFully(dst: IoBuffer, length: Int)\n\n    final override fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int\n    final override fun readAvailable(dst: ShortArray, offset: Int, length: Int): Int\n    final override fun readAvailable(dst: IntArray, offset: Int, length: Int): Int\n    final override fun readAvailable(dst: LongArray, offset: Int, length: Int): Int\n    final override fun readAvailable(dst: FloatArray, offset: Int, length: Int): Int\n    final override fun readAvailable(dst: DoubleArray, offset: Int, length: Int): Int\n    final override fun readAvailable(dst: IoBuffer, length: Int): Int\n\n    final override fun tryPeek(): Int\n\n    /**\n     * Copy available bytes to the specified [buffer] but keep them available.\n     * If the underlying implementation could trigger\n     * bytes population from the underlying source and block until any bytes available\n     *\n     * Very similar to [readAvailable] but don't discard copied bytes.\n     *\n     * @return number of bytes were copied\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun peekTo(buffer: IoBuffer): Int\n\n    @Deprecated(\"Use discardExact instead.\")\n    final override fun discard(n: Long): Long\n\n    /**\n     * Discards [n] bytes or fails if there is not enough bytes available for read.\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun discardExact(n: Int)\n\n    final override fun writeByte(v: Byte)\n    final override fun writeShort(v: Short)\n    final override fun writeInt(v: Int)\n    final override fun writeLong(v: Long)\n    final override fun writeFloat(v: Float)\n    final override fun writeDouble(v: Double)\n\n    final override fun writeFully(src: ByteArray, offset: Int, length: Int)\n    final override fun writeFully(src: ShortArray, offset: Int, length: Int)\n    final override fun writeFully(src: IntArray, offset: Int, length: Int)\n    final override fun writeFully(src: LongArray, offset: Int, length: Int)\n    final override fun writeFully(src: FloatArray, offset: Int, length: Int)\n    final override fun writeFully(src: DoubleArray, offset: Int, length: Int)\n    final override fun writeFully(src: IoBuffer, length: Int)\n\n    fun appendChars(csq: CharArray, start: Int, end: Int): Int\n    fun appendChars(csq: CharSequence, start: Int, end: Int): Int\n\n    final override fun append(c: Char): Appendable\n    final override fun append(csq: CharSequence?): Appendable\n    final override fun append(csq: CharSequence?, start: Int, end: Int): Appendable\n    final override fun append(csq: CharArray, start: Int, end: Int): Appendable\n\n    final override fun fill(n: Long, v: Byte)\n\n    override fun close()\n\n    /**\n     * Writes exactly [length] bytes of [array] starting from [offset] position or fails if not enough free space\n     */\n    @Deprecated(\"Use writeFully instead\", level = DeprecationLevel.ERROR)\n    fun write(array: ByteArray, offset: Int, length: Int)\n\n    /**\n     * Writes [length] bytes of [src] buffer or fails if not enough free space available\n     */\n    @Deprecated(\"Use writeFully instead\", ReplaceWith(\"writeFully(src, length)\"), level = DeprecationLevel.ERROR)\n    fun writeBuffer(src: IoBuffer, length: Int): Int\n\n    internal fun restoreStartGap(n: Int)\n    internal fun restoreEndGap(n: Int)\n\n    internal fun writeBufferPrepend(other: IoBuffer)\n    internal fun writeBufferAppend(other: IoBuffer, maxSize: Int)\n\n    /**\n     * Push back [n] bytes: only possible if there were at least [n] bytes read before this operation.\n     */\n    fun pushBack(n: Int)\n\n    /**\n     * Marks the whole buffer available for write and no bytes for read.\n     */\n    fun resetForWrite()\n\n    /**\n     * Marks up to [limit] bytes of the buffer available for write and no bytes for read\n     */\n    fun resetForWrite(limit: Int)\n\n    /**\n     * Marks the whole buffer available for read and no for write\n     */\n    fun resetForRead()\n\n    /**\n     * @return `true` if and only if the are no buffer views that share the same actual buffer. This actually does\n     * refcount and only work guaranteed if other views created/not created via [makeView] function.\n     * One can instantiate multiple buffers with the same buffer and this function will return `true` in spite of\n     * the fact that the buffer is actually shared.\n     */\n    @ExperimentalIoApi\n    fun isExclusivelyOwned(): Boolean\n\n    /**\n     * Creates a new view to the same actual buffer with independent read and write positions and gaps\n     */\n    fun makeView(): IoBuffer\n\n    /**\n     * releases buffer view and returns it to the [pool] if there are no more usages. Based on simple ref-couting so\n     * it is very fragile.\n     */\n    fun release(pool: ObjectPool<IoBuffer>)\n\n    final override fun flush()\n\n    companion object {\n        /**\n         * Number of bytes usually reserved in the end of chunk\n         * when several instances of [IoBuffer] are connected into a chain (usually inside of [ByteReadPacket]\n         * or [BytePacketBuilder])\n         */\n        @Deprecated(\"This implementation detail is going to become internal.\")\n        val ReservedSize: Int\n\n        /**\n         * The empty buffer singleton: it has zero capacity for read and write.\n         */\n        val Empty: IoBuffer\n\n        /**\n         * The default buffer pool\n         */\n        val Pool: ObjectPool<IoBuffer>\n\n        /**\n         * Pool that always instantiates new buffers instead of reusing it\n         */\n        val NoPool: ObjectPool<IoBuffer>\n\n        /**\n         * A pool that always returns [IoBuffer.Empty]\n         */\n        val EmptyPool: ObjectPool<IoBuffer>\n    }\n}\n\n@Deprecated(\n    \"Use IoBuffer.EmptyPool instead.\",\n    replaceWith = ReplaceWith(\"IoBuffer.EmptyPool\", \"kotlinx.io.core.IoBuffer\"),\n    level = DeprecationLevel.ERROR\n)\nval EmptyBufferViewPool get() = IoBuffer.EmptyPool\n\ninternal object EmptyBufferPoolImpl : NoPoolImpl<IoBuffer>() {\n    override fun borrow() = IoBuffer.Empty\n}\n\ninternal tailrec fun IoBuffer?.releaseAll(pool: ObjectPool<IoBuffer>) {\n    if (this == null) return\n    val next = next\n    this.next = null\n    release(pool)\n    next.releaseAll(pool)\n}\n\n/**\n * Copy every element of the chain starting from this and setup next links.\n */\ninternal fun IoBuffer.copyAll(): IoBuffer {\n    val copied = makeView()\n    val next = this.next ?: return copied\n\n    return next.copyAll(copied, copied)\n}\n\nprivate tailrec fun IoBuffer.copyAll(head: IoBuffer, prev: IoBuffer): IoBuffer {\n    val copied = makeView()\n    prev.next = copied\n\n    val next = this.next ?: return head\n\n    return next.copyAll(head, copied)\n}\n\ninternal tailrec fun IoBuffer.findTail(): IoBuffer {\n    val next = this.next ?: return this\n    return next.findTail()\n}\n\n/**\n * Summarize remainings of all elements of the chain\n */\n@DangerousInternalIoApi\nfun IoBuffer.remainingAll(): Long = remainingAll(0L)\n\nprivate tailrec fun IoBuffer.remainingAll(n: Long): Long {\n    val rem = readRemaining.toLong() + n\n    val next = this.next ?: return rem\n\n    return next.remainingAll(rem)\n}\n\ninternal tailrec fun IoBuffer.isEmpty(): Boolean {\n    if (readRemaining > 0) return false\n    val next = this.next ?: return true\n    return next.isEmpty()\n}\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Long.coerceAtMostMaxInt(): Int = minOf(this, Int.MAX_VALUE.toLong()).toInt()\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Long.coerceAtMostMaxIntOrFail(message: String): Int {\n    if (this > Int.MAX_VALUE.toLong()) throw IllegalArgumentException(message)\n    return this.toInt()\n}\n\nclass BufferLimitExceededException(message: String) : Exception(message)\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.comparisons\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\n\n/**\n * Returns the greater of two values.\n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T): T {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Byte, b: Byte): Byte {\n    return Math.max(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Short, b: Short): Short {\n    return Math.max(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Int, b: Int): Int {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"DEPRECATION_ERROR\", \"NOTHING_TO_INLINE\")\npublic actual inline fun maxOf(a: Long, b: Long): Long {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Float, b: Float): Float {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Double, b: Double): Double {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T, c: T): T {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Byte, b: Byte, c: Byte): Byte {\n    return Math.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Short, b: Short, c: Short): Short {\n    return Math.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Int, b: Int, c: Int): Int {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Long, b: Long, c: Long): Long {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Float, b: Float, c: Float): Float {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Double, b: Double, c: Double): Double {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the smaller of two values.\n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T): T {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Byte, b: Byte): Byte {\n    return Math.min(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Short, b: Short): Short {\n    return Math.min(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Int, b: Int): Int {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"DEPRECATION_ERROR\", \"NOTHING_TO_INLINE\")\npublic actual inline fun minOf(a: Long, b: Long): Long {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Float, b: Float): Float {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Double, b: Double): Double {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T, c: T): T {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Byte, b: Byte, c: Byte): Byte {\n    return Math.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Short, b: Short, c: Short): Short {\n    return Math.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Int, b: Int, c: Int): Int {\n    return Math.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Long, b: Long, c: Long): Long {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Float, b: Float, c: Float): Float {\n    return Math.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Double, b: Double, c: Double): Double {\n    return Math.min(a, b, c)\n}\n\n","package kotlinx.io.core\n\nimport kotlinx.io.core.internal.*\n\n/**\n * Shouldn't be implemented directly. Inherit [AbstractInput] instead.\n */\nexpect interface Input : Closeable {\n    @Deprecated(\n        \"Implementing this interface is highly experimental. Extend AbstractInput instead.\",\n        level = DeprecationLevel.HIDDEN\n    )\n    val doNotImplementInputButExtendAbstractInputInstead: Nothing\n\n    @Deprecated(\"Use readXXXLittleEndian or readXXX then X.reverseByteOrder() instead.\")\n    var byteOrder: ByteOrder\n    val endOfInput: Boolean\n\n    fun readByte(): Byte\n    fun readShort(): Short\n    fun readInt(): Int\n    fun readLong(): Long\n    fun readFloat(): Float\n    fun readDouble(): Double\n\n    fun readFully(dst: ByteArray, offset: Int, length: Int)\n    fun readFully(dst: ShortArray, offset: Int, length: Int)\n    fun readFully(dst: IntArray, offset: Int, length: Int)\n    fun readFully(dst: LongArray, offset: Int, length: Int)\n    fun readFully(dst: FloatArray, offset: Int, length: Int)\n    fun readFully(dst: DoubleArray, offset: Int, length: Int)\n    fun readFully(dst: IoBuffer, length: Int = dst.writeRemaining)\n\n    fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int\n    fun readAvailable(dst: ShortArray, offset: Int, length: Int): Int\n    fun readAvailable(dst: IntArray, offset: Int, length: Int): Int\n    fun readAvailable(dst: LongArray, offset: Int, length: Int): Int\n    fun readAvailable(dst: FloatArray, offset: Int, length: Int): Int\n    fun readAvailable(dst: DoubleArray, offset: Int, length: Int): Int\n    fun readAvailable(dst: IoBuffer, length: Int): Int\n\n    /*\n     * Returns next byte (unsigned) or `-1` if no more bytes available\n     */\n    fun tryPeek(): Int\n\n    /**\n     * Copy available bytes to the specified [buffer] but keep them available.\n     * The underlying implementation could trigger\n     * bytes population from the underlying source and block until any bytes available.\n     *\n     * Very similar to [readAvailable] but don't discard copied bytes.\n     *\n     * @return number of bytes were copied\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun peekTo(buffer: IoBuffer): Int\n\n    /**\n     * Discard at most [n] bytes\n     */\n    @Deprecated(\"Use discardExact instead.\")\n    fun discard(n: Long): Long\n\n    override fun close()\n}\n\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readFully(dst: ByteArray, offset: Int = 0, length: Int = dst.size - offset) {\n    return readFully(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readFully(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset) {\n    return readFully(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readFully(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset) {\n    return readFully(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readFully(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset) {\n    return readFully(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readFully(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset) {\n    return readFully(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readFully(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset) {\n    return readFully(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readFully(dst: IoBuffer, length: Int = dst.writeRemaining) {\n    return readFully(dst, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readAvailable(dst: ByteArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailable(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readAvailable(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailable(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readAvailable(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailable(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readAvailable(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailable(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readAvailable(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailable(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readAvailable(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailable(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readAvailable(dst: IoBuffer, length: Int = dst.writeRemaining): Int {\n    return readAvailable(dst, length)\n}\n\n/**\n * Discard all remaining bytes.\n *\n * @return number of bytes were discarded\n */\nfun Input.discard(): Long {\n    @Suppress(\"DEPRECATION\")\n    return discard(Long.MAX_VALUE)\n}\n\n/**\n * Discard exactly [n] bytes or fail if not enough bytes available.\n *\n * @throws EOFException when not enough bytes available to discard the specified number of bytes.\n */\nfun Input.discardExact(n: Long) {\n    @Suppress(\"DEPRECATION\")\n    val discarded = discard(n)\n    if (discarded != n) {\n        throw EOFException(\"Only $discarded bytes were discarded of $n requested\")\n    }\n}\n\n/**\n * Discard exactly [n] bytes or fail if not enough bytes available.\n *\n * @throws EOFException when not enough bytes available to discard the specified number of bytes.\n */\nfun Input.discardExact(n: Int) {\n    discardExact(n.toLong())\n}\n\n/**\n * Invoke [block] function for every chunk until end of input or [block] function return `false`\n * [block] function returns `true` to request more chunks or `false` to stop loop\n *\n * It is not guaranteed that every chunk will have fixed size but it will be never empty.\n * [block] function should never release provided buffer and should not write to it otherwise an undefined behaviour\n * could be observed\n */\n@Deprecated(\"This is going to become internal. Use peekTo instead.\")\ninline fun Input.takeWhile(block: (IoBuffer) -> Boolean) {\n    var release = true\n    var current = prepareReadFirstHead(1) ?: return\n\n    try {\n        do {\n            if (!block(current)) {\n                break\n            }\n            release = false\n            val next = prepareReadNextHead(current) ?: break\n            current = next\n            release = true\n        } while (true)\n    } finally {\n        if (release) {\n            completeReadHead(current)\n        }\n    }\n}\n\n/**\n * Invoke [block] function for every chunk until end of input or [block] function return zero\n * [block] function returns number of bytes required to read next primitive and shouldn't require too many bytes at once\n * otherwise it could fail with an exception.\n * It is not guaranteed that every chunk will have fixed size but it will be always at least requested bytes length.\n * [block] function should never release provided buffer and should not write to it otherwise an undefined behaviour\n * could be observed\n */\n@Deprecated(\"This is going to become internal. Use peekTo instead.\")\ninline fun Input.takeWhileSize(initialSize: Int = 1, block: (IoBuffer) -> Int) {\n    var release = true\n    var current = prepareReadFirstHead(initialSize) ?: return\n    var size = initialSize\n\n    try {\n        do {\n            val before = current.readRemaining\n            val after: Int\n\n            if (before >= size) {\n                try {\n                    size = block(current)\n                } finally {\n                    after = current.readRemaining\n                }\n            } else {\n                after = before\n            }\n\n            release = false\n\n            val next = when {\n                after == 0 -> prepareReadNextHead(current)\n                after < size || current.endGap < IoBuffer.ReservedSize -> {\n                    completeReadHead(current)\n                    prepareReadFirstHead(size)\n                }\n                else -> current\n            }\n\n            if (next == null) {\n                release = false\n                break\n            }\n\n            current = next\n            release = true\n        } while (size > 0)\n    } finally {\n        if (release) {\n            completeReadHead(current)\n        }\n    }\n}\n\n@ExperimentalIoApi\nfun Input.peekCharUtf8(): Char {\n    val rc = tryPeek()\n    if (rc and 0x80 == 0) return rc.toChar()\n    if (rc == -1) throw EOFException(\"Failed to peek a char: end of input\")\n\n    return peekCharUtf8Impl(rc)\n}\n\nprivate fun Input.peekCharUtf8Impl(first: Int): Char {\n    var rc = '?'\n    var found = false\n\n    takeWhileSize(byteCountUtf8(first)) {\n        it.decodeUTF8 { ch ->\n            found = true\n            rc = ch\n            false\n        }\n    }\n\n    if (!found) {\n        throw MalformedUTF8InputException(\"No UTF-8 character found\")\n    }\n\n    return rc\n}\n","@file:Suppress(\"RedundantModalityModifier\")\n\npackage kotlinx.io.core\n\nimport kotlinx.io.core.internal.*\nimport kotlinx.io.errors.IOException\nimport kotlinx.io.pool.*\n\n/**\n * Read-only immutable byte packet. Could be consumed only once however it does support [copy] that doesn't copy every byte\n * but creates a new view instead. Once packet created it should be either completely read (consumed) or released\n * via [release].\n */\n@DangerousInternalIoApi\nabstract class ByteReadPacketBase(@PublishedApi internal var head: IoBuffer,\n                                  remaining: Long = head.remainingAll(),\n                                  val pool: ObjectPool<IoBuffer>) : Input {\n\n    init {\n        head.setByteOrderForNonEmpty(ByteOrder.BIG_ENDIAN)\n    }\n\n    @Deprecated(\n        \"Suppress warning.\",\n        level = DeprecationLevel.HIDDEN\n    )\n    @Suppress(\"unused\")\n    final override val doNotImplementInputButExtendAbstractInputInstead: Nothing\n        get() = error(\"Should be never accessed.\")\n\n    @Deprecated(\"Use readXXXLittleEndian or readXXX then X.reverseByteOrder() instead.\")\n    final override var byteOrder: ByteOrder = ByteOrder.BIG_ENDIAN\n        set(newOrder) {\n            field = newOrder\n            head.setByteOrderForNonEmpty(newOrder)\n        }\n\n    /**\n     * Number of bytes available for read\n     */\n    val remaining: Long get() = headRemaining.toLong() + tailRemaining\n\n    @Deprecated(\"For compatibility purpose\", level = DeprecationLevel.HIDDEN)\n    fun getRemaining(): Int = remaining.coerceAtMostMaxInt()\n\n    /**\n     * @return `true` if there is at least one byte to read\n     */\n    fun canRead() = tailRemaining != 0L || head.canRead()\n\n    /**\n     * @return `true` if there are at least [n] bytes to read\n     */\n    fun hasBytes(n: Int) = headRemaining + tailRemaining >= n\n\n    @PublishedApi\n    internal var headRemaining = head.readRemaining\n\n    private var tailRemaining: Long = remaining - headRemaining\n\n    /**\n     * `true` if no bytes available for read\n     */\n    val isEmpty: Boolean\n        get() = headRemaining == 0 && tailRemaining == 0L && noMoreChunksAvailable\n\n    val isNotEmpty: Boolean\n        get() = headRemaining > 0 || tailRemaining > 0L || !noMoreChunksAvailable\n\n    private var noMoreChunksAvailable = false\n    override val endOfInput: Boolean\n        get() = isEmpty && (noMoreChunksAvailable || doFill() == null)\n\n    /**\n     * Returns a copy of the packet. The original packet and the copy could be used concurrently. Both need to be\n     * either completely consumed or released via [release]\n     */\n    fun copy(): ByteReadPacket = ByteReadPacket(head.copyAll(), remaining, pool)\n\n    /**\n     * Release packet. After this function invocation the packet becomes empty. If it has been copied via [copy]\n     * then the copy should be released as well.\n     */\n    fun release() {\n        val head = head\n        val empty = IoBuffer.Empty\n\n        if (head !== empty) {\n            this.head = empty\n            headRemaining = 0\n            tailRemaining = 0\n            head.releaseAll(pool)\n        }\n    }\n\n    override fun close() {\n        release()\n        if (!noMoreChunksAvailable) {\n            noMoreChunksAvailable = true\n        }\n        closeSource()\n    }\n\n    internal fun stealAll(): IoBuffer? {\n        val head = head\n        val empty = IoBuffer.Empty\n\n        if (head === empty) return null\n        this.head = empty\n        headRemaining = 0\n        tailRemaining = 0\n        return head\n    }\n\n    internal fun steal(): IoBuffer? {\n        val head = head\n        val next = head.next\n        val empty = IoBuffer.Empty\n        if (head === empty) return null\n\n        val nextRemaining = next?.readRemaining ?: 0\n\n        this.head = next ?: empty\n        this.headRemaining = nextRemaining\n        this.tailRemaining -= nextRemaining\n        head.next = null\n\n        return head\n    }\n\n    internal fun append(chain: IoBuffer) {\n        if (chain === IoBuffer.Empty) return\n\n        val size = chain.remainingAll()\n        if (head === IoBuffer.Empty) {\n            head = chain\n            headRemaining = chain.readRemaining\n            tailRemaining = size - headRemaining\n        } else {\n            head.findTail().next = chain\n            tailRemaining += size\n        }\n        @Suppress(\"DEPRECATION\")\n        chain.byteOrder = byteOrder\n    }\n\n    internal fun tryWriteAppend(chain: IoBuffer): Boolean {\n        val tail = head.findTail()\n        val size = chain.readRemaining\n\n        if (size == 0 || tail.writeRemaining < size) return false\n        tail.writeBufferAppend(chain, size)\n\n        if (head === tail) {\n            headRemaining += size\n        } else {\n            tailRemaining += size\n        }\n\n        return true\n    }\n\n    final override fun readByte(): Byte {\n        val headRemaining = headRemaining\n        if (headRemaining > 1) {\n            this.headRemaining = headRemaining - 1\n            return head.readByte()\n        }\n\n        return readByteSlow2()\n    }\n\n    private fun readByteSlow2(): Byte {\n        val head = head\n        val headRemaining = headRemaining\n\n        if (headRemaining == 1) {\n            this.headRemaining = headRemaining - 1\n            return head.readByte().also { ensureNext(head) }\n        } else {\n            return readByteSlow(head)\n        }\n    }\n\n    private fun readByteSlow(head: IoBuffer): Byte {\n        ensureNext(head) ?: throw EOFException(\"One more byte required but reached end of input\")\n        return readByte()\n    }\n\n    final override fun readShort() = readN(2) { readShort() }\n    final override fun readFloat() = readN(4) { readFloat() }\n    final override fun readDouble() = readN(8) { readDouble() }\n\n    final override fun readInt(): Int {\n        val headRemaining = headRemaining\n        if (headRemaining > 4) {\n            this.headRemaining = headRemaining - 4\n            return head.readInt()\n        }\n\n        return readIntSlow()\n    }\n\n    private fun readIntSlow(): Int = readN(4) { readInt() }\n\n    final override fun readLong(): Long {\n        val headRemaining = headRemaining\n        if (headRemaining > 8) {\n            this.headRemaining = headRemaining - 8\n            return head.readLong()\n        }\n\n        return readLongSlow()\n    }\n\n    private fun readLongSlow(): Long = readN(8) { readLong() }\n\n    /**\n     * Read as much bytes as possible to [dst] array\n     * @return number of bytes copied\n     */\n    fun readAvailable(dst: ByteArray): Int = readAvailable(dst, 0, dst.size)\n\n    /**\n     * Read at most [length] bytes to [dst] array and write them at [offset]\n     * @return number of bytes copied to the array\n     */\n    final override fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int {\n        require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n        require(length >= 0) { \"length shouldn't be negative: $length\" }\n        require(offset + length <= dst.size) { \"offset ($offset) + length ($length) > dst.size (${dst.size})\" }\n\n        return readAsMuchAsPossible(dst, offset, length, 0)\n    }\n\n    /**\n     * Read exactly [length] bytes to [dst] array at specified [offset]\n     */\n    final override fun readFully(dst: ByteArray, offset: Int, length: Int) {\n        val rc = readAvailable(dst, offset, length)\n        if (rc != length) throw EOFException(\"Not enough data in packet to fill buffer: ${length - rc} more bytes required\")\n    }\n\n    /**\n     * Discards at most [n] bytes\n     * @return number of bytes has been discarded\n     */\n    @Deprecated(\"Use discardExact instead.\")\n    final fun discard(n: Int) = discardAsMuchAsPossible(n, 0)\n\n    /**\n     * Discards exactly [n] bytes or fails with [EOFException]\n     */\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final fun discardExact(n: Int) {\n        if (discard(n) != n) throw EOFException(\"Unable to discard $n bytes due to end of packet\")\n    }\n\n    @PublishedApi\n    internal inline fun read(block: (IoBuffer) -> Unit) {\n        read(1, block)\n    }\n\n    @PublishedApi\n    internal inline fun read(n: Int, block: (IoBuffer) -> Unit) {\n        val head = head\n        var before = head.readRemaining\n        val buffer = if (before < n) {\n            prepareRead(n, head).also { before = it?.readRemaining ?: 0 }\n        } else {\n            head\n        }\n\n        if (buffer != null) {\n            block(buffer)\n            val after = buffer.readRemaining\n            val delta = before - after\n            if (delta > 0) {\n                headRemaining -= delta\n            }\n            if (after == 0) {\n                ensureNext(buffer)\n            }\n        }\n    }\n\n    final override fun readFully(dst: ShortArray, offset: Int, length: Int) {\n        var copied = 0\n        takeWhile { buffer ->\n            val rc = buffer.readAvailable(dst, offset + copied, length - copied)\n            if (rc == -1) throw EOFException(\"Unexpected EOF while reading $length bytes\")\n            copied += rc\n            copied < length\n        }\n\n        if (copied != length) {\n            throw EOFException(\"Not enough bytes available to read $length short integers, $copied were copied\")\n        }\n    }\n\n    final override fun readAvailable(dst: ShortArray, offset: Int, length: Int): Int {\n        val remaining = remaining\n        if (remaining == 0L) {\n            if (doFill() == null) return -1\n            return readAvailable(dst, offset, length)\n        }\n        val size = minOf(remaining, length.toLong()).toInt()\n        readFully(dst, offset, size)\n        return size\n    }\n\n    final override fun readFully(dst: IntArray, offset: Int, length: Int) {\n        var copied = 0\n        takeWhile { buffer ->\n            val rc = buffer.readAvailable(dst, offset + copied, length - copied)\n            if (rc == -1) throw EOFException(\"Unexpected EOF while read $length short integers\")\n            copied += rc\n            copied < length\n        }\n\n        if (copied != length) {\n            throw EOFException(\"Not enough bytes available to read $length integers, $copied were copied\")\n        }\n    }\n\n    final override fun readAvailable(dst: IntArray, offset: Int, length: Int): Int {\n        val remaining = remaining\n        if (remaining == 0L) {\n            if (doFill() == null) return -1\n            return readAvailable(dst, offset, length)\n        }\n        val size = minOf(remaining, length.toLong()).toInt()\n        readFully(dst, offset, size)\n        return size\n    }\n\n    final override fun readFully(dst: LongArray, offset: Int, length: Int) {\n        var copied = 0\n        takeWhile { buffer ->\n            val rc = buffer.readAvailable(dst, offset + copied, length - copied)\n            if (rc == -1) throw EOFException(\"Unexpected EOF while reading $length long integers\")\n            copied += rc\n            copied < length\n        }\n\n        if (copied != length) {\n            throw EOFException(\"Not enough bytes available to read $length long integers, $copied were copied\")\n        }\n    }\n\n    final override fun readAvailable(dst: LongArray, offset: Int, length: Int): Int {\n        val remaining = remaining\n        if (remaining == 0L) {\n            if (doFill() == null) return -1\n            return readAvailable(dst, offset, length)\n        }\n        val size = minOf(remaining, length.toLong()).toInt()\n        readFully(dst, offset, size)\n        return size\n    }\n\n    final override fun readFully(dst: FloatArray, offset: Int, length: Int) {\n        var copied = 0\n        takeWhile { buffer ->\n            val rc = buffer.readAvailable(dst, offset + copied, length - copied)\n            if (rc == -1) throw EOFException(\"Unexpected EOF while read $length float number\")\n            copied += rc\n            copied < length\n        }\n\n        if (copied != length) {\n            throw EOFException(\"Not enough bytes available to read $length float numbers, $copied were copied\")\n        }\n    }\n\n    final override fun readAvailable(dst: FloatArray, offset: Int, length: Int): Int {\n        val remaining = remaining\n        if (remaining == 0L) {\n            if (doFill() == null) return -1\n            return readAvailable(dst, offset, length)\n        }\n        val size = minOf(remaining, length.toLong()).toInt()\n        readFully(dst, offset, size)\n        return size\n    }\n\n    final override fun readFully(dst: DoubleArray, offset: Int, length: Int) {\n        var copied = 0\n        takeWhile { buffer ->\n            val rc = buffer.readAvailable(dst, offset + copied, length - copied)\n            if (rc == -1) throw EOFException(\"Unexpected EOF while reading $length double float numbers\")\n            copied += rc\n            copied < length\n        }\n\n        if (copied != length) {\n            throw EOFException(\"Not enough bytes available to read $length double numbers, $copied were copied\")\n        }\n    }\n\n    final override fun readAvailable(dst: DoubleArray, offset: Int, length: Int): Int {\n        val remaining = remaining\n        if (remaining == 0L) {\n            if (doFill() == null) return -1\n            return readAvailable(dst, offset, length)\n        }\n        val size = minOf(remaining, length.toLong()).toInt()\n        readFully(dst, offset, size)\n        return size\n    }\n\n    final override fun readFully(dst: IoBuffer, length: Int) {\n        require(length <= dst.writeRemaining) { \"Not enough free space in destination buffer to write $length bytes\" }\n\n        var copied = 0\n        takeWhile { buffer ->\n            val rc = buffer.readAvailable(dst, length - copied)\n            if (rc > 0) copied += rc\n            copied < length\n        }\n\n        if (copied != length) {\n            throw EOFException(\"Not enough bytes available to read $length bytes, $copied were copied\")\n        }\n    }\n\n    final override fun readAvailable(dst: IoBuffer, length: Int): Int {\n        val remaining = remaining\n        if (remaining == 0L) {\n            if (doFill() == null) return -1\n            return readAvailable(dst, length)\n        }\n        val size = minOf(remaining, length.toLong(), dst.writeRemaining.toLong()).toInt()\n        readFully(dst, size)\n        return size\n    }\n\n    /*\n     * Returns next byte (unsigned) or `-1` if no more bytes available\n     */\n    final override fun tryPeek(): Int {\n        val head = head\n        if (headRemaining > 0) {\n            return head.tryPeek()\n        }\n\n        if (tailRemaining == 0L && noMoreChunksAvailable) return -1\n\n        return prepareRead(1, head)?.tryPeek() ?: -1\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun peekTo(buffer: IoBuffer): Int {\n        return peekTo(buffer)\n    }\n\n    @Deprecated(\"Use discardExact instead.\")\n    final override fun discard(n: Long): Long {\n        return discardAsMuchAsPossible(minOf(Int.MAX_VALUE.toLong(), n).toInt(), 0).toLong()\n    }\n\n    internal fun readCbuf(cbuf: CharArray, off: Int, len: Int): Int {\n        if (isEmpty) return -1\n\n        val out = object : Appendable {\n            private var idx = off\n\n            override fun append(c: Char): Appendable {\n                cbuf[idx++] = c\n                return this\n            }\n\n            override fun append(csq: CharSequence?): Appendable {\n                if (csq is String) {\n                    csq.getCharsInternal(cbuf, idx)\n                    idx += csq.length\n                }\n                else if (csq != null) {\n                    for (i in 0 until csq.length) {\n                        cbuf[idx++] = csq[i]\n                    }\n                }\n\n                return this\n            }\n\n            override fun append(csq: CharSequence?, start: Int, end: Int): Appendable {\n                throw UnsupportedOperationException()\n            }\n        }\n\n        return readText(out, 0, len)\n    }\n\n    /**\n     * Read at least [min] and at most [max] characters and append them to [out]\n     * @return number of characters appended\n     */\n    fun readText(out: Appendable, min: Int = 0, max: Int = Int.MAX_VALUE): Int {\n        if (max.toLong() >= remaining) {\n            val s = readTextExactBytes(bytesCount = remaining.toInt())\n            out.append(s)\n            return s.length\n        }\n        return readASCII(out, min, max)\n    }\n\n    /**\n     * Read exactly [exactCharacters] characters and append them to [out]\n     */\n    fun readTextExact(out: Appendable, exactCharacters: Int) {\n        readText(out, exactCharacters, exactCharacters)\n    }\n\n    /**\n     * Read a string at last [min] and at most [max] characters length\n     */\n    fun readText(min: Int = 0, max: Int = Int.MAX_VALUE): String {\n        if (min == 0 && (max == 0 || isEmpty)) return \"\"\n        val remaining = remaining\n        if (remaining > 0 && max.toLong() >= remaining) return readTextExactBytes(bytesCount = remaining.toInt())\n\n        return buildString(min.coerceAtLeast(16).coerceAtMost(max)) {\n            readASCII(this, min, max)\n        }\n    }\n\n    /**\n     * Read a string exactly [exactCharacters] length\n     */\n    fun readTextExact(exactCharacters: Int): String {\n        return readText(exactCharacters, exactCharacters)\n    }\n\n    private fun readASCII(out: Appendable, min: Int, max: Int): Int {\n        when {\n            max == 0 && min == 0 -> return 0\n            isEmpty -> if (min == 0) return 0 else atLeastMinCharactersRequire(min)\n            max < min -> minShouldBeLess(min, max)\n        }\n\n        var copied = 0\n        var utf8 = false\n\n        takeWhile { buffer ->\n            val rc = buffer.decodeASCII {\n                if (copied == max) false\n                else {\n                    out.append(it)\n                    copied++\n                    true\n                }\n            }\n\n            when {\n                rc -> true\n                copied == max -> false\n                else -> {\n                    utf8 = true\n                    false\n                }\n            }\n        }\n\n        if (utf8) {\n            return copied + readUtf8(out, min - copied, max - copied)\n        }\n        if (copied < min) prematureEndOfStreamChars(min, copied)\n        return copied\n    }\n\n    internal final fun peekToImpl(destination: IoBuffer, offset: Int, min: Int, max: Int): Int {\n        var current: IoBuffer = head\n        var copied = 0\n        var skip = offset\n\n        while (copied < min) {\n            val chunkSize = current.readRemaining\n            if (chunkSize > skip) {\n                val size = minOf(chunkSize - skip, max - copied)\n                current.readFully(destination, size)\n                skip = 0\n                copied += size\n            } else {\n                skip -= chunkSize\n            }\n\n            current = current.next ?: break\n        }\n\n        return copied\n    }\n\n    private fun atLeastMinCharactersRequire(min: Int): Nothing =\n        throw EOFException(\"at least $min characters required but no bytes available\")\n\n    private fun minShouldBeLess(min: Int, max: Int): Nothing =\n        throw IllegalArgumentException(\"min should be less or equal to max but min = $min, max = $max\")\n\n    private fun prematureEndOfStreamChars(min: Int, copied: Int): Nothing = throw MalformedUTF8InputException(\n        \"Premature end of stream: expected at least $min chars but had only $copied\"\n    )\n\n    private fun prematureEndOfStream(size: Int): Nothing =\n        throw MalformedUTF8InputException(\"Premature end of stream: expected $size bytes\")\n\n    private fun readUtf8(out: Appendable, min: Int, max: Int): Int {\n        var copied = 0\n\n        takeWhileSize { buffer ->\n            val size = buffer.decodeUTF8 {\n                if (copied == max) false\n                else {\n                    out.append(it)\n                    copied++\n                    true\n                }\n            }\n\n            when {\n                size == 0 -> 1\n                size > 0 -> size\n                else -> 0\n            }\n        }\n\n        if (copied < min) prematureEndOfStreamChars(min, copied)\n\n        return copied\n    }\n\n    private tailrec fun discardAsMuchAsPossible(n: Int, skipped: Int): Int {\n        if (n == 0) return skipped\n        val current = prepareRead(1) ?: return skipped\n        val size = minOf(current.readRemaining, n)\n        current.discardExact(size)\n        headRemaining -= size\n        afterRead()\n\n        return discardAsMuchAsPossible(n - size, skipped + size)\n    }\n\n    private tailrec fun readAsMuchAsPossible(array: ByteArray, offset: Int, length: Int, copied: Int): Int {\n        if (length == 0) return copied\n        val current = prepareRead(1) ?: return copied\n        val size = minOf(length, current.readRemaining)\n\n        current.readFully(array, offset, size)\n        headRemaining -= size\n\n        return if (size != length || current.readRemaining == 0) {\n            afterRead()\n            readAsMuchAsPossible(array, offset + size, length - size, copied + size)\n        } else {\n            copied + size\n        }\n    }\n\n    private inline fun <R> readN(n: Int, block: IoBuffer.() -> R): R {\n        val bb = prepareRead(n) ?: notEnoughBytesAvailable(n)\n        val rc = block(bb)\n\n        val after = bb.readRemaining\n        if (after == 0) {\n            ensureNext(bb)\n        } else {\n            headRemaining = after\n        }\n\n        return rc\n    }\n\n    private fun notEnoughBytesAvailable(n: Int): Nothing {\n        throw EOFException(\"Not enough data in packet ($remaining) to read $n byte(s)\")\n    }\n\n    @DangerousInternalIoApi\n    fun updateHeadRemaining(remaining: Int) {\n        headRemaining = remaining\n    }\n\n    @DangerousInternalIoApi\n    fun prepareReadHead(minSize: Int): IoBuffer? = prepareRead(minSize, head)\n\n    @DangerousInternalIoApi\n    fun ensureNextHead(current: IoBuffer): IoBuffer? = ensureNext(current)\n\n    @PublishedApi\n    internal fun ensureNext(current: IoBuffer) = ensureNext(current, IoBuffer.Empty)\n\n    @DangerousInternalIoApi\n    fun fixGapAfterRead(current: IoBuffer) {\n        val next = current.next ?: return fixGapAfterReadFallback(current)\n\n        val remaining = current.readRemaining\n        val overrunSize = minOf(remaining, IoBuffer.ReservedSize - current.endGap)\n        if (next.startGap < overrunSize) return fixGapAfterReadFallback(current)\n\n        next.restoreStartGap(overrunSize)\n\n        if (remaining > overrunSize) {\n            current.restoreEndGap(overrunSize)\n\n            this.headRemaining = remaining - overrunSize\n            this.tailRemaining += overrunSize\n        } else {\n            this.head = next\n            val nextSize = next.readRemaining\n            this.headRemaining = nextSize\n            this.tailRemaining -= nextSize - overrunSize\n\n            current.release(pool)\n        }\n    }\n\n    private fun fixGapAfterReadFallback(current: IoBuffer) {\n        if (noMoreChunksAvailable) {\n            this.headRemaining = current.readRemaining\n            this.tailRemaining = 0\n            return\n        }\n\n        val size = current.readRemaining\n        val overrun = minOf(size, IoBuffer.ReservedSize - current.endGap)\n\n        if (size > overrun) {\n            fixGapAfterReadFallbackUnreserved(current, size, overrun)\n        } else {\n            val new = pool.borrow()\n            new.reserveEndGap(IoBuffer.ReservedSize)\n            new.next = current.next\n\n            new.writeBufferAppend(current, size)\n            this.head = new\n            this.headRemaining = size\n            this.tailRemaining = 0L\n        }\n\n        current.release(pool)\n    }\n\n    private fun fixGapAfterReadFallbackUnreserved(current: IoBuffer, size: Int, overrun: Int) {\n        // if we have a chunk with no end reservation\n        // we can split it into two to fix it\n\n        val chunk1 = pool.borrow()\n        val chunk2 = pool.borrow()\n\n        chunk1.reserveEndGap(IoBuffer.ReservedSize)\n        chunk2.reserveEndGap(IoBuffer.ReservedSize)\n        chunk1.next = chunk2\n        chunk2.next = current.next\n\n        chunk1.writeBufferAppend(current, size - overrun)\n        chunk2.writeBufferAppend(current, overrun)\n\n        this.head = chunk1\n        this.headRemaining = chunk1.readRemaining\n        this.tailRemaining = chunk2.readRemaining.toLong()\n    }\n\n    private tailrec fun ensureNext(current: IoBuffer, empty: IoBuffer): IoBuffer? {\n        if (current === empty) {\n            return doFill()\n        }\n\n        val next = current.next\n        current.release(pool)\n\n        return when {\n            next == null -> {\n                this.headRemaining = 0\n                this.tailRemaining = 0L\n                this.head = empty\n                ensureNext(empty, empty)\n            }\n            next.canRead() -> {\n                head = next\n                @Suppress(\"DEPRECATION\")\n                next.byteOrder = byteOrder\n                val nextRemaining = next.readRemaining\n                headRemaining = nextRemaining\n                tailRemaining -= nextRemaining\n                next\n            }\n            else -> ensureNext(next, empty)\n        }\n    }\n\n    /**\n     * Reads the next chunk suitable for reading or `null` if no more chunks available. It is also allowed\n     * to return a chain of chunks linked through [IoBuffer.next]. The last chunk should have `null` next reference.\n     * Could rethrow exceptions from the underlying source.\n     */\n    protected abstract fun fill(): IoBuffer?\n\n    /**\n     * Should close the underlying bytes source. Could do nothing or throw exceptions.\n     */\n    protected abstract fun closeSource()\n\n    internal fun markNoMoreChunksAvailable() {\n        if (!noMoreChunksAvailable) {\n            noMoreChunksAvailable = true\n        }\n    }\n\n    private fun doFill(): IoBuffer? {\n        if (noMoreChunksAvailable) return null\n        val chunk = fill()\n        if (chunk == null) {\n            noMoreChunksAvailable = true\n            return null\n        }\n        appendView(chunk)\n        return chunk\n    }\n\n    private fun appendView(chunk: IoBuffer) {\n        val tail = head.findTail()\n        if (tail === IoBuffer.Empty) {\n            head = chunk\n            @Suppress(\"DEPRECATION\")\n            chunk.byteOrder = byteOrder\n            require(tailRemaining == 0L) { throw IllegalStateException(\"It should be no tail remaining bytes if current tail is EmptyBuffer\") }\n            headRemaining = chunk.readRemaining\n            tailRemaining = chunk.next?.remainingAll() ?: 0L\n        } else {\n            tail.next = chunk\n            tailRemaining += chunk.remainingAll()\n        }\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    internal inline fun prepareRead(minSize: Int): IoBuffer? = prepareRead(minSize, head)\n\n    @PublishedApi\n    internal tailrec fun prepareRead(minSize: Int, head: IoBuffer): IoBuffer? {\n        val headSize = headRemaining\n        if (headSize >= minSize) return head\n\n        val next = head.next ?: doFill() ?: return null\n        @Suppress(\"DEPRECATION\")\n        next.byteOrder = byteOrder\n\n        if (headSize == 0) {\n            if (head !== IoBuffer.Empty) {\n                releaseHead(head)\n            }\n\n            return prepareRead(minSize, next)\n        } else {\n            val before = next.readRemaining\n            head.writeBufferAppend(next, minSize - headSize)\n            val after = next.readRemaining\n            headRemaining = head.readRemaining\n            tailRemaining -= before - after\n            if (after == 0) {\n                head.next = next.next\n                next.release(pool)\n            }\n        }\n\n        if (head.readRemaining >= minSize) return head\n        if (minSize > IoBuffer.ReservedSize) minSizeIsTooBig(minSize)\n\n        return prepareRead(minSize, head)\n    }\n\n    internal fun prefetch(size: Int) {\n        if (headRemaining >= size) return\n        val head = head\n\n        val currentSize = head.remainingAll()\n        if (currentSize >= size || noMoreChunksAvailable) return\n\n        if (head === IoBuffer.Empty) {\n            doFill()\n            return prefetch(size)\n        }\n\n        prefetchLoop(size, currentSize, head)\n    }\n\n    private fun prefetchLoop(size: Int, currentSize0: Long, head: IoBuffer) {\n        var tail = head.findTail()\n        var currentSize = currentSize0\n        var tailRemaining = tailRemaining\n\n        do {\n            val chunk = fill()\n            if (chunk == null) {\n                noMoreChunksAvailable = true\n                break\n            }\n            val chunkSize = chunk.readRemaining\n            tail.next = chunk\n            tailRemaining += chunkSize\n            currentSize += chunkSize\n            tail = chunk\n        } while (currentSize < size)\n\n        this.tailRemaining = tailRemaining\n    }\n\n    private fun minSizeIsTooBig(minSize: Int): Nothing {\n        throw IllegalStateException(\"minSize of $minSize is too big (should be less than ${IoBuffer.ReservedSize}\")\n    }\n\n    private fun afterRead() {\n        val head = head\n        if (head.readRemaining == 0) {\n            releaseHead(head)\n        }\n    }\n\n    internal fun releaseHead(head: IoBuffer): IoBuffer {\n        val next = head.next ?: IoBuffer.Empty\n        this.head = next\n        val nextRemaining = next.readRemaining\n        this.headRemaining = nextRemaining\n        this.tailRemaining -= nextRemaining\n        head.release(pool)\n\n        return next\n    }\n\n    companion object {\n        @Deprecated(\n            \"Use ByteReadPacket.Empty instead\",\n            ReplaceWith(\"ByteReadPacket.Empty\"),\n            level = DeprecationLevel.ERROR\n        )\n        val Empty: ByteReadPacket\n            get() = ByteReadPacket.Empty\n\n        @Deprecated(\"This implementation detail is going to become internal.\", level = DeprecationLevel.ERROR)\n        val ReservedSize: Int = IoBuffer.ReservedSize\n    }\n}\n\nexpect class EOFException(message: String) : IOException\n\nprivate fun IoBuffer.setByteOrderForNonEmpty(newByteOrder: ByteOrder) {\n    if (canRead()) {\n        @Suppress(\"DEPRECATION\")\n        byteOrder = newByteOrder\n    }\n}\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage kotlinx.io.bits\n\n/**\n * Reverse number's byte order\n */\nactual fun Short.reverseByteOrder(): Short = swap(this)\n\n/**\n * Reverse number's byte order\n */\nactual fun Int.reverseByteOrder(): Int = swap(this)\n\n/**\n * Reverse number's byte order\n */\nactual fun Long.reverseByteOrder(): Long = swap(this)\n\n/**\n * Reverse number's byte order\n */\nactual fun Float.reverseByteOrder(): Float = swap(this)\n\n/**\n * Reverse number's byte order\n */\nactual fun Double.reverseByteOrder(): Double = swap(this)\n\n\nprivate inline fun swap(s: Short): Short = (((s.toInt() and 0xff) shl 8) or ((s.toInt() and 0xffff) ushr 8)).toShort()\n\nprivate inline fun swap(s: Int): Int =\n    (swap((s and 0xffff).toShort()).toInt() shl 16) or (swap((s ushr 16).toShort()).toInt() and 0xffff)\n\nprivate inline fun swap(s: Long): Long =\n    (swap((s and 0xffffffff).toInt()).toLong() shl 32) or (swap((s ushr 32).toInt()).toLong() and 0xffffffff)\n\nprivate inline fun swap(s: Float): Float = Float.fromBits(swap(s.toRawBits()))\n\nprivate inline fun swap(s: Double): Double = Double.fromBits(swap(s.toRawBits()))\n\n","package kotlinx.io.bits\n\n/**\n * Reverse number's byte order\n */\nexpect fun Short.reverseByteOrder(): Short\n\n/**\n * Reverse number's byte order\n */\nexpect fun Int.reverseByteOrder(): Int\n\n/**\n * Reverse number's byte order\n */\nexpect fun Long.reverseByteOrder(): Long\n\n/**\n * Reverse number's byte order\n */\nexpect fun Float.reverseByteOrder(): Float\n\n/**\n * Reverse number's byte order\n */\nexpect fun Double.reverseByteOrder(): Double\n\n/**\n * Reverse number's byte order\n */\n@ExperimentalUnsignedTypes\nfun UShort.reverseByteOrder(): UShort = toShort().reverseByteOrder().toUShort()\n\n/**\n * Reverse number's byte order\n */\n@ExperimentalUnsignedTypes\nfun UInt.reverseByteOrder(): UInt = toInt().reverseByteOrder().toUInt()\n\n/**\n * Reverse number's byte order\n */\n@ExperimentalUnsignedTypes\nfun ULong.reverseByteOrder(): ULong = toLong().reverseByteOrder().toULong()\n\n\n","package kotlinx.io.core\n\nimport kotlinx.io.core.internal.*\nimport kotlinx.io.pool.*\n\nexpect val PACKET_MAX_COPY_SIZE: Int\n\n/**\n * Build a byte packet in [block] lambda. Creates a temporary builder and releases it in case of failure\n */\ninline fun buildPacket(headerSizeHint: Int = 0, block: BytePacketBuilder.() -> Unit): ByteReadPacket {\n    val builder = BytePacketBuilder(headerSizeHint)\n    try {\n        block(builder)\n        return builder.build()\n    } catch (t: Throwable) {\n        builder.release()\n        throw t\n    }\n}\n\nexpect fun BytePacketBuilder(headerSizeHint: Int = 0): BytePacketBuilder\n\n/**\n * A builder that provides ability to build byte packets with no knowledge of it's size.\n * Unlike Java's ByteArrayOutputStream it doesn't copy the whole content every time it's internal buffer overflows\n * but chunks buffers instead. Packet building via [build] function is O(1) operation and only does instantiate\n * a new [ByteReadPacket]. Once a byte packet has been built via [build] function call, the builder could be\n * reused again. You also can discard all written bytes via [reset] or [release]. Please note that an instance of\n * builder need to be terminated either via [build] function invocation or via [release] call otherwise it will\n * cause byte buffer leak so that may have performance impact.\n *\n * Byte packet builder is also an [Appendable] so it does append UTF-8 characters to a packet\n *\n * ```\n * buildPacket {\n *     listOf(1,2,3).joinTo(this, separator = \",\")\n * }\n * ```\n */\nclass BytePacketBuilder(private var headerSizeHint: Int, pool: ObjectPool<IoBuffer>) :\n    @Suppress(\"DEPRECATION_ERROR\") BytePacketBuilderPlatformBase(pool) {\n    init {\n        require(headerSizeHint >= 0) { \"shouldn't be negative: headerSizeHint = $headerSizeHint\" }\n    }\n\n    /**\n     * Number of bytes written to the builder\n     */\n    val size: Int get() {\n        val size = _size\n        if (size == -1) {\n            _size = head.remainingAll().toInt()\n            return _size\n        }\n        return size\n    }\n\n    val isEmpty: Boolean get() {\n        val _size = _size\n        return when {\n            _size > 0 -> false\n            _size == 0 -> true\n            head.canRead() -> false\n            size == 0 -> true\n            else -> false\n        }\n    }\n\n    val isNotEmpty: Boolean get() {\n        val _size = _size\n        return when {\n            _size > 0 -> true\n            _size == 0 -> false\n            head.canRead() -> true\n            size > 0 -> true\n            else -> false\n        }\n    }\n\n    @PublishedApi\n    internal var head: IoBuffer = IoBuffer.Empty\n\n    override fun append(c: Char): BytePacketBuilder {\n        return super.append(c) as BytePacketBuilder\n    }\n\n    override fun append(csq: CharSequence?): BytePacketBuilder {\n        return super.append(csq) as BytePacketBuilder\n    }\n\n    override fun append(csq: CharSequence?, start: Int, end: Int): BytePacketBuilder {\n        return super.append(csq, start, end) as BytePacketBuilder\n    }\n\n    /**\n     * Release any resources that the builder holds. Builder shouldn't be used after release\n     */\n    override fun release() {\n        val head = this.head\n        val empty = IoBuffer.Empty\n\n        if (head !== empty) {\n            this.head = empty\n            this.tail = empty\n            head.releaseAll(pool)\n            _size = 0\n        }\n    }\n\n    override fun flush() {\n    }\n\n    override fun close() {\n        release()\n    }\n\n    /**\n     * Discard all written bytes and prepare to build another packet.\n     */\n    @Suppress(\"OverridingDeprecatedMember\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun reset() {\n        release()\n    }\n\n    /**\n     * Creates a temporary packet view of the packet being build without discarding any bytes from the builder.\n     * This is similar to `build().copy()` except that the builder keeps already written bytes untouched.\n     * A temporary view packet is passed as argument to [block] function and it shouldn't leak outside of this block\n     * otherwise an unexpected behaviour may occur.\n     */\n    fun <R> preview(block: (tmp: ByteReadPacket) -> R): R {\n        val packet = preview()\n\n        return try {\n            block(packet)\n        } finally {\n            packet.release()\n        }\n    }\n\n    @PublishedApi\n    internal final fun preview(): ByteReadPacket {\n        val head = head\n        return when {\n            head === IoBuffer.Empty -> ByteReadPacket.Empty\n            else -> ByteReadPacket(head.copyAll(), pool)\n        }\n    }\n\n    /**\n     * Builds byte packet instance and resets builder's state to be able to build another one packet if needed\n     */\n    fun build(): ByteReadPacket {\n        val size = size\n        val head = stealAll()\n\n        return when (head) {\n            null -> ByteReadPacket.Empty\n            else -> ByteReadPacket(head, size.toLong(), pool)\n        }\n    }\n\n    /**\n     * Detach all chunks and cleanup all internal state so builder could be reusable again\n     * @return a chain of buffer views or `null` of it is empty\n     */\n    internal fun stealAll(): IoBuffer? {\n        val head = this.head\n        val empty = IoBuffer.Empty\n\n        this.head = empty\n        this.tail = empty\n        this._size = 0\n\n        return if (head === empty) null else head\n    }\n\n    internal fun afterBytesStolen() {\n        val head = head\n        check(head.next == null)\n        _size = 0\n        head.resetForWrite()\n        head.reserveStartGap(headerSizeHint)\n        head.reserveEndGap(IoBuffer.ReservedSize)\n    }\n\n    /**\n     * Writes another packet to the end. Please note that the instance [p] gets consumed so you don't need to release it\n     */\n    override fun writePacket(p: ByteReadPacket) {\n        val foreignStolen = p.stealAll()\n        if (foreignStolen == null) {\n            p.release()\n            return\n        }\n\n        val tail = tail\n        if (tail === IoBuffer.Empty) {\n            head = foreignStolen\n            this.tail = foreignStolen.findTail()\n            _size = foreignStolen.remainingAll().toInt()\n            return\n        }\n\n        writePacketSlow(tail, foreignStolen, p)\n    }\n\n    private fun writePacketSlow(tail: IoBuffer, foreignStolen: IoBuffer, p: ByteReadPacket) {\n        val lastSize = tail.readRemaining\n        val nextSize = foreignStolen.readRemaining\n\n        val maxCopySize = PACKET_MAX_COPY_SIZE\n        val appendSize = if (nextSize < maxCopySize && nextSize <= (tail.endGap + tail.writeRemaining)) {\n            nextSize\n        } else -1\n\n        val prependSize = if (lastSize < maxCopySize && lastSize <= foreignStolen.startGap && foreignStolen.isExclusivelyOwned()) {\n            lastSize\n        } else -1\n\n        if (appendSize == -1 && prependSize == -1) {\n            // simply enqueue\n            tail.next = foreignStolen\n            this.tail = foreignStolen.findTail()\n            _size = head.remainingAll().toInt()\n        } else if (prependSize == -1 || appendSize <= prependSize) {\n            // do append\n            tail.writeBufferAppend(foreignStolen, tail.writeRemaining + tail.endGap)\n            tail.next = foreignStolen.next\n            this.tail = foreignStolen.findTail().takeUnless { it === foreignStolen } ?: tail\n            foreignStolen.release(p.pool)\n            _size = head.remainingAll().toInt()\n        } else if (appendSize == -1 || prependSize < appendSize) {\n            writePacketSlowPrepend(foreignStolen, tail)\n        } else {\n            throw IllegalStateException(\"prep = $prependSize, app = $appendSize\")\n        }\n    }\n\n    private fun writePacketSlowPrepend(foreignStolen: IoBuffer, tail: IoBuffer) {\n        // do prepend\n        foreignStolen.writeBufferPrepend(tail)\n\n        if (head === tail) {\n            head = foreignStolen\n        } else {\n            var pre = head\n            while (true) {\n                val next = pre.next!!\n                if (next === tail) break\n                pre = next\n            }\n\n            pre.next = foreignStolen\n        }\n        tail.release(pool)\n\n        this.tail = foreignStolen.findTail()\n        _size = head.remainingAll().toInt()\n    }\n\n    override fun last(buffer: IoBuffer) {\n        if (head === IoBuffer.Empty) {\n            if (buffer.isEmpty()) { // headerSize is just a hint so we shouldn't force to reserve space\n                buffer.reserveStartGap(headerSizeHint) // it will always fail for non-empty buffer\n            }\n            tail = buffer\n            head = buffer\n            _size = buffer.remainingAll().toInt()\n        } else {\n            tail.next = buffer\n            tail = buffer\n            _size = -1\n        }\n    }\n}\n\n/**\n * Discard all written bytes and prepare to build another packet.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun BytePacketBuilder.reset() {\n    release()\n}\n\n@DangerousInternalIoApi\n@Deprecated(\"Will be removed in future releases.\", level = DeprecationLevel.ERROR)\n@Suppress(\"DEPRECATION_ERROR\")\nexpect abstract class BytePacketBuilderPlatformBase\ninternal constructor(pool: ObjectPool<IoBuffer>) : BytePacketBuilderBase\n\n/**\n * This is the default [Output] implementation\n */\n@ExperimentalIoApi\nabstract class AbstractOutput(pool: ObjectPool<IoBuffer> = IoBuffer.Pool) :\n    @Suppress(\"DEPRECATION_ERROR\") BytePacketBuilderPlatformBase(pool) {\n    @Deprecated(\"Will be removed. Override flush(buffer) properly.\", level = DeprecationLevel.ERROR)\n    protected var currentTail: IoBuffer\n        get() = this.tail\n        set(newValue) {\n            this.tail = newValue\n        }\n\n    /**\n     * An implementation should write the whole [buffer] to the destination. It should never capture the [buffer] instance\n     * longer than this method execution since it will be disposed after return.\n     * There is no need to follow [buffer]'s next chunk: this function is invoked for every chunk.\n     */\n    protected abstract fun flush(buffer: IoBuffer)\n\n    /**\n     * An implementation should only close the destination.\n     */\n    protected abstract fun closeDestination()\n\n    @Deprecated(\"This makes no sense for anything except BytePacketBuilder.\")\n    final override fun reset() {\n    }\n\n    /**\n     * Invoked when a new [buffer] is appended for writing (usually it's empty)\n     */\n    final override fun last(buffer: IoBuffer) {\n        var current = tail\n        tail = buffer\n\n        if (current === IoBuffer.Empty) return\n\n        do {\n            val next = current.next\n            current.next = null\n\n            try {\n                flush(current)\n            } catch (t: Throwable) {\n                next?.releaseAll(pool)\n                throw t\n            } finally {\n                current.release(pool)\n            }\n\n            if (next == null) break\n            current = next\n        } while (true)\n    }\n\n    final override fun release() {\n        val tail = tail\n        this.tail = IoBuffer.Empty\n        if (tail !== IoBuffer.Empty) {\n            tail.release(pool)\n        }\n        closeDestination()\n    }\n\n    final override fun flush() {\n        last(IoBuffer.Empty)\n    }\n\n    /**\n     * Should flush and close the destination\n     */\n    final override fun close() {\n        try {\n            flush()\n        } finally {\n            release()\n        }\n    }\n}\n\n@DangerousInternalIoApi\n@Deprecated(\"Will be removed in future releases\", level = DeprecationLevel.ERROR)\n@Suppress(\"DEPRECATION\")\nabstract class BytePacketBuilderBase internal constructor(protected val pool: ObjectPool<IoBuffer>) : Appendable, Output {\n    @Deprecated(\n        \"Suppress warning.\",\n        level = DeprecationLevel.HIDDEN\n    )\n    final override val doNotImplementOutputButExtendAbstractOutputInstead: Nothing\n        get() = error(\"Should be never accessed.\")\n\n    /**\n     * Number of bytes currently buffered or -1 if not known (need to be recomputed)\n     */\n    protected var _size: Int = 0\n\n    /**\n     * Byte order (Endianness) to be used by future write functions calls on this builder instance. Doesn't affect any\n     * previously written values. Note that [reset] doesn't change this value back to the default byte order.\n     * @default [ByteOrder.BIG_ENDIAN]\n     */\n    @Deprecated(\"Write with writeXXXLittleEndian or do X.reverseByteOrder() and then writeXXX instead.\")\n    final override var byteOrder: ByteOrder = ByteOrder.BIG_ENDIAN\n        set(value) {\n            field = value\n            val tail = tail\n            if (tail.canWrite()) {\n                // it is important to not set byte order for IoBuffer.Empty as it will crash on native\n                tail.byteOrder = value\n            }\n        }\n\n    @PublishedApi\n    internal var tail: IoBuffer = IoBuffer.Empty\n\n    final override fun writeFully(src: ByteArray, offset: Int, length: Int) {\n        if (length == 0) return\n\n        var copied = 0\n\n        writeLoop(1, { copied < length }) { buffer, bufferRemaining ->\n            val size = minOf(bufferRemaining, length - copied)\n            buffer.writeFully(src, offset + copied, size)\n            copied += size\n            size\n        }\n    }\n\n    final override fun writeLong(v: Long) {\n        write(8) { it.writeLong(v); 8 }\n    }\n\n    final override fun writeInt(v: Int) {\n        write(4) { it.writeInt(v); 4 }\n    }\n\n    final override fun writeShort(v: Short) {\n        write(2) { it.writeShort(v); 2 }\n    }\n\n    final override fun writeByte(v: Byte) {\n        write(1) { it.writeByte(v); 1 }\n    }\n\n    final override fun writeDouble(v: Double) {\n        write(8) { it.writeDouble(v); 8 }\n    }\n\n    final override fun writeFloat(v: Float) {\n        write(4) { it.writeFloat(v); 4 }\n    }\n\n    override fun writeFully(src: ShortArray, offset: Int, length: Int) {\n        require(length >= 0) { \"length shouldn't be negative: $length\" }\n        require(offset + length < src.lastIndex) { \"offset ($offset) + length ($length) >= src.lastIndex (${src.lastIndex})\" }\n\n        if (length == 0) return\n\n        var start = offset\n        var remaining = length\n\n        writeLoop(2, { remaining > 0 }) { buffer, chunkRemaining ->\n            val qty = minOf(chunkRemaining shr 1, remaining)\n            buffer.writeFully(src, start, qty)\n            start += qty\n            remaining -= qty\n            qty * 2\n        }\n    }\n\n    override fun writeFully(src: IntArray, offset: Int, length: Int) {\n        require(length >= 0) { \"length shouldn't be negative: $length\" }\n        require(offset + length < src.lastIndex) { \"offset ($offset) + length ($length) >= src.lastIndex (${src.lastIndex})\" }\n\n        var start = offset\n        var remaining = length\n\n        writeLoop(4, { remaining > 0 }) { buffer, chunkRemaining ->\n            val qty = minOf(chunkRemaining shr 2, remaining)\n            buffer.writeFully(src, start, qty)\n            start += qty\n            remaining -= qty\n            qty * 4\n        }\n    }\n\n    override fun writeFully(src: LongArray, offset: Int, length: Int) {\n        require(length >= 0) { \"length shouldn't be negative: $length\" }\n        require(offset + length < src.lastIndex) { \"offset ($offset) + length ($length) >= src.lastIndex (${src.lastIndex})\" }\n\n        var start = offset\n        var remaining = length\n\n        writeLoop(8, { remaining > 0 }) { buffer, chunkRemaining ->\n            val qty = minOf(chunkRemaining shr 3, remaining)\n            buffer.writeFully(src, start, qty)\n            start += qty\n            remaining -= qty\n            qty * 8\n        }\n    }\n\n    override fun writeFully(src: FloatArray, offset: Int, length: Int) {\n        require(length >= 0) { \"length shouldn't be negative: $length\" }\n        require(offset + length < src.lastIndex) { \"offset ($offset) + length ($length) >= src.lastIndex (${src.lastIndex})\" }\n\n        var start = offset\n        var remaining = length\n\n        writeLoop(4, { remaining > 0 }) { buffer, chunkRemaining ->\n            val qty = minOf(chunkRemaining shr 2, remaining)\n            buffer.writeFully(src, start, qty)\n            start += qty\n            remaining -= qty\n            qty * 4\n        }\n    }\n\n    override fun writeFully(src: DoubleArray, offset: Int, length: Int) {\n        require(length >= 0) { \"length shouldn't be negative: $length\" }\n        require(offset + length < src.lastIndex) { \"offset ($offset) + length ($length) >= src.lastIndex (${src.lastIndex})\" }\n\n        var start = offset\n        var remaining = length\n\n        writeLoop(8, { remaining > 0 }) { buffer, chunkRemaining ->\n            val qty = minOf(chunkRemaining shr 3, remaining)\n            buffer.writeFully(src, start, qty)\n            start += qty\n            remaining -= qty\n            qty * 8\n        }\n    }\n\n    override fun writeFully(src: IoBuffer, length: Int) {\n        require(length >= 0) { \"length shouldn't be negative: $length\" }\n        require(length <= src.readRemaining) { \"Not enough bytes available in src buffer to read $length bytes\" }\n\n        val totalSize = minOf(src.readRemaining, length)\n        if (totalSize == 0) return\n        var remaining = totalSize\n\n        var tail = tail\n        if (!tail.canWrite()) {\n            tail = appendNewBuffer()\n        }\n\n        do {\n            val size = minOf(tail.writeRemaining, remaining)\n            tail.writeFully(src, size)\n            remaining -= size\n\n            if (remaining == 0) break\n            tail = appendNewBuffer()\n        } while (true)\n\n        addSize(totalSize)\n    }\n\n    override fun fill(n: Long, v: Byte) {\n        require(n >= 0L) { \"n shouldn't be negative: $n\" }\n\n        var rem = n\n        writeLoop(1, { rem > 0L }) { buffer, chunkRemaining ->\n            val size = minOf(chunkRemaining.toLong(), n).toInt()\n            buffer.fill(size.toLong(), v)\n            rem -= size\n            size\n        }\n    }\n\n    /**\n     * Append single UTF-8 character\n     */\n    override fun append(c: Char): @Suppress(\"DEPRECATION_ERROR\") BytePacketBuilderBase {\n        write(3) {\n            it.putUtf8Char(c.toInt())\n        }\n        return this\n    }\n\n    override fun append(csq: CharSequence?): @Suppress(\"DEPRECATION_ERROR\") BytePacketBuilderBase {\n        if (csq == null) {\n            appendChars(\"null\", 0, 4)\n        } else {\n            appendChars(csq, 0, csq.length)\n        }\n        return this\n    }\n\n    override fun append(csq: CharSequence?, start: Int, end: Int): @Suppress(\"DEPRECATION_ERROR\") BytePacketBuilderBase {\n        if (csq == null) {\n            return append(\"null\", start, end)\n        }\n\n        appendChars(csq, start, end)\n\n        return this\n    }\n\n    open fun writePacket(p: ByteReadPacket) {\n        while (true) {\n            val buffer = p.steal() ?: break\n            last(buffer)\n        }\n    }\n\n    /**\n     * Write exact [n] bytes from packet to the builder\n     */\n    fun writePacket(p: ByteReadPacket, n: Int) {\n        var remaining = n\n\n        while (remaining > 0) {\n            val headRemaining = p.headRemaining\n            if (headRemaining <= remaining) {\n                remaining -= headRemaining\n                last(p.steal() ?: throw EOFException(\"Unexpected end of packet\"))\n            } else {\n                p.read { view ->\n                    writeFully(view, remaining)\n                }\n                break\n            }\n        }\n    }\n\n    /**\n     * Write exact [n] bytes from packet to the builder\n     */\n    fun writePacket(p: ByteReadPacket, n: Long) {\n        var remaining = n\n\n        while (remaining > 0L) {\n            val headRemaining = p.headRemaining.toLong()\n            if (headRemaining <= remaining) {\n                remaining -= headRemaining\n                last(p.steal() ?: throw EOFException(\"Unexpected end of packet\"))\n            } else {\n                p.read { view ->\n                    writeFully(view, remaining.toInt())\n                }\n                break\n            }\n        }\n    }\n\n    override fun append(csq: CharArray, start: Int, end: Int): Appendable {\n        appendChars(csq, start, end)\n        return this\n    }\n\n    private fun appendChars(csq: CharSequence, start: Int, end: Int): Int {\n        var idx = start\n        if (idx >= end) return idx\n        val tail = tail\n        if (tail.canWrite()) {\n            idx = tail.appendChars(csq, idx, end)\n        }\n\n        while (idx < end) {\n            idx = appendNewBuffer().appendChars(csq, idx, end)\n        }\n\n        this._size = -1\n        return idx\n    }\n\n    private fun appendChars(csq: CharArray, start: Int, end: Int): Int {\n        var idx = start\n        if (idx >= end) return idx\n        val tail = tail\n        if (tail.canWrite()) {\n            idx = tail.appendChars(csq, idx, end)\n        }\n\n        while (idx < end) {\n            idx = appendNewBuffer().appendChars(csq, idx, end)\n        }\n\n        this._size = -1\n        return idx\n    }\n\n    fun writeStringUtf8(s: String) {\n        append(s, 0, s.length)\n    }\n\n    fun writeStringUtf8(cs: CharSequence) {\n        append(cs, 0, cs.length)\n    }\n\n//    fun writeStringUtf8(cb: CharBuffer) {\n//        append(cb, 0, cb.remaining())\n//    }\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    private inline fun IoBuffer.putUtf8Char(v: Int) = when {\n        v in 1..0x7f -> {\n            writeByte(v.toByte())\n            1\n        }\n        v > 0x7ff -> {\n            writeByte((0xe0 or ((v shr 12) and 0x0f)).toByte())\n            writeByte((0x80 or ((v shr  6) and 0x3f)).toByte())\n            writeByte((0x80 or ( v         and 0x3f)).toByte())\n            3\n        }\n        else -> {\n            writeByte((0xc0 or ((v shr  6) and 0x1f)).toByte())\n            writeByte((0x80 or ( v         and 0x3f)).toByte())\n            2\n        }\n    }\n\n    /**\n     * Release any resources that the builder holds. Builder shouldn't be used after release\n     */\n    abstract fun release()\n\n    @DangerousInternalIoApi\n    fun prepareWriteHead(n: Int): IoBuffer {\n        if (tail.writeRemaining >= n) return tail\n        return appendNewBuffer()\n    }\n\n    @DangerousInternalIoApi\n    fun afterHeadWrite() {\n        _size = -1\n    }\n\n    /**\n     * Discard all written bytes and prepare to build another packet.\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    open fun reset() {\n    }\n\n    @PublishedApi\n    internal inline fun write(size: Int, block: (IoBuffer) -> Int) {\n        var buffer = tail\n        if (buffer.writeRemaining < size) {\n            buffer = appendNewBuffer()\n        }\n\n        addSize(block(buffer))\n    }\n\n    private inline fun writeLoop(size: Int, predicate: () -> Boolean, block: (IoBuffer, Int) -> Int) {\n        if (!predicate()) return\n        var written = 0\n        var buffer = tail\n        var rem = buffer.writeRemaining\n\n        do {\n            if (rem < size) {\n                buffer = appendNewBuffer()\n                rem = buffer.writeRemaining\n            }\n\n            val result = block(buffer, rem)\n            written += result\n            rem -= result\n        } while (predicate())\n\n        addSize(written)\n    }\n\n    @PublishedApi\n    internal fun addSize(n: Int) {\n        val size = _size\n        if (size != -1) {\n            _size = size + n\n        }\n    }\n\n    internal abstract fun last(buffer: IoBuffer)\n\n    @PublishedApi\n    internal fun appendNewBuffer(): IoBuffer {\n        val new = pool.borrow()\n        new.reserveEndGap(IoBuffer.ReservedSize)\n        new.byteOrder = byteOrder\n\n        last(new)\n\n        return new\n    }\n}\n\nprivate inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    return if (!predicate(this)) this else null\n}\n\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","package kotlinx.io.core\n\nimport kotlinx.io.core.internal.*\n\n/**\n * This shouldn't be implemented directly. Inherit [AbstractOutput] instead.\n */\nexpect interface Output : Appendable, Closeable {\n    @Deprecated(\n        \"Implementing this interface is highly experimental. Extend AbstractOutput instead.\",\n        level = DeprecationLevel.HIDDEN\n    )\n    val doNotImplementOutputButExtendAbstractOutputInstead: Nothing\n\n    /**\n     * Byte order (Endianness) to be used by future write functions calls on this builder instance. Doesn't affect any\n     * previously written values.\n     * @default [ByteOrder.BIG_ENDIAN]\n     */\n    @Deprecated(\"Write with writeXXXLittleEndian or do X.reverseByteOrder() and then writeXXX instead.\")\n    var byteOrder: ByteOrder\n\n    fun writeByte(v: Byte)\n    fun writeShort(v: Short)\n    fun writeInt(v: Int)\n    fun writeLong(v: Long)\n    fun writeFloat(v: Float)\n    fun writeDouble(v: Double)\n\n    fun writeFully(src: ByteArray, offset: Int, length: Int)\n    fun writeFully(src: ShortArray, offset: Int, length: Int)\n    fun writeFully(src: IntArray, offset: Int, length: Int)\n    fun writeFully(src: LongArray, offset: Int, length: Int)\n    fun writeFully(src: FloatArray, offset: Int, length: Int)\n    fun writeFully(src: DoubleArray, offset: Int, length: Int)\n    fun writeFully(src: IoBuffer, length: Int)\n\n    fun append(csq: CharArray, start: Int, end: Int): Appendable\n\n    fun fill(n: Long, v: Byte)\n\n    fun flush()\n\n    override fun close()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.append(csq: CharSequence, start: Int = 0, end: Int = csq.length): Appendable {\n    return append(csq, start, end)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.append(csq: CharArray, start: Int = 0, end: Int = csq.size): Appendable {\n    return append(csq, start, end)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.writeFully(src: ByteArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFully(src, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.writeFully(src: ShortArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFully(src, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.writeFully(src: IntArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFully(src, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.writeFully(src: LongArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFully(src, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.writeFully(src: FloatArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFully(src, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.writeFully(src: DoubleArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFully(src, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.writeFully(src: IoBuffer, length: Int = src.readRemaining) {\n    writeFully(src, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.fill(n: Long, v: Byte = 0) {\n    fill(n, v)\n}\n\n/**\n * Append number of chunks invoking [block] function while the returned value is true.\n * Depending on the output underlying implementation it could invoke [block] function with the same buffer several times\n * however it is guaranteed that it is always non-empty.\n */\n@Deprecated(\"This is going to become internal. Write directly to output instead.\")\ninline fun Output.writeWhile(block: (IoBuffer) -> Boolean) {\n    var tail: IoBuffer = prepareWriteHead(1, null)\n    try {\n        while (true) {\n            if (!block(tail)) break\n            tail = prepareWriteHead(1, tail)\n        }\n    } finally {\n        afterHeadWrite(tail)\n    }\n}\n\n/**\n * Append number of chunks invoking [block] function while the returned value is positive.\n * If returned value is positive then it will be invoked again with a buffer having at least requested number of\n * bytes space (could be the same buffer as before if it complies to the restriction).\n * @param initialSize for the first buffer passed to [block] function\n */\n@Deprecated(\"This is going to become internal. Write directly to output instead.\")\ninline fun Output.writeWhileSize(initialSize: Int = 1, block: (IoBuffer) -> Int) {\n    var tail = prepareWriteHead(initialSize, null)\n\n    try {\n        var size: Int\n        while (true) {\n            size = block(tail)\n            if (size <= 0) break\n            tail = prepareWriteHead(size, tail)\n        }\n    } finally {\n        afterHeadWrite(tail)\n    }\n}\n\nfun Output.writePacket(packet: ByteReadPacket) {\n    @Suppress(\"DEPRECATION_ERROR\")\n    if (this is BytePacketBuilderBase) {\n        writePacket(packet)\n        return\n    }\n\n    packet.takeWhile { from ->\n        writeFully(from)\n        true\n    }\n}\n","package kotlinx.io.core.internal\n\n@PublishedApi\ninternal inline fun require(condition: Boolean, crossinline message: () -> String) {\n    if (!condition) {\n        val m = object : RequireFailureCapture() {\n            override fun doFail(): Nothing {\n                throw IllegalArgumentException(message())\n            }\n        }\n        m.doFail()\n    }\n}\n\n@PublishedApi\ninternal abstract class RequireFailureCapture {\n    abstract fun doFail(): Nothing\n}\n","package kotlinx.io.core\n\nimport kotlinx.io.core.internal.*\nimport kotlinx.io.pool.*\n\nexpect class ByteReadPacket internal constructor(head: IoBuffer, remaining: Long, pool: ObjectPool<IoBuffer>) :\n    ByteReadPacketPlatformBase {\n    constructor(head: IoBuffer, pool: ObjectPool<IoBuffer>)\n\n    companion object {\n        val Empty: ByteReadPacket\n\n        @Deprecated(\"This implementation detail is going to become internal.\")\n        val ReservedSize: Int\n    }\n}\n\n@DangerousInternalIoApi\nexpect abstract class ByteReadPacketPlatformBase protected constructor(\n    head: IoBuffer,\n    remaining: Long,\n    pool: ObjectPool<IoBuffer>\n) : ByteReadPacketBase\n\n/**\n * The default abstract base class for implementing [Input] interface.\n * @see [AbstractInput.fill] amd [AbstractInput.closeSource]\n */\n@ExperimentalIoApi\nabstract class AbstractInput(\n    head: IoBuffer = IoBuffer.Empty,\n    remaining: Long = head.remainingAll(),\n    pool: ObjectPool<IoBuffer> = IoBuffer.Pool\n) : ByteReadPacketPlatformBase(head, remaining, pool) {\n    /**\n     * Reads the next chunk suitable for reading or `null` if no more chunks available. It is also allowed\n     * to return a chain of chunks linked through [IoBuffer.next]. The last chunk should have `null` next reference.\n     * Could rethrow exceptions from the underlying source.\n     */\n    abstract override fun fill(): IoBuffer?\n\n    /**\n     * Should close the underlying bytes source. Could do nothing or throw exceptions.\n     */\n    abstract override fun closeSource()\n}\n\nexpect fun ByteReadPacket(\n    array: ByteArray, offset: Int = 0, length: Int = array.size,\n    block: (ByteArray) -> Unit\n): ByteReadPacket\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninline fun ByteReadPacket(array: ByteArray, offset: Int = 0, length: Int = array.size): ByteReadPacket {\n    return ByteReadPacket(array, offset, length) {}\n}\n","package kotlinx.io.core\n\nexpect interface Closeable {\n    fun close()\n}\n\ninline fun <C : Closeable, R> C.use(block: (C) -> R): R {\n    var closed = false\n\n    return try {\n        block(this)\n    } catch (first: Throwable) {\n        try {\n            closed = true\n            close()\n        } catch (second: Throwable) {\n            first.addSuppressedInternal(second)\n        }\n\n        throw first\n    } finally {\n        if (!closed) {\n            close()\n        }\n    }\n}\n\n@PublishedApi\ninternal expect fun Throwable.addSuppressedInternal(other: Throwable)\n","package kotlinx.io.core\n\n/**\n * Copy all bytes to the [output].\n * Depending on actual input and output implementation it could be zero-copy or copy byte per byte.\n * All regular types such as [ByteReadPacket], [BytePacketBuilder], [AbstractInput] and [AbstractOutput]\n * are always optimized so no bytes will be copied.\n */\nfun Input.copyTo(output: Output): Long {\n    @Suppress(\"DEPRECATION_ERROR\")\n    if (this !is ByteReadPacketBase || output !is BytePacketBuilderBase) {\n        // slow-path\n        return copyToFallback(output)\n    }\n\n    var copied = 0L\n    do {\n        val head = stealAll()\n        if (head == null) {\n            if (prepareRead(1) == null) break\n            continue\n        }\n\n        copied += head.remainingAll()\n        output.last(head)\n    } while (true)\n\n    return copied\n}\n\nprivate fun Input.copyToFallback(output: Output): Long {\n    val buffer = IoBuffer.Pool.borrow()\n    var copied = 0L\n\n    try {\n        do {\n            buffer.resetForWrite()\n            val rc = readAvailable(buffer)\n            if (rc == -1) break\n            copied += rc\n            output.writeFully(buffer)\n        } while (true)\n\n        return copied\n    } finally {\n        buffer.release(IoBuffer.Pool)\n    }\n}\n","package kotlinx.io.core\n\n/**\n * API marked with this annotation is experimental and could be changed\n */\n@Experimental(Experimental.Level.WARNING)\nannotation class ExperimentalIoApi\n","package kotlinx.io.core.internal\n\nimport kotlinx.io.core.*\n\ninternal inline fun IoBuffer.decodeASCII(consumer: (Char) -> Boolean): Boolean {\n    for (i in 0 until readRemaining) {\n        val v = readByte().toInt() and 0xff\n        if (v and 0x80 != 0 || !consumer(v.toChar())) {\n            pushBack(1)\n            return false\n        }\n    }\n\n    return true\n}\n\n@DangerousInternalIoApi\nsuspend fun decodeUTF8LineLoopSuspend(\n    out: Appendable,\n    limit: Int,\n    nextChunk: suspend (Int) -> ByteReadPacketBase?\n): Boolean {\n    var decoded = 0\n    var size = 1\n    var cr = false\n    var end = false\n\n    while (!end && size != 0) {\n        val chunk = nextChunk(size) ?: break\n        chunk.takeWhileSize { buffer ->\n            var skip = 0\n            size = buffer.decodeUTF8 { ch ->\n                when (ch) {\n                    '\\r' -> {\n                        if (cr) {\n                            end = true\n                            return@decodeUTF8 false\n                        }\n                        cr = true\n                        true\n                    }\n                    '\\n' -> {\n                        end = true\n                        skip = 1\n                        false\n                    }\n                    else -> {\n                        if (cr) {\n                            end = true\n                            return@decodeUTF8 false\n                        }\n\n                        if (decoded == limit) {\n                            throw BufferLimitExceededException(\"Too many characters in line: limit $limit exceeded\")\n                        }\n                        decoded++\n                        out.append(ch)\n                        true\n                    }\n                }\n            }\n\n            if (skip > 0) {\n                buffer.discardExact(skip)\n            }\n\n            size = if (end) 0 else size.coerceAtLeast(1)\n\n            size\n        }\n    }\n\n    if (size > 1) prematureEndOfStreamUtf(size)\n    if (cr) {\n        end = true\n    }\n\n    return decoded > 0 || end\n}\n\nprivate fun prematureEndOfStreamUtf(size: Int): Nothing =\n    throw EOFException(\"Premature end of stream: expected $size bytes to decode UTF-8 char\")\n\n@DangerousInternalIoApi\ninternal fun byteCountUtf8(firstByte: Int): Int {\n    var byteCount = 0\n    var mask = 0x80\n    var value = firstByte\n\n    for (i in 1..6) {\n        if (value and mask != 0) {\n            value = value and mask.inv()\n            mask = mask shr 1\n            byteCount++\n        } else {\n            break\n        }\n    }\n\n    return byteCount\n}\n\n/**\n * Decodes all the bytes to utf8 applying every character on [consumer] until or consumer return `false`.\n * If a consumer returned false then a character will be pushed back (including all surrogates will be pushed back as well)\n * and [decodeUTF8] returns -1\n * @return number of bytes required to decode incomplete utf8 character or 0 if all bytes were processed\n * or -1 if consumer rejected loop\n */\n@DangerousInternalIoApi\ninline fun IoBuffer.decodeUTF8(consumer: (Char) -> Boolean): Int {\n    var byteCount = 0\n    var value = 0\n    var lastByteCount = 0\n\n    while (canRead()) {\n        val v = readByte().toInt() and 0xff\n        when {\n            v and 0x80 == 0 -> {\n                if (byteCount != 0) malformedByteCount(byteCount)\n                if (!consumer(v.toChar())) {\n                    pushBack(1)\n                    return -1\n                }\n            }\n            byteCount == 0 -> {\n                // first unicode byte\n\n                var mask = 0x80\n                value = v\n\n                for (i in 1..6) { // TODO do we support 6 bytes unicode?\n                    if (value and mask != 0) {\n                        value = value and mask.inv()\n                        mask = mask shr 1\n                        byteCount++\n                    } else {\n                        break\n                    }\n                }\n\n                lastByteCount = byteCount\n                byteCount--\n\n                if (byteCount > readRemaining) {\n                    pushBack(1) // return one byte back\n                    return lastByteCount\n                }\n            }\n            else -> {\n                // trailing unicode byte\n                value = (value shl 6) or (v and 0x7f)\n                byteCount--\n\n                if (byteCount == 0) {\n                    if (isBmpCodePoint(value)) {\n                        if (!consumer(value.toChar())) {\n                            pushBack(lastByteCount)\n                            return -1\n                        }\n                    } else if (!isValidCodePoint(value)) {\n                        malformedCodePoint(value)\n                    } else {\n                        if (!consumer(highSurrogate(value).toChar()) ||\n                                !consumer(lowSurrogate(value).toChar())) {\n                            pushBack(lastByteCount)\n                            return -1\n                        }\n                    }\n\n                    value = 0\n                }\n            }\n        }\n    }\n\n    return 0\n}\n\n@PublishedApi\ninternal fun malformedByteCount(byteCount: Int): Nothing =\n    throw MalformedUTF8InputException(\"Expected $byteCount more character bytes\")\n\n@PublishedApi\ninternal fun malformedCodePoint(value: Int): Nothing =\n    throw IllegalArgumentException(\"Malformed code-point $value found\")\n\nprivate const val MaxCodePoint = 0x10ffff\nprivate const val MinLowSurrogate = 0xdc00\nprivate const val MinHighSurrogate = 0xd800\nprivate const val MinSupplementary = 0x10000\nprivate const val HighSurrogateMagic = MinHighSurrogate - (MinSupplementary ushr 10)\n\n@PublishedApi\ninternal fun isBmpCodePoint(cp: Int) = cp ushr 16 == 0\n\n@PublishedApi\ninternal fun isValidCodePoint(codePoint: Int) = codePoint <= MaxCodePoint\n\n@PublishedApi\ninternal fun lowSurrogate(cp: Int) = (cp and 0x3ff) + MinLowSurrogate\n\n@PublishedApi\ninternal fun highSurrogate(cp: Int) = (cp ushr 10) + HighSurrogateMagic\n\nclass MalformedUTF8InputException(message: String) : Exception(message)\n","@file:Suppress(\"Duplicates\")\n\npackage kotlinx.io.core\n\nimport kotlinx.io.bits.*\n\nfun Input.readShort(byteOrder: ByteOrder): Short =\n    readPrimitiveTemplate(byteOrder, { readShort() }, { reverseByteOrder() })\n\nfun Input.readInt(byteOrder: ByteOrder): Int =\n    readPrimitiveTemplate(byteOrder, { readInt() }, { reverseByteOrder() })\n\nfun Input.readLong(byteOrder: ByteOrder): Long =\n    readPrimitiveTemplate(byteOrder, { readLong() }, { reverseByteOrder() })\n\nfun Input.readFloat(byteOrder: ByteOrder): Float =\n    readPrimitiveTemplate(byteOrder, { readFloat() }, { reverseByteOrder() })\n\nfun Input.readDouble(byteOrder: ByteOrder): Double =\n    readPrimitiveTemplate(byteOrder, { readDouble() }, { reverseByteOrder() })\n\nfun Input.readShortLittleEndian(): Short = readPrimitiveTemplate({ readShort() }, { reverseByteOrder() })\n\nfun Input.readIntLittleEndian(): Int = readPrimitiveTemplate({ readInt() }, { reverseByteOrder() })\n\nfun Input.readLongLittleEndian(): Long = readPrimitiveTemplate({ readLong() }, { reverseByteOrder() })\n\nfun Input.readFloatLittleEndian(): Float = readPrimitiveTemplate({ readFloat() }, { reverseByteOrder() })\n\nfun Input.readDoubleLittleEndian(): Double = readPrimitiveTemplate({ readDouble() }, { reverseByteOrder() })\n\nfun Input.readFullyLittleEndian(dst: UShortArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyLittleEndian(dst.asShortArray(), offset, length)\n}\n\nfun Input.readFullyLittleEndian(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    if (byteOrderDeprecated != ByteOrder.LITTLE_ENDIAN) {\n        val lastIndex = offset + length - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n}\n\nfun Input.readFullyLittleEndian(dst: UIntArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyLittleEndian(dst.asIntArray(), offset, length)\n}\n\nfun Input.readFullyLittleEndian(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    if (byteOrderDeprecated != ByteOrder.LITTLE_ENDIAN) {\n        val lastIndex = offset + length - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n}\n\nfun Input.readFullyLittleEndian(dst: ULongArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyLittleEndian(dst.asLongArray(), offset, length)\n}\n\nfun Input.readFullyLittleEndian(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    if (byteOrderDeprecated != ByteOrder.LITTLE_ENDIAN) {\n        val lastIndex = offset + length - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n}\n\nfun Input.readFullyLittleEndian(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    if (byteOrderDeprecated != ByteOrder.LITTLE_ENDIAN) {\n        val lastIndex = offset + length - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n}\n\nfun Input.readFullyLittleEndian(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    if (byteOrderDeprecated != ByteOrder.LITTLE_ENDIAN) {\n        val lastIndex = offset + length - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n}\n\nfun Input.readAvailableLittleEndian(dst: UShortArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailableLittleEndian(dst.asShortArray(), offset, length)\n}\n\nfun Input.readAvailableLittleEndian(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0 && byteOrderDeprecated != ByteOrder.LITTLE_ENDIAN) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\nfun Input.readAvailableLittleEndian(dst: UIntArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailableLittleEndian(dst.asIntArray(), offset, length)\n}\n\nfun Input.readAvailableLittleEndian(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0 && byteOrderDeprecated != ByteOrder.LITTLE_ENDIAN) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\nfun Input.readAvailableLittleEndian(dst: ULongArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailableLittleEndian(dst.asLongArray(), offset, length)\n}\n\nfun Input.readAvailableLittleEndian(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0 && byteOrderDeprecated != ByteOrder.LITTLE_ENDIAN) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\nfun Input.readAvailableLittleEndian(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0 && byteOrderDeprecated != ByteOrder.LITTLE_ENDIAN) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\nfun Input.readAvailableLittleEndian(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0 && byteOrderDeprecated != ByteOrder.LITTLE_ENDIAN) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\nprivate inline fun <T : Any> Input.readPrimitiveTemplate(read: () -> T, reverse: T.() -> T): T {\n    return when (byteOrderDeprecated) {\n        ByteOrder.LITTLE_ENDIAN -> read()\n        else -> read().reverse()\n    }\n}\n\nprivate inline fun <T : Any> Input.readPrimitiveTemplate(byteOrder: ByteOrder, read: () -> T, reverse: T.() -> T): T {\n    return when {\n        byteOrderDeprecated == byteOrder -> read()\n        else -> read().reverse()\n    }\n}\n\n@Suppress(\"DEPRECATION\")\nprivate inline val Input.byteOrderDeprecated get() = byteOrder\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"UArraysKt\")\n@file:kotlin.jvm.JvmPackageName(\"kotlin.collections.unsigned\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component1(): UInt {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component1(): ULong {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component1(): UByte {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component1(): UShort {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component2(): UInt {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component2(): ULong {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component2(): UByte {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component2(): UShort {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component3(): UInt {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component3(): ULong {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component3(): UByte {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component3(): UShort {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component4(): UInt {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component4(): ULong {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component4(): UByte {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component4(): UShort {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component5(): UInt {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component5(): ULong {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component5(): UByte {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component5(): UShort {\n    return get(4)\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UIntArray.elementAt(index: Int): UInt\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun ULongArray.elementAt(index: Int): ULong\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UByteArray.elementAt(index: Int): UByte\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UShortArray.elementAt(index: Int): UShort\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> UInt): UInt {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> ULong): ULong {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> UByte): UByte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> UShort): UShort {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.elementAtOrNull(index: Int): UInt? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.elementAtOrNull(index: Int): ULong? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.elementAtOrNull(index: Int): UByte? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.elementAtOrNull(index: Int): UShort? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.find(predicate: (UInt) -> Boolean): UInt? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.find(predicate: (ULong) -> Boolean): ULong? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.find(predicate: (UByte) -> Boolean): UByte? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.find(predicate: (UShort) -> Boolean): UShort? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.findLast(predicate: (UInt) -> Boolean): UInt? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.findLast(predicate: (ULong) -> Boolean): ULong? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.findLast(predicate: (UByte) -> Boolean): UByte? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.findLast(predicate: (UShort) -> Boolean): UShort? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.first(): UInt {\n    return storage.first().toUInt()\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.first(): ULong {\n    return storage.first().toULong()\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.first(): UByte {\n    return storage.first().toUByte()\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.first(): UShort {\n    return storage.first().toUShort()\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.first(predicate: (UInt) -> Boolean): UInt {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.first(predicate: (ULong) -> Boolean): ULong {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.first(predicate: (UByte) -> Boolean): UByte {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.first(predicate: (UShort) -> Boolean): UShort {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.firstOrNull(): UInt? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.firstOrNull(): ULong? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.firstOrNull(): UByte? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.firstOrNull(): UShort? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.firstOrNull(predicate: (UInt) -> Boolean): UInt? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.firstOrNull(predicate: (ULong) -> Boolean): ULong? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.firstOrNull(predicate: (UByte) -> Boolean): UByte? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.firstOrNull(predicate: (UShort) -> Boolean): UShort? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.getOrElse(index: Int, defaultValue: (Int) -> UInt): UInt {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.getOrElse(index: Int, defaultValue: (Int) -> ULong): ULong {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.getOrElse(index: Int, defaultValue: (Int) -> UByte): UByte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.getOrElse(index: Int, defaultValue: (Int) -> UShort): UShort {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.getOrNull(index: Int): UInt? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.getOrNull(index: Int): ULong? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.getOrNull(index: Int): UByte? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.getOrNull(index: Int): UShort? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.indexOf(element: UInt): Int {\n    return storage.indexOf(element.toInt())\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.indexOf(element: ULong): Int {\n    return storage.indexOf(element.toLong())\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.indexOf(element: UByte): Int {\n    return storage.indexOf(element.toByte())\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.indexOf(element: UShort): Int {\n    return storage.indexOf(element.toShort())\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.indexOfFirst(predicate: (UInt) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toUInt()) }\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.indexOfFirst(predicate: (ULong) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toULong()) }\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.indexOfFirst(predicate: (UByte) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toUByte()) }\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.indexOfFirst(predicate: (UShort) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toUShort()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.indexOfLast(predicate: (UInt) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toUInt()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.indexOfLast(predicate: (ULong) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toULong()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.indexOfLast(predicate: (UByte) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toUByte()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.indexOfLast(predicate: (UShort) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toUShort()) }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.last(): UInt {\n    return storage.last().toUInt()\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.last(): ULong {\n    return storage.last().toULong()\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.last(): UByte {\n    return storage.last().toUByte()\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.last(): UShort {\n    return storage.last().toUShort()\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.last(predicate: (UInt) -> Boolean): UInt {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.last(predicate: (ULong) -> Boolean): ULong {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.last(predicate: (UByte) -> Boolean): UByte {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.last(predicate: (UShort) -> Boolean): UShort {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.lastIndexOf(element: UInt): Int {\n    return storage.lastIndexOf(element.toInt())\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.lastIndexOf(element: ULong): Int {\n    return storage.lastIndexOf(element.toLong())\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.lastIndexOf(element: UByte): Int {\n    return storage.lastIndexOf(element.toByte())\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.lastIndexOf(element: UShort): Int {\n    return storage.lastIndexOf(element.toShort())\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.lastOrNull(): UInt? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.lastOrNull(): ULong? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.lastOrNull(): UByte? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.lastOrNull(): UShort? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.lastOrNull(predicate: (UInt) -> Boolean): UInt? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.lastOrNull(predicate: (ULong) -> Boolean): ULong? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.lastOrNull(predicate: (UByte) -> Boolean): UByte? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.lastOrNull(predicate: (UShort) -> Boolean): UShort? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.random(): UInt {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.random(): ULong {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.random(): UByte {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.random(): UShort {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.random(random: Random): UInt {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.random(random: Random): ULong {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.random(random: Random): UByte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.random(random: Random): UShort {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.single(): UInt {\n    return storage.single().toUInt()\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.single(): ULong {\n    return storage.single().toULong()\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.single(): UByte {\n    return storage.single().toUByte()\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.single(): UShort {\n    return storage.single().toUShort()\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.single(predicate: (UInt) -> Boolean): UInt {\n    var single: UInt? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as UInt\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.single(predicate: (ULong) -> Boolean): ULong {\n    var single: ULong? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as ULong\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.single(predicate: (UByte) -> Boolean): UByte {\n    var single: UByte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as UByte\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.single(predicate: (UShort) -> Boolean): UShort {\n    var single: UShort? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as UShort\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.singleOrNull(): UInt? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.singleOrNull(): ULong? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.singleOrNull(): UByte? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.singleOrNull(): UShort? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.singleOrNull(predicate: (UInt) -> Boolean): UInt? {\n    var single: UInt? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.singleOrNull(predicate: (ULong) -> Boolean): ULong? {\n    var single: ULong? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.singleOrNull(predicate: (UByte) -> Boolean): UByte? {\n    var single: UByte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.singleOrNull(predicate: (UShort) -> Boolean): UShort? {\n    var single: UShort? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.drop(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.drop(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.drop(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.drop(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.dropLast(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.dropLast(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.dropLast(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.dropLast(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.dropLastWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.dropLastWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.dropLastWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.dropLastWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.dropWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    var yielding = false\n    val list = ArrayList<UInt>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.dropWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    var yielding = false\n    val list = ArrayList<ULong>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.dropWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    var yielding = false\n    val list = ArrayList<UByte>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.dropWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    var yielding = false\n    val list = ArrayList<UShort>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.filter(predicate: (UInt) -> Boolean): List<UInt> {\n    return filterTo(ArrayList<UInt>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.filter(predicate: (ULong) -> Boolean): List<ULong> {\n    return filterTo(ArrayList<ULong>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.filter(predicate: (UByte) -> Boolean): List<UByte> {\n    return filterTo(ArrayList<UByte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.filter(predicate: (UShort) -> Boolean): List<UShort> {\n    return filterTo(ArrayList<UShort>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.filterIndexed(predicate: (index: Int, UInt) -> Boolean): List<UInt> {\n    return filterIndexedTo(ArrayList<UInt>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.filterIndexed(predicate: (index: Int, ULong) -> Boolean): List<ULong> {\n    return filterIndexedTo(ArrayList<ULong>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.filterIndexed(predicate: (index: Int, UByte) -> Boolean): List<UByte> {\n    return filterIndexedTo(ArrayList<UByte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.filterIndexed(predicate: (index: Int, UShort) -> Boolean): List<UShort> {\n    return filterIndexedTo(ArrayList<UShort>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UInt>> UIntArray.filterIndexedTo(destination: C, predicate: (index: Int, UInt) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in ULong>> ULongArray.filterIndexedTo(destination: C, predicate: (index: Int, ULong) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UByte>> UByteArray.filterIndexedTo(destination: C, predicate: (index: Int, UByte) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UShort>> UShortArray.filterIndexedTo(destination: C, predicate: (index: Int, UShort) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.filterNot(predicate: (UInt) -> Boolean): List<UInt> {\n    return filterNotTo(ArrayList<UInt>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.filterNot(predicate: (ULong) -> Boolean): List<ULong> {\n    return filterNotTo(ArrayList<ULong>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.filterNot(predicate: (UByte) -> Boolean): List<UByte> {\n    return filterNotTo(ArrayList<UByte>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.filterNot(predicate: (UShort) -> Boolean): List<UShort> {\n    return filterNotTo(ArrayList<UShort>(), predicate)\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UInt>> UIntArray.filterNotTo(destination: C, predicate: (UInt) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in ULong>> ULongArray.filterNotTo(destination: C, predicate: (ULong) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UByte>> UByteArray.filterNotTo(destination: C, predicate: (UByte) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UShort>> UShortArray.filterNotTo(destination: C, predicate: (UShort) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UInt>> UIntArray.filterTo(destination: C, predicate: (UInt) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in ULong>> ULongArray.filterTo(destination: C, predicate: (ULong) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UByte>> UByteArray.filterTo(destination: C, predicate: (UByte) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UShort>> UShortArray.filterTo(destination: C, predicate: (UShort) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.slice(indices: IntRange): List<UInt> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.slice(indices: IntRange): List<ULong> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.slice(indices: IntRange): List<UByte> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.slice(indices: IntRange): List<UShort> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.slice(indices: Iterable<Int>): List<UInt> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<UInt>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.slice(indices: Iterable<Int>): List<ULong> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<ULong>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.slice(indices: Iterable<Int>): List<UByte> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<UByte>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.slice(indices: Iterable<Int>): List<UShort> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<UShort>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sliceArray(indices: Collection<Int>): UIntArray {\n    return UIntArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sliceArray(indices: Collection<Int>): ULongArray {\n    return ULongArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sliceArray(indices: Collection<Int>): UByteArray {\n    return UByteArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sliceArray(indices: Collection<Int>): UShortArray {\n    return UShortArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sliceArray(indices: IntRange): UIntArray {\n    return UIntArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sliceArray(indices: IntRange): ULongArray {\n    return ULongArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sliceArray(indices: IntRange): UByteArray {\n    return UByteArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sliceArray(indices: IntRange): UShortArray {\n    return UShortArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.take(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<UInt>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.take(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<ULong>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.take(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<UByte>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.take(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<UShort>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.takeLast(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<UInt>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.takeLast(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<ULong>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.takeLast(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<UByte>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.takeLast(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<UShort>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.takeLastWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.takeLastWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.takeLastWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.takeLastWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.takeWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    val list = ArrayList<UInt>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.takeWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    val list = ArrayList<ULong>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.takeWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    val list = ArrayList<UByte>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.takeWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    val list = ArrayList<UShort>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.reversed(): List<UInt> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.reversed(): List<ULong> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.reversed(): List<UByte> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.reversed(): List<UShort> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reversedArray(): UIntArray {\n    return UIntArray(storage.reversedArray())\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reversedArray(): ULongArray {\n    return ULongArray(storage.reversedArray())\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reversedArray(): UByteArray {\n    return UByteArray(storage.reversedArray())\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reversedArray(): UShortArray {\n    return UShortArray(storage.reversedArray())\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sorted(): List<UInt> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sorted(): List<ULong> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sorted(): List<UByte> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sorted(): List<UShort> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortedArray(): UIntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortedArray(): ULongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortedArray(): UByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortedArray(): UShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortedArrayDescending(): UIntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortedArrayDescending(): ULongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortedArrayDescending(): UByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortedArrayDescending(): UShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortedDescending(): List<UInt> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortedDescending(): List<ULong> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortedDescending(): List<UByte> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortedDescending(): List<UShort> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns an array of type [ByteArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.asByteArray(): ByteArray {\n    return storage\n}\n\n/**\n * Returns an array of type [IntArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.asIntArray(): IntArray {\n    return storage\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UIntArray.asList(): List<UInt>\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun ULongArray.asList(): List<ULong>\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UByteArray.asList(): List<UByte>\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UShortArray.asList(): List<UShort>\n\n/**\n * Returns an array of type [LongArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.asLongArray(): LongArray {\n    return storage\n}\n\n/**\n * Returns an array of type [ShortArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.asShortArray(): ShortArray {\n    return storage\n}\n\n/**\n * Returns an array of type [UByteArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.asUByteArray(): UByteArray {\n    return UByteArray(this)\n}\n\n/**\n * Returns an array of type [UIntArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.asUIntArray(): UIntArray {\n    return UIntArray(this)\n}\n\n/**\n * Returns an array of type [ULongArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.asULongArray(): ULongArray {\n    return ULongArray(this)\n}\n\n/**\n * Returns an array of type [UShortArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.asUShortArray(): UShortArray {\n    return UShortArray(this)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UIntArray.contentEquals(other: UIntArray): Boolean {\n    return storage.contentEquals(other.storage)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun ULongArray.contentEquals(other: ULongArray): Boolean {\n    return storage.contentEquals(other.storage)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UByteArray.contentEquals(other: UByteArray): Boolean {\n    return storage.contentEquals(other.storage)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UShortArray.contentEquals(other: UShortArray): Boolean {\n    return storage.contentEquals(other.storage)\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.contentHashCode(): Int {\n    return storage.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.contentHashCode(): Int {\n    return storage.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.contentHashCode(): Int {\n    return storage.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.contentHashCode(): Int {\n    return storage.contentHashCode()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.contentToString(): String {\n    return joinToString(\", \", \"[\", \"]\")\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.contentToString(): String {\n    return joinToString(\", \", \"[\", \"]\")\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.contentToString(): String {\n    return joinToString(\", \", \"[\", \"]\")\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.contentToString(): String {\n    return joinToString(\", \", \"[\", \"]\")\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyInto(destination: UIntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): UIntArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyInto(destination: ULongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ULongArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyInto(destination: UByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): UByteArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyInto(destination: UShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): UShortArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyOf(): UIntArray {\n    return UIntArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyOf(): ULongArray {\n    return ULongArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyOf(): UByteArray {\n    return UByteArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyOf(): UShortArray {\n    return UShortArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyOf(newSize: Int): UIntArray {\n    return UIntArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyOf(newSize: Int): ULongArray {\n    return ULongArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyOf(newSize: Int): UByteArray {\n    return UByteArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyOf(newSize: Int): UShortArray {\n    return UShortArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyOfRange(fromIndex: Int, toIndex: Int): UIntArray {\n    return UIntArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyOfRange(fromIndex: Int, toIndex: Int): ULongArray {\n    return ULongArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyOfRange(fromIndex: Int, toIndex: Int): UByteArray {\n    return UByteArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyOfRange(fromIndex: Int, toIndex: Int): UShortArray {\n    return UShortArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UIntArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val ULongArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UByteArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UShortArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UIntArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val ULongArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UByteArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UShortArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.plus(element: UInt): UIntArray {\n    return UIntArray(storage + element.toInt())\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.plus(element: ULong): ULongArray {\n    return ULongArray(storage + element.toLong())\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.plus(element: UByte): UByteArray {\n    return UByteArray(storage + element.toByte())\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.plus(element: UShort): UShortArray {\n    return UShortArray(storage + element.toShort())\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun UIntArray.plus(elements: Collection<UInt>): UIntArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toInt()\n    return UIntArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun ULongArray.plus(elements: Collection<ULong>): ULongArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toLong()\n    return ULongArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun UByteArray.plus(elements: Collection<UByte>): UByteArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toByte()\n    return UByteArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun UShortArray.plus(elements: Collection<UShort>): UShortArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toShort()\n    return UShortArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.plus(elements: UIntArray): UIntArray {\n    return UIntArray(storage + elements.storage)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.plus(elements: ULongArray): ULongArray {\n    return ULongArray(storage + elements.storage)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.plus(elements: UByteArray): UByteArray {\n    return UByteArray(storage + elements.storage)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.plus(elements: UShortArray): UShortArray {\n    return UShortArray(storage + elements.storage)\n}\n\n/**\n * Sorts the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sort(): Unit {\n    if (size > 1) sortArray(this)\n}\n\n/**\n * Sorts the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sort(): Unit {\n    if (size > 1) sortArray(this)\n}\n\n/**\n * Sorts the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sort(): Unit {\n    if (size > 1) sortArray(this)\n}\n\n/**\n * Sorts the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sort(): Unit {\n    if (size > 1) sortArray(this)\n}\n\n/**\n * Returns an array of type [ByteArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.toByteArray(): ByteArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns an array of type [IntArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.toIntArray(): IntArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns an array of type [LongArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.toLongArray(): LongArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns an array of type [ShortArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.toShortArray(): ShortArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.toTypedArray(): Array<UInt> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.toTypedArray(): Array<ULong> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.toTypedArray(): Array<UByte> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.toTypedArray(): Array<UShort> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of UByte containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UByte>.toUByteArray(): UByteArray {\n    return UByteArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [UByteArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.toUByteArray(): UByteArray {\n    return UByteArray(this.copyOf())\n}\n\n/**\n * Returns an array of UInt containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UInt>.toUIntArray(): UIntArray {\n    return UIntArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [UIntArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.toUIntArray(): UIntArray {\n    return UIntArray(this.copyOf())\n}\n\n/**\n * Returns an array of ULong containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out ULong>.toULongArray(): ULongArray {\n    return ULongArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [ULongArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.toULongArray(): ULongArray {\n    return ULongArray(this.copyOf())\n}\n\n/**\n * Returns an array of UShort containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UShort>.toUShortArray(): UShortArray {\n    return UShortArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [UShortArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.toUShortArray(): UShortArray {\n    return UShortArray(this.copyOf())\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.flatMap(transform: (UInt) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.flatMap(transform: (ULong) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.flatMap(transform: (UByte) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.flatMap(transform: (UShort) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.flatMapTo(destination: C, transform: (UInt) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.flatMapTo(destination: C, transform: (ULong) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.flatMapTo(destination: C, transform: (UByte) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.flatMapTo(destination: C, transform: (UShort) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> UIntArray.groupBy(keySelector: (UInt) -> K): Map<K, List<UInt>> {\n    return groupByTo(LinkedHashMap<K, MutableList<UInt>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> ULongArray.groupBy(keySelector: (ULong) -> K): Map<K, List<ULong>> {\n    return groupByTo(LinkedHashMap<K, MutableList<ULong>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> UByteArray.groupBy(keySelector: (UByte) -> K): Map<K, List<UByte>> {\n    return groupByTo(LinkedHashMap<K, MutableList<UByte>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> UShortArray.groupBy(keySelector: (UShort) -> K): Map<K, List<UShort>> {\n    return groupByTo(LinkedHashMap<K, MutableList<UShort>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> UIntArray.groupBy(keySelector: (UInt) -> K, valueTransform: (UInt) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> ULongArray.groupBy(keySelector: (ULong) -> K, valueTransform: (ULong) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> UByteArray.groupBy(keySelector: (UByte) -> K, valueTransform: (UByte) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> UShortArray.groupBy(keySelector: (UShort) -> K, valueTransform: (UShort) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<UInt>>> UIntArray.groupByTo(destination: M, keySelector: (UInt) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<UInt>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<ULong>>> ULongArray.groupByTo(destination: M, keySelector: (ULong) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<ULong>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<UByte>>> UByteArray.groupByTo(destination: M, keySelector: (UByte) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<UByte>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<UShort>>> UShortArray.groupByTo(destination: M, keySelector: (UShort) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<UShort>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> UIntArray.groupByTo(destination: M, keySelector: (UInt) -> K, valueTransform: (UInt) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ULongArray.groupByTo(destination: M, keySelector: (ULong) -> K, valueTransform: (ULong) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> UByteArray.groupByTo(destination: M, keySelector: (UByte) -> K, valueTransform: (UByte) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> UShortArray.groupByTo(destination: M, keySelector: (UShort) -> K, valueTransform: (UShort) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.map(transform: (UInt) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.map(transform: (ULong) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.map(transform: (UByte) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.map(transform: (UShort) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.mapIndexed(transform: (index: Int, UInt) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.mapIndexed(transform: (index: Int, ULong) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.mapIndexed(transform: (index: Int, UByte) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.mapIndexed(transform: (index: Int, UShort) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.mapIndexedTo(destination: C, transform: (index: Int, UInt) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.mapIndexedTo(destination: C, transform: (index: Int, ULong) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.mapIndexedTo(destination: C, transform: (index: Int, UByte) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.mapIndexedTo(destination: C, transform: (index: Int, UShort) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.mapTo(destination: C, transform: (UInt) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.mapTo(destination: C, transform: (ULong) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.mapTo(destination: C, transform: (UByte) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.mapTo(destination: C, transform: (UShort) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.withIndex(): Iterable<IndexedValue<UInt>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.withIndex(): Iterable<IndexedValue<ULong>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.withIndex(): Iterable<IndexedValue<UByte>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.withIndex(): Iterable<IndexedValue<UShort>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.all(predicate: (UInt) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.all(predicate: (ULong) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.all(predicate: (UByte) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.all(predicate: (UShort) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.any(predicate: (UInt) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.any(predicate: (ULong) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.any(predicate: (UByte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.any(predicate: (UShort) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.count(predicate: (UInt) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.count(predicate: (ULong) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.count(predicate: (UByte) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.count(predicate: (UShort) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.fold(initial: R, operation: (acc: R, UInt) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.fold(initial: R, operation: (acc: R, ULong) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.fold(initial: R, operation: (acc: R, UByte) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.fold(initial: R, operation: (acc: R, UShort) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.foldIndexed(initial: R, operation: (index: Int, acc: R, UInt) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.foldIndexed(initial: R, operation: (index: Int, acc: R, ULong) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.foldIndexed(initial: R, operation: (index: Int, acc: R, UByte) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.foldIndexed(initial: R, operation: (index: Int, acc: R, UShort) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.foldRight(initial: R, operation: (UInt, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.foldRight(initial: R, operation: (ULong, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.foldRight(initial: R, operation: (UByte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.foldRight(initial: R, operation: (UShort, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.foldRightIndexed(initial: R, operation: (index: Int, UInt, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.foldRightIndexed(initial: R, operation: (index: Int, ULong, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.foldRightIndexed(initial: R, operation: (index: Int, UByte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.foldRightIndexed(initial: R, operation: (index: Int, UShort, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.forEach(action: (UInt) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.forEach(action: (ULong) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.forEach(action: (UByte) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.forEach(action: (UShort) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.forEachIndexed(action: (index: Int, UInt) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.forEachIndexed(action: (index: Int, ULong) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.forEachIndexed(action: (index: Int, UByte) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.forEachIndexed(action: (index: Int, UShort) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.max(): UInt? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.max(): ULong? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.max(): UByte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.max(): UShort? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.maxBy(selector: (UInt) -> R): UInt? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.maxBy(selector: (ULong) -> R): ULong? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.maxBy(selector: (UByte) -> R): UByte? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.maxBy(selector: (UShort) -> R): UShort? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.maxWith(comparator: Comparator<in UInt>): UInt? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.maxWith(comparator: Comparator<in ULong>): ULong? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.maxWith(comparator: Comparator<in UByte>): UByte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.maxWith(comparator: Comparator<in UShort>): UShort? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.min(): UInt? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.min(): ULong? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.min(): UByte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.min(): UShort? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.minBy(selector: (UInt) -> R): UInt? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.minBy(selector: (ULong) -> R): ULong? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.minBy(selector: (UByte) -> R): UByte? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.minBy(selector: (UShort) -> R): UShort? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.minWith(comparator: Comparator<in UInt>): UInt? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.minWith(comparator: Comparator<in ULong>): ULong? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.minWith(comparator: Comparator<in UByte>): UByte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.minWith(comparator: Comparator<in UShort>): UShort? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.none(predicate: (UInt) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.none(predicate: (ULong) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.none(predicate: (UByte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.none(predicate: (UShort) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduce(operation: (acc: UInt, UInt) -> UInt): UInt {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduce(operation: (acc: ULong, ULong) -> ULong): ULong {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduce(operation: (acc: UByte, UByte) -> UByte): UByte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduce(operation: (acc: UShort, UShort) -> UShort): UShort {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceIndexed(operation: (index: Int, acc: UInt, UInt) -> UInt): UInt {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceIndexed(operation: (index: Int, acc: ULong, ULong) -> ULong): ULong {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceIndexed(operation: (index: Int, acc: UByte, UByte) -> UByte): UByte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceIndexed(operation: (index: Int, acc: UShort, UShort) -> UShort): UShort {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceRight(operation: (UInt, acc: UInt) -> UInt): UInt {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceRight(operation: (ULong, acc: ULong) -> ULong): ULong {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceRight(operation: (UByte, acc: UByte) -> UByte): UByte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceRight(operation: (UShort, acc: UShort) -> UShort): UShort {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceRightIndexed(operation: (index: Int, UInt, acc: UInt) -> UInt): UInt {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceRightIndexed(operation: (index: Int, ULong, acc: ULong) -> ULong): ULong {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceRightIndexed(operation: (index: Int, UByte, acc: UByte) -> UByte): UByte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceRightIndexed(operation: (index: Int, UShort, acc: UShort) -> UShort): UShort {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumBy(selector: (UInt) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumBy(selector: (ULong) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumBy(selector: (UByte) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumBy(selector: (UShort) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumByDouble(selector: (UInt) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumByDouble(selector: (ULong) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumByDouble(selector: (UByte) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumByDouble(selector: (UShort) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UIntArray.zip(other: Array<out R>): List<Pair<UInt, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> ULongArray.zip(other: Array<out R>): List<Pair<ULong, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UByteArray.zip(other: Array<out R>): List<Pair<UByte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UShortArray.zip(other: Array<out R>): List<Pair<UShort, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UIntArray.zip(other: Array<out R>, transform: (a: UInt, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> ULongArray.zip(other: Array<out R>, transform: (a: ULong, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UByteArray.zip(other: Array<out R>, transform: (a: UByte, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UShortArray.zip(other: Array<out R>, transform: (a: UShort, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UIntArray.zip(other: Iterable<R>): List<Pair<UInt, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> ULongArray.zip(other: Iterable<R>): List<Pair<ULong, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UByteArray.zip(other: Iterable<R>): List<Pair<UByte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UShortArray.zip(other: Iterable<R>): List<Pair<UShort, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UIntArray.zip(other: Iterable<R>, transform: (a: UInt, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> ULongArray.zip(other: Iterable<R>, transform: (a: ULong, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UByteArray.zip(other: Iterable<R>, transform: (a: UByte, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UShortArray.zip(other: Iterable<R>, transform: (a: UShort, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UIntArray.zip(other: UIntArray): List<Pair<UInt, UInt>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun ULongArray.zip(other: ULongArray): List<Pair<ULong, ULong>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UByteArray.zip(other: UByteArray): List<Pair<UByte, UByte>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UShortArray.zip(other: UShortArray): List<Pair<UShort, UShort>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UIntArray.zip(other: UIntArray, transform: (a: UInt, b: UInt) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> ULongArray.zip(other: ULongArray, transform: (a: ULong, b: ULong) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UByteArray.zip(other: UByteArray, transform: (a: UByte, b: UByte) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UShortArray.zip(other: UShortArray, transform: (a: UShort, b: UShort) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UInt>.sum(): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out ULong>.sum(): ULong {\n    var sum: ULong = 0uL\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfUByte\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UByte>.sum(): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfUShort\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UShort>.sum(): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sum(): UInt {\n    return storage.sum().toUInt()\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sum(): ULong {\n    return storage.sum().toULong()\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sum(): UInt {\n    return sumBy { it.toUInt() }\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sum(): UInt {\n    return sumBy { it.toUInt() }\n}\n\n","package kotlinx.io.core\n\n/**\n * Copy at least [min] but up to [max] bytes to the specified [destination] buffer from this input\n * skipping [offset] bytes. If there are not enough bytes available to provide [min] bytes then\n * it simply return number of available bytes with no exception so the returned value need\n * to be checked.\n * It is safe to specify `max > destination.writeRemaining` but\n * `min` shouldn't be bigger than the [destination] free space.\n * This function could trigger the underlying source reading that may lead to blocking I/O.\n * It is safe to specify too big [offset] so in this case this function will always return `0`.\n * This function usually copy more bytes than [min] (unless `max = min`) but it is not guaranteed.\n * When `0` is returned with `offset = 0` then it makes sense to check [Input.endOfInput].\n *\n * @param destination to write bytes\n * @param offset to skip input\n * @param min bytes to be copied, shouldn't be greater than the buffer free space. Could be `0`.\n * @param max bytes to be copied even if there are more bytes buffered, could be [Int.MAX_VALUE].\n * @return number of bytes copied to the [destination] possibly `0`\n */\n@ExperimentalIoApi\nfun Input.peekTo(destination: IoBuffer, offset: Int = 0, min: Int = 1, max: Int = Int.MAX_VALUE): Int {\n    checkPeekTo(destination, offset, min, max)\n\n    if (this is IoBuffer) {\n        return peekToImpl(destination, offset, min, max)\n    }\n    if (this is ByteReadPacketBase) {\n        prefetch(offset + min)\n        return peekToImpl(destination, offset, min, max)\n    }\n\n    throw UnsupportedOperationException(\"This only works for builtin Inputs and AbstractInput implementations\")\n}\n\nprivate fun IoBuffer.peekToImpl(destination: IoBuffer, offset: Int, min: Int, max: Int): Int {\n    val readRemaining = readRemaining\n    if (readRemaining == 0 || offset > readRemaining) return 0\n\n    val size = minOf(readRemaining - offset, destination.writeRemaining, max)\n    discardExact(offset)\n    writeFully(this, size)\n    pushBack(size + offset)\n\n    return size\n}\n\nprivate fun checkPeekTo(destination: IoBuffer, offset: Int, min: Int, max: Int) {\n    kotlinx.io.core.internal.require(offset >= 0) { \"offset shouldn't be negative: $offset.\" }\n    kotlinx.io.core.internal.require(min >= 0) { \"min shouldn't be negative: $min.\" }\n    kotlinx.io.core.internal.require(max >= min) { \"max should't be less than min: max = $max, min = $min.\" }\n    kotlinx.io.core.internal.require(min <= destination.writeRemaining) {\n        \"Not enough free space in the destination buffer \" +\n            \"to write the specified minimum number of bytes: min = $min, free = ${destination.writeRemaining}.\"\n    }\n}\n","package kotlinx.io.core\n\nimport kotlinx.io.bits.*\n\nfun Output.writeShort(value: Short, byteOrder: ByteOrder) {\n    writePrimitiveTemplate(value, byteOrder, { writeShort(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeInt(value: Int, byteOrder: ByteOrder) {\n    writePrimitiveTemplate(value, byteOrder, { writeInt(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeLong(value: Long, byteOrder: ByteOrder) {\n    writePrimitiveTemplate(value, byteOrder, { writeLong(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeFloat(value: Float, byteOrder: ByteOrder) {\n    writePrimitiveTemplate(value, byteOrder, { writeFloat(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeDouble(value: Double, byteOrder: ByteOrder) {\n    writePrimitiveTemplate(value, byteOrder, { writeDouble(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeShortLittleEndian(value: Short) {\n    writePrimitiveTemplate(value, { writeShort(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeIntLittleEndian(value: Int) {\n    writePrimitiveTemplate(value, { writeInt(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeLongLittleEndian(value: Long) {\n    writePrimitiveTemplate(value, { writeLong(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeFloatLittleEndian(value: Float) {\n    writePrimitiveTemplate(value, { writeFloat(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeDoubleLittleEndian(value: Double) {\n    writePrimitiveTemplate(value, { writeDouble(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeFullyLittleEndian(source: UShortArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFullyLittleEndian(source.asShortArray(), offset, length)\n}\n\nfun Output.writeFullyLittleEndian(source: ShortArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        2,\n        { writeFully(source, offset, length) },\n        { writeShort(source[it].reverseByteOrder()) })\n}\n\nfun Output.writeFullyLittleEndian(source: UIntArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFullyLittleEndian(source.asIntArray(), offset, length)\n}\n\nfun Output.writeFullyLittleEndian(source: IntArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        4,\n        { writeFully(source, offset, length) },\n        { writeInt(source[it].reverseByteOrder()) })\n}\n\nfun Output.writeFullyLittleEndian(source: ULongArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFullyLittleEndian(source.asLongArray(), offset, length)\n}\n\nfun Output.writeFullyLittleEndian(source: LongArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        8,\n        { writeFully(source, offset, length) },\n        { writeLong(source[it].reverseByteOrder()) })\n}\n\nfun Output.writeFullyLittleEndian(source: FloatArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        4,\n        { writeFully(source, offset, length) },\n        { writeFloat(source[it].reverseByteOrder()) })\n}\n\nfun Output.writeFullyLittleEndian(source: DoubleArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        8,\n        { writeFully(source, offset, length) },\n        { writeDouble(source[it].reverseByteOrder()) })\n}\n\nprivate inline fun <T : Any> Output.writePrimitiveTemplate(value: T, write: (T) -> Unit, reverse: T.() -> T) {\n    write(\n        when (byteOrderDeprecated) {\n            ByteOrder.LITTLE_ENDIAN -> value\n            else -> value.reverse()\n        }\n    )\n}\n\nprivate inline fun <T : Any> Output.writePrimitiveTemplate(value: T, byteOrder: ByteOrder, write: (T) -> Unit, reverse: T.() -> T) {\n    write(\n        when {\n            byteOrderDeprecated == byteOrder -> value\n            else -> value.reverse()\n        }\n    )\n}\n\nprivate inline fun Output.writeArrayTemplate(\n    offset: Int,\n    length: Int,\n    componentSize: Int,\n    writeFullyBE: () -> Unit,\n    writeComponent: IoBuffer.(Int) -> Unit\n) {\n    if (byteOrderDeprecated != ByteOrder.LITTLE_ENDIAN) {\n        val untilIndex = offset + length\n        var start = offset\n        writeWhileSize(componentSize) { buffer ->\n            val size = minOf(buffer.writeRemaining / componentSize, untilIndex - start)\n            val lastIndex = start + size - 1\n            for (index in start..lastIndex) {\n                writeComponent(buffer, index)\n            }\n            start += size\n            when {\n                start < untilIndex -> componentSize\n                else -> 0\n            }\n        }\n    } else {\n        writeFullyBE()\n    }\n}\n\n@Suppress(\"DEPRECATION\")\nprivate inline val Output.byteOrderDeprecated\n    get() = byteOrder\n","package kotlinx.io.core\n\n/**\n * Discards bytes until [delimiter] occurred\n * @return number of bytes discarded\n */\nfun Input.discardUntilDelimiter(delimiter: Byte): Long {\n    var discardedTotal = 0L\n\n    takeWhile { chunk ->\n        val discarded = chunk.discardUntilDelimiterImpl(delimiter)\n        discardedTotal += discarded\n        discarded > 0 && !chunk.canRead()\n    }\n\n    return discardedTotal\n}\n\n/**\n * Discards bytes until of of the specified delimiters [delimiter1] or [delimiter2] occurred\n * @return number of bytes discarded\n */\nfun Input.discardUntilDelimiters(delimiter1: Byte, delimiter2: Byte): Long {\n    var discardedTotal = 0L\n\n    takeWhile { chunk ->\n        val discarded = chunk.discardUntilDelimitersImpl(delimiter1, delimiter2)\n        discardedTotal += discarded\n        discarded > 0 && !chunk.canRead()\n    }\n\n    return discardedTotal\n}\n\n/**\n * Copies to [dst] array at [offset] at most [length] bytes or until the specified [delimiter] occurred.\n * @return number of bytes copied\n */\nfun Input.readUntilDelimiter(delimiter: Byte, dst: ByteArray, offset: Int = 0, length: Int = dst.size): Int {\n    var currentOffset = offset\n    var dstRemaining = length\n\n    takeWhile { chunk ->\n        val copied = chunk.readUntilDelimiterImpl(delimiter, dst, currentOffset, dstRemaining)\n        currentOffset += copied\n        dstRemaining -= copied\n        dstRemaining > 0 && !chunk.canRead()\n    }\n\n    return currentOffset - offset\n}\n\n/**\n * Copies to [dst] array at [offset] at most [length] bytes or until one of the specified delimiters\n * [delimiter1] or [delimiter2] occurred.\n * @return number of bytes copied\n */\nfun Input.readUntilDelimiters(delimiter1: Byte, delimiter2: Byte,\n                              dst: ByteArray, offset: Int = 0, length: Int = dst.size): Int {\n    if (delimiter1 == delimiter2) return readUntilDelimiter(delimiter1, dst, offset, length)\n\n    var currentOffset = offset\n    var dstRemaining = length\n\n    takeWhile {  chunk ->\n        val copied = chunk.readUntilDelimitersImpl(delimiter1, delimiter2, dst, currentOffset, dstRemaining)\n        currentOffset += copied\n        dstRemaining -= copied\n        !chunk.canRead() && dstRemaining > 0\n    }\n\n    return currentOffset - offset\n}\n\n/**\n * Copies to [dst] output until the specified [delimiter] occurred.\n * @return number of bytes copied\n */\nfun Input.readUntilDelimiter(delimiter: Byte, dst: Output): Long {\n    var copiedTotal = 0L\n    takeWhile { chunk ->\n        val copied = chunk.readUntilDelimiterImpl(delimiter, dst)\n        copiedTotal += copied\n        !chunk.canRead()\n    }\n\n    return copiedTotal\n}\n\n/**\n * Copies to [dst] output until one of the specified delimiters\n * [delimiter1] or [delimiter2] occurred.\n * @return number of bytes copied\n */\nfun Input.readUntilDelimiters(delimiter1: Byte, delimiter2: Byte, dst: Output): Long {\n    var copiedTotal = 0L\n\n    takeWhile {  chunk ->\n        val copied = chunk.readUntilDelimitersImpl(delimiter1, delimiter2, dst)\n        copiedTotal += copied\n        !chunk.canRead()\n    }\n\n    return copiedTotal\n}\n\ninternal expect fun IoBuffer.discardUntilDelimiterImpl(delimiter: Byte): Int\n\ninternal expect fun IoBuffer.discardUntilDelimitersImpl(delimiter1: Byte, delimiter2: Byte): Int\n\n\ninternal expect fun IoBuffer.readUntilDelimiterImpl(delimiter: Byte,\n                                                    dst: ByteArray, offset: Int, length: Int): Int\n\ninternal expect fun IoBuffer.readUntilDelimitersImpl(delimiter1: Byte, delimiter2: Byte,\n                                                     dst: ByteArray, offset: Int, length: Int): Int\n\ninternal expect fun IoBuffer.readUntilDelimiterImpl(delimiter: Byte,\n                                                    dst: Output): Int\n\ninternal expect fun IoBuffer.readUntilDelimitersImpl(delimiter1: Byte, delimiter2: Byte,\n                                                     dst: Output): Int\n\n","package kotlinx.io.core\n\nimport kotlinx.io.charsets.*\nimport kotlinx.io.core.internal.*\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninline fun String.toByteArray(charset: Charset = Charsets.UTF_8): ByteArray =\n    charset.newEncoder().encodeToByteArray(this, 0, length)\n\nexpect fun String(\n    bytes: ByteArray,\n    offset: Int = 0,\n    length: Int = bytes.size,\n    charset: Charset = Charsets.UTF_8\n): String\n\n/**\n * Read a string line considering optionally specified [estimate] but up to optional [limit] characters length\n * (does fail once limit exceeded) or return `null` if the packet is empty\n */\nfun ByteReadPacket.readUTF8Line(estimate: Int = 16, limit: Int = Int.MAX_VALUE): String? {\n    if (isEmpty) return null\n    val sb = StringBuilder(estimate)\n    return if (readUTF8LineTo(sb, limit)) sb.toString() else null\n}\n\n/**\n * Read a string line considering optionally specified [estimate] but up to optional [limit] characters length\n * (does fail once limit exceeded) or return `null` if the packet is empty\n */\nfun Input.readUTF8Line(estimate: Int = 16, limit: Int = Int.MAX_VALUE): String? {\n    val sb = StringBuilder(estimate)\n    return if (readUTF8LineTo(sb, limit)) sb.toString() else null\n}\n\n/**\n * Read UTF-8 line and append all line characters to [out] except line endings. Does support CR, LF and CR+LF\n * @return `true` if some characters were appended or line ending reached (empty line) or `false` if packet\n * if empty\n */\nfun Input.readUTF8LineTo(out: Appendable, limit: Int): Boolean {\n    var decoded = 0\n    var size = 1\n    var cr = false\n    var end = false\n\n    takeWhileSize { buffer ->\n        var skip = 0\n        size = buffer.decodeUTF8 { ch ->\n            when (ch) {\n                '\\r' -> {\n                    if (cr) {\n                        end = true\n                        return@decodeUTF8 false\n                    }\n                    cr = true\n                    true\n                }\n                '\\n' -> {\n                    end = true\n                    skip = 1\n                    false\n                }\n                else -> {\n                    if (cr) {\n                        end = true\n                        return@decodeUTF8 false\n                    }\n\n                    if (decoded == limit) bufferLimitExceeded(limit)\n                    decoded++\n                    out.append(ch)\n                    true\n                }\n            }\n        }\n\n        if (skip > 0) {\n            buffer.discardExact(skip)\n        }\n\n        if (end) 0 else size.coerceAtLeast(1)\n    }\n\n    if (size > 1) prematureEndOfStream(size)\n\n    return decoded > 0 || !endOfInput\n}\n\n/**\n * Reads UTF-8 characters until one of the specified [delimiters] found, [limit] exceeded or end of stream encountered\n *\n * @throws BufferLimitExceededException\n * @returns a string of characters read before delimiter\n */\nfun Input.readUTF8UntilDelimiter(delimiters: String, limit: Int = Int.MAX_VALUE): String {\n    return buildString {\n        readUTF8UntilDelimiterTo(this, delimiters, limit)\n    }\n}\n\n/**\n * Reads UTF-8 characters to [out] buffer until one of the specified [delimiters] found, [limit] exceeded\n * or end of stream encountered\n *\n * @throws BufferLimitExceededException\n * @returns number of characters copied (possibly zero)\n */\nfun Input.readUTF8UntilDelimiterTo(out: Appendable, delimiters: String, limit: Int = Int.MAX_VALUE): Int {\n    var decoded = 0\n    var delimiter = false\n\n    takeWhile { buffer ->\n        buffer.decodeASCII { ch ->\n            if (ch in delimiters) {\n                delimiter = true\n                false\n            } else {\n                if (decoded == limit) bufferLimitExceeded(limit)\n                decoded++\n                out.append(ch)\n                true\n            }\n        }\n    }\n\n    if (!delimiter) {\n        decoded = readUTF8UntilDelimiterToSlowUtf8(out, delimiters, limit, decoded)\n    }\n\n    return decoded\n}\n\n/**\n * Reads UTF-8 characters to [out] buffer until one of the specified [delimiters] found, [limit] exceeded\n * or end of stream encountered\n *\n * @throws BufferLimitExceededException\n * @returns number of characters copied (possibly zero)\n */\nfun Input.readUTF8UntilDelimiterTo(out: Output, delimiters: String, limit: Int = Int.MAX_VALUE): Int {\n    val delimitersCount = delimiters.length\n    if (delimitersCount == 1 && delimiters[0].isAsciiChar()) {\n        return readUntilDelimiter(delimiters[0].toByte(), out).toInt()\n    } else if (delimitersCount == 2 && delimiters[0].isAsciiChar() && delimiters[1].isAsciiChar()) {\n        return readUntilDelimiters(delimiters[0].toByte(), delimiters[1].toByte(), out).toInt()\n    }\n\n    return readUTFUntilDelimiterToSlowAscii(delimiters, limit, out)\n}\n\n@Suppress(\"unused\", \"DEPRECATION_ERROR\")\n@Deprecated(\"Use Output version instead\", level = DeprecationLevel.HIDDEN)\nfun Input.readUTF8UntilDelimiterTo(out: BytePacketBuilderBase, delimiters: String, limit: Int = Int.MAX_VALUE): Int {\n    return readUTF8UntilDelimiterTo(out as Output, delimiters, limit)\n}\n\n/**\n * Read exactly [n] bytes (consumes all remaining if [n] is not specified but up to [Int.MAX_VALUE] bytes).\n * Does fail if not enough bytes remaining.\n */\nfun ByteReadPacket.readBytes(\n    n: Int = remaining.coerceAtMostMaxIntOrFail(\"Unable to convert to a ByteArray: packet is too big\")\n): ByteArray =\n    ByteArray(n).also { readFully(it, 0, n) }\n\n/**\n * Reads exactly [n] bytes from the input or fails if not enough bytes available.\n */\nfun Input.readBytes(n: Int): ByteArray = readBytesOf(n, n)\n\n/**\n * Reads all remaining bytes from the input\n */\nfun Input.readBytes(): ByteArray = readBytesOf()\n\n/**\n * Reads at least [min] but no more than [max] bytes from the input to a new byte array\n * @throws EOFException if not enough bytes available to get [min] bytes\n */\nfun Input.readBytesOf(min: Int = 0, max: Int = Int.MAX_VALUE): ByteArray = if (min == max) {\n    ByteArray(min).also { readFully(it, 0, min) }\n} else {\n    var array = ByteArray(max.toLong().coerceAtMost(sizeEstimate()).coerceAtLeast(min.toLong()).toInt())\n    var size = 0\n\n    while (size < max) {\n        val partSize = minOf(max, array.size) - size\n        val rc = readAvailable(array, size, partSize)\n        if (rc <= 0) break\n        size += rc\n        if (array.size == size) {\n            array = array.copyOf(size * 2)\n        }\n    }\n\n    if (size < min) {\n        throw EOFException(\"Not enough bytes available to read $min bytes: ${min - size} more required\")\n    }\n\n    if (size == array.size) array else array.copyOf(size)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [decoder]. Extra character bytes will remain unconsumed\n * @return number of characters copied to [out]\n */\n@Deprecated(\"Use CharsetDecoder.decode instead\",\n    ReplaceWith(\"decoder.decode(this, out, max)\", \"kotlinx.io.charsets.decode\"),\n    level = DeprecationLevel.ERROR\n)\nfun Input.readText(out: Appendable, decoder: CharsetDecoder, max: Int = Int.MAX_VALUE): Int {\n    return decoder.decode(this, out, max)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [charset]. Extra character bytes will remain unconsumed\n * @return number of characters copied to [out]\n */\nfun Input.readText(out: Appendable, charset: Charset = Charsets.UTF_8, max: Int = Int.MAX_VALUE): Int {\n    return charset.newDecoder().decode(this, out, max)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [decoder]. Extra character bytes will remain unconsumed\n * @return a decoded string\n */\n@Deprecated(\n    \"Use CharsetDecoder.decode instead\",\n    ReplaceWith(\"decoder.decode(this, max)\", \"kotlinx.io.charsets.decode\"),\n    level = DeprecationLevel.ERROR\n)\nfun Input.readText(decoder: CharsetDecoder, max: Int = Int.MAX_VALUE): String {\n    return decoder.decode(this, max)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [charset]. Extra character bytes will remain unconsumed\n * @return a decoded string\n */\nfun Input.readText(charset: Charset = Charsets.UTF_8, max: Int = Int.MAX_VALUE): String {\n    return charset.newDecoder().decode(this, max)\n}\n\n/**\n * Read exactly [n] characters interpreting bytes in the specified [charset].\n */\n@Deprecated(\n    \"Use readTextExactCharacters instead.\",\n    ReplaceWith(\"readTextExactCharacters(n, charset)\")\n)\nfun Input.readTextExact(charset: Charset = Charsets.UTF_8, n: Int): String {\n    return readTextExactCharacters(n, charset)\n}\n\n/**\n * Read exactly [charactersCount] characters interpreting bytes in the specified [charset].\n */\nfun Input.readTextExactCharacters(charactersCount: Int, charset: Charset = Charsets.UTF_8): String {\n    val s = readText(charset, charactersCount)\n    if (s.length < charactersCount) {\n        prematureEndOfStreamToReadChars(charactersCount)\n    }\n    return s\n}\n\n\n/**\n * Read exactly the specified number of [bytes]\n * interpreting bytes in the specified [charset] (optional, UTF-8 by default).\n */\n@Deprecated(\"Parameters order is changed.\", ReplaceWith(\"readTextExactBytes(bytes, charset)\"))\nfun Input.readTextExactBytes(charset: Charset = Charsets.UTF_8, bytes: Int): String {\n    return readTextExactBytes(bytes, charset)\n}\n\n/**\n * Read exactly [bytesCount] interpreting bytes in the specified [charset] (optional, UTF-8 by default).\n */\nfun Input.readTextExactBytes(bytesCount: Int, charset: Charset = Charsets.UTF_8): String {\n    return charset.newDecoder().decodeExactBytes(this, inputLength = bytesCount)\n}\n\n/**\n * Writes [text] characters in range \\[[fromIndex] .. [toIndex]) with the specified [encoder]\n */\n@Deprecated(\n    \"Use the implementation with Charset instead\",\n    ReplaceWith(\"writeText(text, fromIndex, toIndex, encoder.charset)\", \"kotlinx.io.charsets.charset\")\n)\nfun Output.writeText(text: CharSequence, fromIndex: Int = 0, toIndex: Int = text.length, encoder: CharsetEncoder) {\n    encoder.encodeToImpl(this, text, fromIndex, toIndex)\n}\n\n/**\n * Writes [text] characters in range \\[[fromIndex] .. [toIndex]) with the specified [charset]\n */\nfun Output.writeText(text: CharSequence, fromIndex: Int = 0, toIndex: Int = text.length, charset: Charset = Charsets.UTF_8) {\n    charset.newEncoder().encodeToImpl(this, text, fromIndex, toIndex)\n}\n\ninternal expect fun String.getCharsInternal(dst: CharArray, dstOffset: Int)\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\nprivate inline fun Char.isAsciiChar() = toInt() <= 0x7f\n\nprivate fun Input.readUTFUntilDelimiterToSlowAscii(delimiters: String, limit: Int, out: Output): Int {\n    var decoded = 0\n    var delimiter = false\n\n    takeWhile { buffer ->\n        val before = buffer.readRemaining\n\n        val rc = buffer.decodeASCII { ch ->\n            if (ch in delimiters) {\n                delimiter = true\n                false\n            } else {\n                if (decoded == limit) bufferLimitExceeded(limit)\n                decoded++\n                true\n            }\n        }\n\n        val delta = before - buffer.readRemaining\n        if (delta > 0) {\n            buffer.pushBack(delta)\n            out.writeFully(buffer, delta)\n        }\n\n        rc\n    }\n\n    if (!delimiter && !endOfInput) {\n        decoded = readUTF8UntilDelimiterToSlowUtf8(out, delimiters, limit, decoded)\n    }\n\n    return decoded\n}\n\nprivate fun Input.readUTF8UntilDelimiterToSlowUtf8(\n    out: Output,\n    delimiters: String,\n    limit: Int,\n    decoded0: Int\n): Int {\n    var decoded = decoded0\n    var size = 1\n\n    takeWhileSize { buffer ->\n        val before = buffer.readRemaining\n\n        size = buffer.decodeUTF8 { ch ->\n            if (ch in delimiters) {\n                false\n            } else {\n                if (decoded == limit) {\n                    bufferLimitExceeded(limit)\n                }\n                decoded++\n                true\n            }\n        }\n\n        val delta = before - buffer.readRemaining\n        if (delta > 0) {\n            buffer.pushBack(delta)\n            out.writeFully(buffer, delta)\n        }\n\n        size = if (size == -1) 0 else size.coerceAtLeast(1)\n        size\n    }\n\n    if (size > 1) prematureEndOfStream(size)\n\n    return decoded\n}\n\nprivate fun Input.readUTF8UntilDelimiterToSlowUtf8(\n    out: Appendable,\n    delimiters: String,\n    limit: Int,\n    decoded0: Int\n): Int {\n    var decoded = decoded0\n    var size = 1\n\n    takeWhileSize { buffer ->\n        size = buffer.decodeUTF8 { ch ->\n            if (ch in delimiters) {\n                false\n            } else {\n                if (decoded == limit) {\n                    bufferLimitExceeded(limit)\n                }\n                decoded++\n                out.append(ch)\n                true\n            }\n        }\n\n        size = if (size == -1) 0 else size.coerceAtLeast(1)\n        size\n    }\n\n    if (size > 1) prematureEndOfStream(size)\n\n    return decoded\n}\n\nprivate fun bufferLimitExceeded(limit: Int): Nothing {\n    throw BufferLimitExceededException(\"Too many characters before delimiter: limit $limit exceeded\")\n}\n\nprivate fun prematureEndOfStream(size: Int): Nothing =\n    throw MalformedUTF8InputException(\"Premature end of stream: expected $size bytes\")\n\nprivate fun prematureEndOfStreamToReadChars(charactersCount: Int): Nothing =\n    throw EOFException(\"Not enough input bytes to read $charactersCount characters.\")\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage kotlinx.io.core\n\n@ExperimentalUnsignedTypes\ninline fun Input.readUByte(): UByte = readByte().toUByte()\n\n@ExperimentalUnsignedTypes\ninline fun Input.readUShort(): UShort = readShort().toUShort()\n\n@ExperimentalUnsignedTypes\ninline fun Input.readUInt(): UInt = readInt().toUInt()\n\n@ExperimentalUnsignedTypes\ninline fun Input.readULong(): ULong = readLong().toULong()\n\n@ExperimentalUnsignedTypes\ninline fun Input.readFully(dst: UByteArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst.asByteArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\ninline fun Input.readFully(dst: UShortArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst.asShortArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\ninline fun Input.readFully(dst: UIntArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst.asIntArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\ninline fun Input.readFully(dst: ULongArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst.asLongArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\ninline fun Output.writeUByte(v: UByte) {\n    writeByte(v.toByte())\n}\n\n@ExperimentalUnsignedTypes\ninline fun Output.writeUShort(v: UShort) {\n    writeShort(v.toShort())\n}\n\n@ExperimentalUnsignedTypes\ninline fun Output.writeUInt(v: UInt) {\n    writeInt(v.toInt())\n}\n\n@ExperimentalUnsignedTypes\ninline fun Output.writeULong(v: ULong) {\n    writeLong(v.toLong())\n}\n\n@ExperimentalUnsignedTypes\ninline fun Output.writeFully(array: UByteArray, offset: Int = 0, length: Int = array.size - offset) {\n    writeFully(array.asByteArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\ninline fun Output.writeFully(array: UShortArray, offset: Int = 0, length: Int = array.size - offset) {\n    writeFully(array.asShortArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\ninline fun Output.writeFully(array: UIntArray, offset: Int = 0, length: Int = array.size - offset) {\n    writeFully(array.asIntArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\ninline fun Output.writeFully(array: ULongArray, offset: Int = 0, length: Int = array.size - offset) {\n    writeFully(array.asLongArray(), offset, length)\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class UByte @PublishedApi internal constructor(@PublishedApi internal val data: Byte) : Comparable<UByte> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UByte can have.\n         */\n        public const val MIN_VALUE: UByte = UByte(0)\n\n        /**\n         * A constant holding the maximum value an instance of UByte can have.\n         */\n        public const val MAX_VALUE: UByte = UByte(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 1\n\n        /**\n         * The number of bits used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BITS: Int = 8\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UByte = UByte(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UByte = UByte(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UByte): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UByte): UByte = UByte(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UByte): UByte = UByte(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UByte): UByte = UByte(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UByte = UByte(data.inv())\n\n    /**\n     * Converts this [UByte] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UByte`. Otherwise the result is negative.\n     *\n     * The resulting `Byte` value has the same binary representation as this `UByte` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data\n    /**\n     * Converts this [UByte] value to [Short].\n     *\n     * The resulting `Short` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Short` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort() and 0xFF\n    /**\n     * Converts this [UByte] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Int` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFF\n    /**\n     * Converts this [UByte] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Long` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFF\n\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = this\n    /**\n     * Converts this [UByte] value to [UShort].\n     *\n     * The resulting `UShort` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = UShort(data.toShort() and 0xFF)\n    /**\n     * Converts this [UByte] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFF)\n    /**\n     * Converts this [UByte] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFF)\n\n    /**\n     * Converts this [UByte] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UByte] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UByte].\n *\n * If this value is positive, the resulting `UByte` value represents the same numerical value as this `Byte`.\n *\n * The resulting `UByte` value has the same binary representation as this `Byte` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUByte(): UByte = UByte(this)\n/**\n * Converts this [Short] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Short`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Short` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Int] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Int` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Long] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUByte(): UByte = UByte(this.toByte())\n","package kotlinx.io.core\n\ninline fun <I : Input, R> I.use(block: (I) -> R): R {\n    return try {\n        block(this)\n    } finally {\n        close()\n    }\n}\n\ninline fun <O : Output, R> O.use(block: (O) -> R): R {\n    return try {\n        block(this)\n    } finally {\n        close()\n    }\n}\n",null,"package kotlinx.io.core.internal\n\nimport kotlinx.io.core.*\n\n/**\n * API marked with this annotation is internal and extremely fragile and not intended to be used by library users.\n * Such API could be changed without notice including rename, removal and behaviour change.\n * Also using API marked with this annotation could cause data loss or any other damage.\n */\n@Experimental(level = Experimental.Level.ERROR)\nannotation class DangerousInternalIoApi\n\n@DangerousInternalIoApi\nfun ByteReadPacket.`$unsafeAppend$`(builder: BytePacketBuilder) {\n    val builderSize = builder.size\n    val builderHead = builder.head\n\n    if (builderSize <= PACKET_MAX_COPY_SIZE && builderHead.next == null && tryWriteAppend(builderHead)) {\n        builder.afterBytesStolen()\n        return\n    }\n\n    builder.stealAll()?.let { chain ->\n        append(chain)\n    }\n}\n\n@DangerousInternalIoApi\nfun Input.prepareReadFirstHead(minSize: Int): IoBuffer? {\n    if (this is ByteReadPacketBase) {\n        return prepareReadHead(minSize)\n    }\n    if (this is IoBuffer) {\n        return if (canRead()) this else null\n    }\n\n    return prepareReadHeadFallback(minSize)\n}\n\nprivate fun Input.prepareReadHeadFallback(minSize: Int): IoBuffer? {\n    if (endOfInput) return null\n\n    val buffer = IoBuffer.Pool.borrow()\n\n    val rc = peekTo(buffer)\n    if (rc < minSize) {\n        buffer.release(IoBuffer.Pool)\n        return null\n    }\n\n    return buffer\n}\n\n@DangerousInternalIoApi\nfun Input.completeReadHead(current: IoBuffer) {\n    if (current === this) {\n        return\n    }\n    if (this is ByteReadPacketBase) {\n        val remaining = current.readRemaining\n        if (remaining == 0) {\n            ensureNext(current)\n        } else if (current.endGap < IoBuffer.ReservedSize) {\n            fixGapAfterRead(current)\n        } else {\n            updateHeadRemaining(remaining)\n        }\n        return\n    }\n\n    completeReadHeadFallback(current)\n}\n\nprivate fun Input.completeReadHeadFallback(current: IoBuffer) {\n    val discardAmount = current.capacity - current.writeRemaining - current.readRemaining\n    discardExact(discardAmount)\n    current.release(IoBuffer.Pool)\n}\n\n@DangerousInternalIoApi\nfun Input.prepareReadNextHead(current: IoBuffer): IoBuffer? {\n    if (current === this) {\n        return if (canRead()) this else null\n    }\n    if (this is ByteReadPacketBase) {\n        return ensureNextHead(current)\n    }\n\n    return prepareNextReadHeadFallback(current)\n}\n\nprivate fun Input.prepareNextReadHeadFallback(current: IoBuffer): IoBuffer? {\n    val discardAmount = current.capacity - current.writeRemaining - current.readRemaining\n    discardExact(discardAmount)\n    current.resetForWrite()\n\n    if (endOfInput || peekTo(current) <= 0) {\n        current.release(IoBuffer.Pool)\n        return null\n    }\n\n    return current\n}\n\n@DangerousInternalIoApi\nfun Output.prepareWriteHead(capacity: Int, current: IoBuffer?): IoBuffer {\n    @Suppress(\"DEPRECATION_ERROR\")\n    if (this is BytePacketBuilderBase) {\n        return prepareWriteHead(capacity)\n    }\n\n    return prepareWriteHeadFallback(current)\n}\n\nprivate fun Output.prepareWriteHeadFallback(current: IoBuffer?): IoBuffer {\n    if (current != null) {\n        writeFully(current)\n        current.resetForWrite()\n        return current\n    }\n\n    return IoBuffer.Pool.borrow()\n}\n\n@DangerousInternalIoApi\nfun Output.afterHeadWrite(current: IoBuffer) {\n    @Suppress(\"DEPRECATION_ERROR\")\n    if (this is BytePacketBuilderBase) {\n        return afterHeadWrite()\n    }\n\n    afterWriteHeadFallback(current)\n}\n\nprivate fun Output.afterWriteHeadFallback(current: IoBuffer) {\n    writeFully(current)\n    current.release(IoBuffer.Pool)\n}\n","package kotlinx.io.pool\n\nimport kotlinx.atomicfu.*\nimport kotlinx.io.core.*\nimport kotlin.jvm.*\n\ninterface ObjectPool<T : Any> : Closeable {\n    /**\n     * Pool capacity\n     */\n    val capacity: Int\n\n    /**\n     * borrow an instance. Pool can recycle an old instance or create a new one\n     */\n    fun borrow(): T\n\n    /**\n     * Recycle an instance. Should be recycled what was borrowed before otherwise could fail\n     */\n    fun recycle(instance: T)\n\n    /**\n     * Dispose the whole pool. None of borrowed objects could be used after the pool gets disposed\n     * otherwise it can result in undefined behaviour\n     */\n    fun dispose()\n\n    /**\n     * Does pool dispose\n     */\n    override fun close() = dispose()\n}\n\n/**\n * A pool implementation of zero capacity that always creates new instances\n */\nabstract class NoPoolImpl<T : Any> : ObjectPool<T> {\n    override val capacity: Int\n        get() = 0\n\n    override fun recycle(instance: T) {\n    }\n\n    override fun dispose() {\n    }\n}\n\n/**\n * A pool that produces at most one instance\n */\nabstract class SingleInstancePool<T : Any> : ObjectPool<T> {\n    private val borrowed = atomic(0)\n    private val disposed = atomic(false)\n\n    @Volatile\n    private var instance: T? = null\n\n    /**\n     * Creates a new instance of [T]\n     */\n    protected abstract fun produceInstance(): T\n\n    /**\n     * Dispose [instance] and release it's resources\n     */\n    protected abstract fun disposeInstance(instance: T)\n\n    final override val capacity: Int get() = 1\n\n    final override fun borrow(): T {\n        borrowed.update {\n            if (it != 0) throw IllegalStateException(\"Instance is already consumed\")\n            1\n        }\n\n        val instance = produceInstance()\n        this.instance = instance\n\n        return instance\n    }\n\n    final override fun recycle(instance: T) {\n        if (this.instance !== instance) {\n            if (this.instance == null && borrowed.value != 0) {\n                throw IllegalStateException(\"Already recycled or an irrelevant instance tried to be recycled\")\n            }\n\n            throw IllegalStateException(\"Unable to recycle irrelevant instance\")\n        }\n\n        this.instance = null\n\n        if (!disposed.compareAndSet(false, true)) {\n            throw IllegalStateException(\"An instance is already disposed\")\n        }\n\n        disposeInstance(instance)\n    }\n\n    final override fun dispose() {\n        if (disposed.compareAndSet(false, true)) {\n            val instance = this.instance ?: return\n            this.instance = null\n\n            disposeInstance(instance)\n        }\n    }\n}\n\n/**\n * Default object pool implementation.\n */\nexpect abstract class DefaultPool<T : Any>(capacity: Int) : ObjectPool<T> {\n    /**\n     * Pool capacity.\n     */\n    final override val capacity: Int\n\n    /**\n     * Creates a new instance of [T]\n     */\n    protected abstract fun produceInstance(): T\n\n    /**\n     * Dispose [instance] and release it's resources\n     */\n    protected open fun disposeInstance(instance: T)\n\n    /**\n     * Clear [instance]'s state before reuse: reset pointers, counters and so on\n     */\n    protected open fun clearInstance(instance: T): T\n\n    /**\n     * Validate [instance] of [T]. Could verify that the object has been borrowed from this pool\n     */\n    protected open fun validateInstance(instance: T)\n\n    final override fun borrow(): T\n\n    final override fun recycle(instance: T)\n\n    final override fun dispose()\n}\n\n/**\n * Borrows and instance of [T] from the pool, invokes [block] with it and finally recycles it\n */\n@Deprecated(\"Use useInstance instead\", ReplaceWith(\"useInstance(block)\"), level = DeprecationLevel.ERROR)\ninline fun <T : Any, R> ObjectPool<T>.useBorrowed(block: (T) -> R): R {\n    return useInstance(block)\n}\n\n/**\n * Borrows and instance of [T] from the pool, invokes [block] with it and finally recycles it\n */\ninline fun <T : Any, R> ObjectPool<T>.useInstance(block: (T) -> R): R {\n    val instance = borrow()\n    try {\n        return block(instance)\n    } finally {\n        recycle(instance)\n    }\n}\n\n",null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n/**\n * Returns `true` if the specified number is a\n * Not-a-Number (NaN) value, `false` otherwise.\n */\npublic actual fun Double.isNaN(): Boolean = this != this\n\n/**\n * Returns `true` if the specified number is a\n * Not-a-Number (NaN) value, `false` otherwise.\n */\npublic actual fun Float.isNaN(): Boolean = this != this\n\n/**\n * Returns `true` if this value is infinitely large in magnitude.\n */\npublic actual fun Double.isInfinite(): Boolean = this == Double.POSITIVE_INFINITY || this == Double.NEGATIVE_INFINITY\n\n/**\n * Returns `true` if this value is infinitely large in magnitude.\n */\npublic actual fun Float.isInfinite(): Boolean = this == Float.POSITIVE_INFINITY || this == Float.NEGATIVE_INFINITY\n\n/**\n * Returns `true` if the argument is a finite floating-point value; returns `false` otherwise (for `NaN` and infinity arguments).\n */\npublic actual fun Double.isFinite(): Boolean = !isInfinite() && !isNaN()\n\n/**\n * Returns `true` if the argument is a finite floating-point value; returns `false` otherwise (for `NaN` and infinity arguments).\n */\npublic actual fun Float.isFinite(): Boolean = !isInfinite() && !isNaN()\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToBits\")\npublic actual fun Double.toBits(): Long = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout,\n * preserving `NaN` values exact layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToRawBits\")\npublic actual fun Double.toRawBits(): Long = definedExternally\n\n/**\n * Returns the [Double] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Double.Companion.fromBits(bits: Long): Double = js(\"Kotlin\").doubleFromBits(bits).unsafeCast<Double>()\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToBits\")\npublic actual fun Float.toBits(): Int = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout,\n * preserving `NaN` values exact layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToRawBits\")\npublic actual fun Float.toRawBits(): Int = definedExternally\n\n/**\n * Returns the [Float] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Float.Companion.fromBits(bits: Int): Float = js(\"Kotlin\").floatFromBits(bits).unsafeCast<Float>()","package kotlinx.io.charsets\n\nimport kotlinx.io.core.*\nimport kotlinx.io.js.*\nimport org.khronos.webgl.*\n\nactual abstract class Charset(internal val _name: String) {\n    actual abstract fun newEncoder(): CharsetEncoder\n    actual abstract fun newDecoder(): CharsetDecoder\n\n    override fun toString(): String {\n        return name\n    }\n\n    actual companion object {\n        actual fun forName(name: String): Charset {\n            if (name == \"UTF-8\" || name == \"utf-8\" || name == \"UTF8\" || name == \"utf8\") return Charsets.UTF_8\n            if (name == \"ISO-8859-1\" || name == \"iso-8859-1\"\n                || name.toLowerCase().replace('_', '-') == \"iso-8859-1\"\n                || name == \"latin1\"\n            ) {\n                return Charsets.ISO_8859_1\n            }\n            throw IllegalArgumentException(\"Charset $name is not supported\")\n        }\n\n    }\n}\n\nactual val Charset.name: String get() = _name\n\n// -----------------------\n\nactual abstract class CharsetEncoder(internal val _charset: Charset)\nprivate data class CharsetEncoderImpl(private val charset: Charset) : CharsetEncoder(charset)\nactual val CharsetEncoder.charset: Charset get() = _charset\n\nactual fun CharsetEncoder.encodeToByteArray(input: CharSequence, fromIndex: Int, toIndex: Int): ByteArray\n        = encodeToByteArrayImpl1(input, fromIndex, toIndex)\n\ninternal actual fun CharsetEncoder.encodeImpl(input: CharSequence, fromIndex: Int, toIndex: Int, dst: IoBuffer): Int {\n    require(fromIndex <= toIndex)\n    if (charset == Charsets.ISO_8859_1) {\n        return encodeISO88591(input, fromIndex, toIndex, dst)\n    }\n\n    require(charset === Charsets.UTF_8) { \"Only UTF-8 encoding is supported in JS\" }\n\n    val encoder = TextEncoderCtor()  // Only UTF-8 is supported so we know that at most 6 bytes per character is used\n    var start = fromIndex\n    var dstRemaining = dst.writeRemaining\n\n    while (start < toIndex && dstRemaining > 0) {\n        val numChars = minOf(toIndex - start, dstRemaining / 6).coerceAtLeast(1)\n        val dropLastChar = input[start + numChars - 1].isHighSurrogate()\n        val endIndexExclusive = when {\n            dropLastChar && numChars == 1 -> start + 2\n            dropLastChar -> start + numChars - 1\n            else -> start + numChars\n        }\n\n        val array1 = encoder.encode(input.substring(start, endIndexExclusive))\n        if (array1.length > dst.writeRemaining) break\n        dst.writeFully(array1, 0, array1.length)\n        start = endIndexExclusive\n        dstRemaining -= array1.length\n    }\n\n    return start - fromIndex\n}\n\nactual fun CharsetEncoder.encodeUTF8(input: ByteReadPacket, dst: Output) {\n    require(charset === Charsets.UTF_8)\n    // we only support UTF-8 so as far as input is UTF-8 encoded string then we simply copy bytes\n    dst.writePacket(input)\n}\n\ninternal actual fun CharsetEncoder.encodeComplete(dst: IoBuffer): Boolean = true\n\n// ----------------------------------------------------------------------\n\nactual abstract class CharsetDecoder(internal val _charset: Charset)\n\nprivate data class CharsetDecoderImpl(private val charset: Charset) : CharsetDecoder(charset)\n\nactual val CharsetDecoder.charset: Charset get() = _charset\n\nactual fun CharsetDecoder.decode(input: Input, dst: Appendable, max: Int): Int {\n    val decoder = TextDecoderFatal(charset.name, true)\n    var copied = 0\n\n    input.takeWhileSize { buffer ->\n        val rem = max - copied\n        if (rem == 0) return@takeWhileSize 0\n\n        copied += buffer.readText(decoder, dst, buffer.next == null, rem)\n        1\n    }\n\n    if (copied < max) {\n        val s = decodeWrap { decoder.decode() }\n        if (s.length > max - copied) {\n            throw UnsupportedOperationException(\"Partial trailing characters are not supported\")\n        }\n\n        dst.append(s)\n        copied += s.length\n    }\n\n    return copied\n}\n\nactual fun CharsetDecoder.decodeExactBytes(input: Input, inputLength: Int): String {\n    if (inputLength == 0) return \"\"\n    if (input is ByteReadPacketBase && input.headRemaining >= inputLength) {\n        val decoder = TextDecoderFatal(charset._name, true)\n\n        val head = input.head\n        val text = decodeWrap {\n            when {\n                head.readPosition == 0 && inputLength == head.content.byteLength -> decoder.decode(head.content)\n                else -> decoder.decode(Int8Array(head.content, head.readPosition, inputLength))\n            }\n        }\n\n        input.discardExact(inputLength)\n        return text\n    }\n\n    return decodeExactBytesSlow(input, inputLength)\n}\n\n// -----------------------------------------------------------\n\nactual object Charsets {\n    actual val UTF_8: Charset = CharsetImpl(\"UTF-8\")\n    actual val ISO_8859_1: Charset = CharsetImpl(\"ISO-8859-1\")\n}\n\nprivate data class CharsetImpl(val name: String) : Charset(name) {\n    override fun newEncoder(): CharsetEncoder = CharsetEncoderImpl(this)\n    override fun newDecoder(): CharsetDecoder = CharsetDecoderImpl(this)\n}\n\n\nactual class MalformedInputException actual constructor(message: String) : Throwable(message)\n\n\nprivate fun CharsetDecoder.decodeExactBytesSlow(input: Input, inputLength: Int): String {\n    val decoder = TextDecoderFatal(charset.name, true)\n    var inputRemaining = inputLength\n    val sb = StringBuilder(inputLength)\n\n    decodeWrap {\n        input.takeWhileSize(6) { buffer ->\n            val chunkSize = buffer.readRemaining\n            val size = minOf(chunkSize, inputRemaining)\n            val text = when {\n                buffer.readPosition == 0 && buffer.content.byteLength == size -> decoder.decodeStream(buffer.content, true)\n                else -> decoder.decodeStream(Int8Array(buffer.content, buffer.readPosition, size), true)\n            }\n            sb.append(text)\n\n            buffer.discardExact(size)\n            inputRemaining -= size\n\n            if (inputRemaining > 0) 6 else 0\n        }\n\n        if (inputRemaining > 0) {\n            input.takeWhile { buffer ->\n                val chunkSize = buffer.readRemaining\n                val size = minOf(chunkSize, inputRemaining)\n                val text = when {\n                    buffer.readPosition == 0 && buffer.content.byteLength == size -> decoder.decode(buffer.content)\n                    else -> decoder.decodeStream(Int8Array(buffer.content, buffer.readPosition, size), true)\n                }\n                sb.append(text)\n                buffer.discardExact(size)\n                inputRemaining -= size\n                true\n            }\n        }\n\n        sb.append(decoder.decode())\n    }\n\n    return sb.toString()\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun String(chars: CharArray): String {\n    var result = \"\"\n    for (char in chars) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n *\n * @throws IndexOutOfBoundsException if either [offset] or [length] are less than zero\n * or `offset + length` is out of [chars] array bounds.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    if (offset < 0 || length < 0 || chars.size - offset < length)\n        throw IndexOutOfBoundsException(\"size: ${chars.size}; offset: $offset; length: $length\")\n    var result = \"\"\n    for (index in offset until offset + length) {\n        result += chars[index]\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] into a String.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun CharArray.concatToString(): String {\n    var result = \"\"\n    for (char in this) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] or its subrange into a String.\n *\n * @param startIndex the beginning (inclusive) of the subrange of characters, 0 by default.\n * @param endIndex the end (exclusive) of the subrange of characters, size of this array by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n@ExperimentalStdlibApi\npublic actual fun CharArray.concatToString(startIndex: Int = 0, endIndex: Int = this.size): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    var result = \"\"\n    for (index in startIndex until endIndex) {\n        result += this[index]\n    }\n    return result\n}\n\n/**\n * Returns a [CharArray] containing characters of this string.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun String.toCharArray(): CharArray {\n    return CharArray(length) { get(it) }\n}\n\n/**\n * Returns a [CharArray] containing characters of this string or its substring.\n *\n * @param startIndex the beginning (inclusive) of the substring, 0 by default.\n * @param endIndex the end (exclusive) of the substring, length of this string by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n@ExperimentalStdlibApi\npublic actual fun String.toCharArray(startIndex: Int = 0, endIndex: Int = this.length): CharArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return CharArray(endIndex - startIndex) { get(startIndex + it) }\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array.\n *\n * Malformed byte sequences are replaced by the replacement char `\\uFFFD`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun ByteArray.decodeToString(): String {\n    return decodeUtf8(this, 0, size, false)\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array or its subrange.\n *\n * @param startIndex the beginning (inclusive) of the subrange to decode, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to decode, size of this array by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char `\\uFFFD`.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if the byte array contains malformed UTF-8 byte sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n@ExperimentalStdlibApi\npublic actual fun ByteArray.decodeToString(\n    startIndex: Int = 0,\n    endIndex: Int = this.size,\n    throwOnInvalidSequence: Boolean = false\n): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    return decodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Encodes this string to an array of bytes in UTF-8 encoding.\n *\n * Any malformed char sequence is replaced by the replacement byte sequence.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun String.encodeToByteArray(): ByteArray {\n    return encodeUtf8(this, 0, length, false)\n}\n\n/**\n * Encodes this string or its substring to an array of bytes in UTF-8 encoding.\n *\n * @param startIndex the beginning (inclusive) of the substring to encode, 0 by default.\n * @param endIndex the end (exclusive) of the substring to encode, length of this string by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed char sequence or replace.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if this string contains malformed char sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n@ExperimentalStdlibApi\npublic actual fun String.encodeToByteArray(\n    startIndex: Int = 0,\n    endIndex: Int = this.length,\n    throwOnInvalidSequence: Boolean = false\n): ByteArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return encodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n *\n * @sample samples.text.Strings.toUpperCase\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n *\n * @sample samples.text.Strings.toLowerCase\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        var start = 0\n        while (true) {\n            val end = minOf(start + 16, min)\n            var s1 = this.substring(start, end)\n            var s2 = other.substring(start, end)\n            if (s1 != s2) {\n                s1 = s1.toUpperCase()\n                s2 = s2.toUpperCase()\n                if (s1 != s2) {\n                    s1 = s1.toLowerCase()\n                    s2 = s2.toLowerCase()\n                    if (s1 != s2) {\n                        return s1.compareTo(s2)\n                    }\n                }\n            }\n            if (end == min) break\n            start = end\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.contract\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n *\n * @sample samples.text.Strings.stringIsNullOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n *\n * @sample samples.text.Strings.stringIsEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n *\n * @sample samples.text.Strings.stringIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNotBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNullOrBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns this char sequence if it's not empty\n * or the result of calling [defaultValue] function if the char sequence is empty.\n *\n * @sample samples.text.Strings.stringIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Returns this char sequence if it is not empty and doesn't consist solely of whitespace characters,\n * or the result of calling [defaultValue] function otherwise.\n *\n * @sample samples.text.Strings.stringIfBlank\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isBlank()) defaultValue() else this\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.append(this, 0, startIndex)\n    sb.append(replacement)\n    sb.append(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.append(this, 0, startIndex)\n    sb.append(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonPrefixWith\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonSuffixWith\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(currentIndex: Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex ->\n        indexOfAny(delimiters, currentIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" } )\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex -> findAnyOf(delimitersList, currentIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n","package kotlinx.io.js\n\nimport kotlinx.io.charsets.*\nimport kotlinx.io.core.*\nimport org.khronos.webgl.*\n\n@Deprecated(\"Use readText with charset instead\", ReplaceWith(\"readText(Charset.forName(encoding), max)\", \"kotlinx.io.core.readText\", \"kotlinx.io.charsets.Charset\"), level = DeprecationLevel.ERROR)\nfun ByteReadPacket.readText(encoding: String, max: Int = Int.MAX_VALUE): String = readText(Charset.forName(encoding), max)\n\n@Deprecated(\"Use readText with charset instead\", ReplaceWith(\"readText(out, Charset.forName(encoding), max)\", \"kotlinx.io.core.readText\", \"kotlinx.io.charsets.Charset\"), level = DeprecationLevel.ERROR)\nfun ByteReadPacket.readText(encoding: String = \"UTF-8\", out: Appendable, max: Int = Int.MAX_VALUE): Int {\n    return readText(out, Charset.forName(encoding), max)\n}\n\ninternal external class TextDecoder(encoding: String, options: dynamic = definedExternally) {\n    val encoding: String\n\n    fun decode(): String\n    fun decode(buffer: ArrayBuffer): String\n    fun decode(buffer: ArrayBuffer, options: dynamic): String\n    fun decode(buffer: ArrayBufferView): String\n    fun decode(buffer: ArrayBufferView, options: dynamic): String\n}\n\nprivate val STREAM_TRUE = Any().apply {\n    with(this.asDynamic()) {\n        stream = true\n    }\n}\n\nprivate val FATAL_TRUE = Any().apply {\n    with(this.asDynamic()) {\n        fatal = true\n    }\n}\n\ninternal fun TextDecoderFatal(encoding: String, fatal: Boolean = true): TextDecoder {\n    // PhantomJS does not support TextDecoder yet so we use node module text-encoding for tests\n    if (js(\"typeof TextDecoder\") == \"undefined\") {\n        val module = js(\"require('text-encoding')\")\n        if (module.TextDecoder === undefined) throw IllegalStateException(\"TextDecoder is not supported by your browser and no text-encoding module found\")\n        val ctor = module.TextDecoder\n        val objPrototype = js(\"Object\").create(ctor.prototype)\n\n        @Suppress(\"UnsafeCastFromDynamic\")\n        return if (fatal) ctor.call(objPrototype, encoding, FATAL_TRUE)\n        else ctor.call(objPrototype, encoding)\n    }\n\n    return if (fatal) TextDecoder(encoding, FATAL_TRUE) else TextDecoder(encoding)\n}\n\ninternal inline fun TextDecoder.decodeStream(buffer: ArrayBufferView, stream: Boolean): String {\n    decodeWrap {\n        return if (stream) {\n            decode(buffer, STREAM_TRUE)\n        } else {\n            decode(buffer)\n        }\n    }\n}\n\ninternal inline fun TextDecoder.decodeStream(buffer: ArrayBuffer, stream: Boolean): String {\n    decodeWrap {\n        return if (stream) {\n            decode(buffer, STREAM_TRUE)\n        } else {\n            decode(buffer)\n        }\n    }\n}\n\ninternal inline fun <R> decodeWrap(block: () -> R): R {\n    try {\n        return block()\n    } catch (t: Throwable) {\n        throw MalformedInputException(\"Failed to decode bytes: ${t.message ?: \"no cause provided\"}\")\n    }\n}\n","package kotlinx.io.charsets\n\nimport kotlinx.io.core.*\nimport org.khronos.webgl.*\n\ninternal fun encodeISO88591(input: CharSequence, fromIndex: Int, toIndex: Int, dst: IoBuffer): Int {\n    if (fromIndex >= toIndex) return 0\n\n    dst.writeDirect { view ->\n        val i8 = Int8Array(view.buffer, view.byteOffset, view.byteLength)\n        var writeIndex = 0\n        for (index in fromIndex until toIndex) {\n            val character = input[index].toInt()\n            if (character > 0xff) {\n                failedToMapError(character)\n            }\n            i8[writeIndex++] = character.toByte()\n        }\n        writeIndex\n    }\n    return toIndex - fromIndex\n}\n\nprivate fun failedToMapError(ch: Int): Nothing {\n    throw MalformedInputException(\"The character with unicode point $ch couldn't be mapped to ISO-8859-1 character\" )\n}\n","@file:Suppress(\"ReplaceRangeToWithUntil\", \"RedundantModalityModifier\")\n\npackage kotlinx.io.core\n\nimport kotlinx.io.core.internal.*\nimport kotlinx.io.js.*\nimport kotlinx.io.pool.*\nimport org.khronos.webgl.*\n\nactual class IoBuffer internal constructor(\n        internal var content: ArrayBuffer,\n        internal actual val origin: IoBuffer?\n) : Input, Output {\n    @Deprecated(\n        \"Suppress warning.\",\n        level = DeprecationLevel.HIDDEN\n    )\n    @Suppress(\"unused\")\n    actual final override val doNotImplementInputButExtendAbstractInputInstead: Nothing\n        get() = error(\"Should be never accessed.\")\n\n    @Deprecated(\n        \"Suppress warning.\",\n        level = DeprecationLevel.HIDDEN\n    )\n    @Suppress(\"unused\")\n    actual final override val doNotImplementOutputButExtendAbstractOutputInstead: Nothing\n        get() = error(\"Should be never accessed.\")\n\n    private var refCount = 1\n\n    internal var readPosition = 0\n    internal var writePosition = 0\n    private var limit = content.byteLength\n\n    private var view = if (content === EmptyBuffer) EmptyDataView else DataView(content)\n    private var i8 = if (content === EmptyBuffer) Empty8 else Int8Array(content, 0, limit)\n    private var i16 = if (content === EmptyBuffer) Empty16 else Int16Array(content, 0, limit / 2)\n    private var i32 = if (content === EmptyBuffer) Empty32 else Int32Array(content, 0, limit / 4)\n    private var f32 = if (content === EmptyBuffer) EmptyF32 else Float32Array(content, 0, limit / 4)\n    private var f64 = if (content === EmptyBuffer) EmptyF64 else Float64Array(content, 0, limit / 8)\n\n    private var littleEndian = false\n    private var platformEndian = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN\n\n    init {\n        require(origin !== this) { \"origin shouldn't point to itself\" }\n    }\n\n    @ExperimentalIoApi\n    actual var attachment: Any? = null\n\n    actual var next: IoBuffer? = null\n\n    override val endOfInput: Boolean get() = writePosition == readPosition\n\n    /**\n     * Backing buffer capacity. Value for released buffer is unspecified\n     */\n    actual val capacity: Int get() = content.byteLength\n    actual val readRemaining get() = writePosition - readPosition\n    actual val writeRemaining get() = limit - writePosition\n\n    actual fun canRead() = writePosition > readPosition\n    actual fun canWrite() = writePosition < limit\n\n    actual fun reserveStartGap(n: Int) {\n        if (readPosition > 0) throw IllegalStateException(\"Start gap is already reserved\")\n        if (writePosition > 0) throw IllegalStateException(\"Start gap is already reserved\")\n        writePosition = n\n        readPosition = n\n    }\n\n    actual fun reserveEndGap(n: Int) {\n        if (limit != content.byteLength) throw IllegalStateException(\"End gap is already reserved\")\n        limit -= n\n    }\n\n    actual val startGap: Int get() = readPosition\n    actual val endGap: Int get() = content.byteLength - limit\n\n    @Deprecated(\"Read/write with readXXXLittleEndian/writeXXXLittleEndian or \" +\n        \"do readXXX/writeXXX with X.reverseByteOrder() instead.\")\n    actual final override var byteOrder: ByteOrder\n        get() = if (littleEndian) ByteOrder.LITTLE_ENDIAN else  ByteOrder.BIG_ENDIAN\n        set(value) {\n            littleEndian = when (value) {\n                ByteOrder.BIG_ENDIAN -> false\n                ByteOrder.LITTLE_ENDIAN -> true\n            }\n            platformEndian = value === ByteOrder.nativeOrder()\n        }\n\n    actual final override fun readByte(): Byte {\n        if (readRemaining < 0) throw IllegalStateException(\"No bytes available for read\")\n        val value = i8[readPosition]\n        readPosition++\n        return value\n    }\n\n    actual final override fun writeByte(v: Byte) {\n        if (writeRemaining < 1) throw IllegalStateException(\"No space left for writing\")\n        i8[writePosition] = v\n        writePosition++\n    }\n\n    actual final override fun readShort(): Short {\n        if (readRemaining < 2) throw IllegalStateException(\"Not enough bytes available to read a short\")\n        val value = view.getInt16(readPosition, littleEndian)\n        readPosition += 2\n        return value\n    }\n\n    actual final override fun writeShort(v: Short) {\n        if (writeRemaining < 2) throw IllegalStateException(\"Not enough space left to write a short\")\n        view.setInt16(writePosition, v, littleEndian)\n        writePosition += 2\n    }\n\n    actual final override fun readInt(): Int {\n        if (readRemaining < 4) throw IllegalStateException(\"Not enough bytes available to read an int\")\n        return readIntUnsafe()\n    }\n\n    private fun readIntUnsafe(): Int {\n        val value = view.getInt32(readPosition, littleEndian)\n        readPosition += 4\n        return value\n    }\n\n    actual final override fun writeInt(v: Int) {\n        if (writeRemaining < 4) throw IllegalStateException(\"Not enough space left to write an int\")\n        view.setInt32(writePosition, v, littleEndian)\n        writePosition += 4\n    }\n\n    actual final override fun readFloat(): Float {\n        if (readRemaining < 4) throw IllegalStateException(\"Not enough bytes available to read a float\")\n        val value = view.getFloat32(readPosition, littleEndian)\n        readPosition += 4\n        return value\n    }\n\n    actual final override fun writeFloat(v: Float) {\n        if (writeRemaining < 4) throw IllegalStateException(\"Not enough space left to write a float\")\n        view.setFloat32(writePosition, v, littleEndian)\n        writePosition += 4\n    }\n\n    actual final override fun readDouble(): Double {\n        if (readRemaining < 8) throw IllegalStateException(\"Not enough bytes available to read a double\")\n        val value = view.getFloat64(readPosition, littleEndian)\n        readPosition += 8\n        return value\n    }\n\n    actual final override fun writeDouble(v: Double) {\n        if (writeRemaining < 8) throw IllegalStateException(\"Not enough space left to write a double\")\n        view.setFloat64(writePosition, v, littleEndian)\n        writePosition += 8\n    }\n\n    actual final override fun writeFully(src: ByteArray, offset: Int, length: Int) {\n        if (writeRemaining < length) throw IllegalStateException(\"Not enough space left ($writeRemaining) to write $length bytes\")\n        val wp = writePosition\n        val i8 = i8\n\n        for (idx in 0 .. length - 1) {\n            i8[wp + idx] = src[offset + idx]\n        }\n\n        writePosition = wp + length\n    }\n\n    actual final override fun writeFully(src: ShortArray, offset: Int, length: Int) {\n        if (writeRemaining < length * 2) throw IllegalStateException(\"Not enough space left to write a short array of length $length\")\n        var wp = writePosition\n        val platformEndian = platformEndian\n\n        if (platformEndian && wp and 1 == 0) {\n            val array = i16\n            var j = wp / 2\n\n            for (i in offset .. offset + length - 1) {\n                array[j++] = src[i]\n            }\n\n            writePosition = wp + length * 2\n        }\n        else if (platformEndian) {\n            val array = Int16Array(content, wp)\n            for (i in offset .. offset + length - 1) {\n                array[i - offset] = src[i]\n            }\n            writePosition = wp + length * 2\n        } else {\n            val littleEndian = littleEndian\n            val view = view\n\n            for (i in offset .. offset + length - 1) {\n                view.setInt16(wp, src[i], littleEndian)\n                wp += 2\n            }\n\n            writePosition = wp\n        }\n    }\n\n    actual final override fun writeFully(src: IntArray, offset: Int, length: Int) {\n        if (writeRemaining < length * 4) throw IllegalStateException(\"Not enough space left to write an int array of length $length\")\n        var wp = writePosition\n        val platformEndian = platformEndian\n\n        if (platformEndian && wp and 3 == 0) {\n            val array = i32\n            var j = wp / 4\n\n            for (i in offset .. offset + length - 1) {\n                array[j++] = src[i]\n            }\n\n            writePosition = wp + length * 4\n        }\n        else if (platformEndian) {\n            val array = Int32Array(content, wp)\n            for (i in offset .. offset + length - 1) {\n                array[i - offset] = src[i]\n            }\n            writePosition = wp + length * 4\n        } else {\n            val littleEndian = littleEndian\n            val view = view\n\n            for (i in offset..offset + length - 1) {\n                view.setInt32(wp, src[i], littleEndian)\n                wp += 4\n            }\n\n            writePosition = wp\n        }\n    }\n\n    actual final override fun writeFully(src: LongArray, offset: Int, length: Int) {\n        if (writeRemaining < length * 8) throw IllegalStateException(\"Not enough space left to write a long array of length $length\")\n\n        for (i in offset .. offset + length - 1) {\n            writeLong(src[i])\n        }\n    }\n\n    actual final override fun writeFully(src: FloatArray, offset: Int, length: Int) {\n        if (writeRemaining < length * 4) throw IllegalStateException(\"Not enough space left to write a float array of length $length\")\n        var wp = writePosition\n        val platformEndian = platformEndian\n\n        if (platformEndian && wp and 3 == 0) {\n            val array = f32\n            var j = wp / 4\n\n            for (i in offset .. offset + length - 1) {\n                array[j++] = src[i]\n            }\n\n            writePosition = wp + length * 4\n        }\n        else if (platformEndian) {\n            val array = Float32Array(content, wp)\n            for (i in offset .. offset + length - 1) {\n                array[i - offset] = src[i]\n            }\n            writePosition = wp + length * 4\n        } else {\n            val littleEndian = littleEndian\n            val view = view\n\n            for (i in offset..offset + length - 1) {\n                view.setFloat32(wp, src[i], littleEndian)\n                wp += 4\n            }\n\n            writePosition = wp\n        }\n    }\n\n    actual final override fun writeFully(src: DoubleArray, offset: Int, length: Int) {\n        if (writeRemaining < length * 8) throw IllegalStateException(\"Not enough space left to write a double array of length $length\")\n        var wp = writePosition\n        val platformEndian = platformEndian\n\n        if (platformEndian && wp and 7 == 0) {\n            val array = f64\n            var j = wp / 8\n\n            for (i in offset .. offset + length - 1) {\n                array[j++] = src[i]\n            }\n\n            writePosition = wp + length * 8\n        }\n        else if (platformEndian) {\n            val array = Float64Array(content, wp)\n            for (i in offset .. offset + length - 1) {\n                array[i - offset] = src[i]\n            }\n            writePosition = wp + length * 8\n        } else {\n            val littleEndian = littleEndian\n            val view = view\n\n            for (i in offset..offset + length - 1) {\n                view.setFloat64(wp, src[i], littleEndian)\n                wp += 8\n            }\n\n            writePosition = wp\n        }\n    }\n\n    actual final override fun writeFully(src: IoBuffer, length: Int) {\n        require(length <= src.readRemaining) { \"length is too large: not enough bytes to read $length > ${src.readRemaining}\"}\n        require(length <= writeRemaining) { \"length is too large: not enough room to write $length > $writeRemaining\" }\n\n        val otherEnd = src.readPosition + length\n        val sub = src.i8.subarray(src.readPosition, otherEnd)\n        i8.set(sub, writePosition)\n        src.readPosition = otherEnd\n        writePosition += length\n    }\n\n    actual final override fun fill(n: Long, v: Byte) {\n        if (writeRemaining.toLong() < n) throw IllegalStateException(\"Not enough space to fill with $n values\")\n\n        val wp = writePosition\n        repeat(n.toInt()) {\n            i8[wp + it] = v\n        }\n\n        writePosition += n.toInt()\n    }\n\n    @Deprecated(\"Use readFully instead\", ReplaceWith(\"readFully(dst, offset, length)\"), level = DeprecationLevel.ERROR)\n    actual fun read(dst: ByteArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    actual final override fun readFully(dst: ByteArray, offset: Int, length: Int) {\n        if (readRemaining < length) throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length bytes\")\n        val rp = readPosition\n        val i8 = i8\n\n        for (idx in 0 .. length - 1) {\n            dst[offset + idx] = i8[rp + idx]\n        }\n\n        readPosition += length\n    }\n\n    actual final override fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int {\n        val readRemaining = readRemaining\n        if (readRemaining == 0) return -1\n        val size = minOf(readRemaining, length)\n        readFully(dst, offset, size)\n        return size\n    }\n\n    actual final override fun readFully(dst: ShortArray, offset: Int, length: Int) {\n        if (readRemaining < length * 2) throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length short integers\")\n        var rp = readPosition\n        val platformEndian = platformEndian\n\n        if (platformEndian && rp and 1 == 0) {\n            val array = i16\n            var j = rp / 2\n\n            for (i in offset..offset + length - 1) {\n                dst[i] = array[j++]\n            }\n\n            readPosition = rp + length * 2\n        } else if (platformEndian) {\n            val array = Int16Array(content, rp)\n            var j = 0\n\n            for (i in offset..offset + length - 1) {\n                dst[i] = array[j++]\n            }\n\n            readPosition = rp + length * 2\n        } else {\n            val littleEndian = littleEndian\n            val view = view\n            for (idx in offset..offset + length - 1) {\n                dst[idx] = view.getInt16(rp, littleEndian)\n                rp += 2\n            }\n\n            readPosition = rp\n        }\n    }\n\n    actual final override fun readAvailable(dst: ShortArray, offset: Int, length: Int): Int {\n        val readRemaining = readRemaining\n        if (readRemaining == 0) return -1\n        val size = minOf(readRemaining, length)\n        readFully(dst, offset, size)\n        return size\n    }\n\n    actual final override fun readFully(dst: IntArray, offset: Int, length: Int) {\n        if (readRemaining < length * 4) throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length integers\")\n        var rp = readPosition\n        val platformEndian = platformEndian\n\n        if (platformEndian && rp and 3 == 0) {\n            val array = i32\n            var j = rp / 4\n\n            for (i in offset..offset + length - 1) {\n                dst[i] = array[j++]\n            }\n\n            readPosition = rp + length * 4\n        } else if (platformEndian) {\n            val array = Int32Array(content, rp)\n            var j = 0\n\n            for (i in offset..offset + length - 1) {\n                dst[i] = array[j++]\n            }\n\n            readPosition = rp + length * 4\n        } else {\n            val littleEndian = littleEndian\n            val view = view\n\n            for (idx in offset..offset + length - 1) {\n                dst[idx] = view.getInt32(rp, littleEndian)\n                rp += 4\n            }\n\n            readPosition = rp\n        }\n    }\n\n    actual final override fun readAvailable(dst: IntArray, offset: Int, length: Int): Int {\n        val readRemaining = readRemaining\n        if (readRemaining == 0) return -1\n        val size = minOf(readRemaining, length)\n        readFully(dst, offset, size)\n        return size\n    }\n\n    actual final override fun readFully(dst: LongArray, offset: Int, length: Int) {\n        if (readRemaining < length * 8) throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length long integers\")\n\n        for (idx in offset .. offset + length - 1) {\n            dst[idx] = readLongUnsafe()\n        }\n    }\n\n    actual final override fun readAvailable(dst: LongArray, offset: Int, length: Int): Int {\n        val readRemaining = readRemaining\n        if (readRemaining == 0) return -1\n        val size = minOf(readRemaining, length)\n        readFully(dst, offset, size)\n        return size\n    }\n\n    actual final override fun readFully(dst: FloatArray, offset: Int, length: Int) {\n        if (readRemaining < length * 4) throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length float numbers\")\n        var rp = readPosition\n        val platformEndian = platformEndian\n\n        if (platformEndian && rp and 3 == 0) {\n            val array = f32\n            var j = rp / 4\n\n            for (i in offset..offset + length - 1) {\n                dst[i] = array[j++]\n            }\n\n            readPosition = rp + length * 4\n        } else if (platformEndian) {\n            val array = Float32Array(content, rp)\n            var j = 0\n\n            for (i in offset..offset + length - 1) {\n                dst[i] = array[j++]\n            }\n\n            readPosition = rp + length * 4\n        } else {\n            val littleEndian = littleEndian\n            val view = view\n\n            for (idx in offset..offset + length - 1) {\n                dst[idx] = view.getFloat32(rp, littleEndian)\n                rp += 4\n            }\n\n            readPosition = rp\n        }\n    }\n\n    actual final override fun readAvailable(dst: FloatArray, offset: Int, length: Int): Int {\n        val readRemaining = readRemaining\n        if (readRemaining == 0) return -1\n        val size = minOf(readRemaining, length)\n        readFully(dst, offset, size)\n        return size\n    }\n\n    actual final override fun readFully(dst: DoubleArray, offset: Int, length: Int) {\n        if (readRemaining < length * 8) throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length double float numbers\")\n        var rp = readPosition\n        val platformEndian = platformEndian\n\n        if (platformEndian && rp and 7 == 0) {\n            val array = f64\n            var j = rp / 8\n\n            for (i in offset..offset + length - 1) {\n                dst[i] = array[j++]\n            }\n\n            readPosition = rp + length * 8\n        } else if (platformEndian) {\n            val array = Float64Array(content, rp)\n            var j = 0\n\n            for (i in offset..offset + length - 1) {\n                dst[i] = array[j++]\n            }\n\n            readPosition = rp + length * 8\n        } else {\n            val littleEndian = littleEndian\n            val view = view\n\n            for (idx in offset..offset + length - 1) {\n                dst[idx] = view.getFloat64(rp, littleEndian)\n                rp += 8\n            }\n\n            readPosition = rp\n        }\n    }\n\n    actual final override fun readAvailable(dst: DoubleArray, offset: Int, length: Int): Int {\n        val readRemaining = readRemaining\n        if (readRemaining == 0) return -1\n        val size = minOf(readRemaining, length)\n        readFully(dst, offset, length)\n        return size\n    }\n\n    @Deprecated(\"Use readFully instead\", ReplaceWith(\"readFully(dst, offset, length)\"), level = DeprecationLevel.ERROR)\n    fun read(dst: Array<Byte>, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    fun readFully(dst: Array<Byte>, offset: Int, length: Int) {\n        if (readRemaining < length) throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length bytes\")\n        val rp = readPosition\n        val i8 = i8\n\n        for (idx in 0 .. length - 1) {\n            dst[offset + idx] = i8[rp + idx]\n        }\n\n        readPosition += length\n    }\n\n    @Deprecated(\"Use readFully instead\", ReplaceWith(\"readFully(dst, offset, length)\"), level = DeprecationLevel.ERROR)\n    fun read(dst: ArrayBuffer, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    final override fun readFully(dst: ArrayBuffer, offset: Int, length: Int) {\n        if (readRemaining < length) throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length bytes\")\n        val to = Int8Array(dst, offset, length)\n\n        val rp = readPosition\n        val rem = writePosition - rp\n        val i8 = i8\n\n        if (rp == 0 && length == rem) {\n            to.set(i8, offset)\n        } else if (length < 100) {\n            for (i in 0 .. length - 1) {\n                to[offset + i] = i8[rp + i]\n            }\n        } else {\n            val from = Int8Array(content, rp, length)\n            to.set(from)\n        }\n\n        readPosition = rp + length\n    }\n\n    override fun readAvailable(dst: ArrayBuffer, offset: Int, length: Int): Int {\n        val readRemaining = readRemaining\n        if (readRemaining == 0) return -1\n        val size = minOf(readRemaining, length)\n        readFully(dst, offset, size)\n        return size\n    }\n\n    actual final override fun readAvailable(dst: IoBuffer, length: Int): Int {\n        val readRemaining = readRemaining\n        if (readRemaining == 0) return -1\n        val size = minOf(dst.writeRemaining, readRemaining, length)\n        readFully(dst, size)\n        return size\n    }\n\n    override fun readFully(dst: ArrayBufferView, offset: Int, length: Int) {\n        if (readRemaining < length) throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length bytes\")\n        if (length > dst.byteLength) throw IllegalArgumentException(\"Destination buffer overflow: length = $length, buffer capacity ${dst.byteLength}\")\n        require(offset >= 0) { \"offset should be positive\" }\n        require(offset + length <= dst.byteLength) { throw IndexOutOfBoundsException(\"\") }\n\n        readFully(dst.buffer, dst.byteOffset + offset, length)\n    }\n\n    override fun readAvailable(dst: ArrayBufferView, offset: Int, length: Int): Int {\n        val readRemaining = readRemaining\n        if (readRemaining == 0) return -1\n        val size = minOf(length, readRemaining)\n        readFully(dst, offset, size)\n        return size\n    }\n\n    @Deprecated(\"Use readFully instead\", ReplaceWith(\"readFully(dst, offset, length)\"), level = DeprecationLevel.ERROR)\n    fun read(dst: Int8Array, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    override fun readFully(dst: Int8Array, offset: Int, length: Int) {\n        if (readRemaining < length) throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length bytes\")\n        val rp = readPosition\n        val rem = writePosition - rp\n        val i8 = i8\n\n        if (rp == 0 && rem == length) {\n            dst.set(i8, offset)\n        } else if (length < 100) {\n            for (i in 0 .. length - 1) {\n                dst[offset + i] = i8[rp + i]\n            }\n        } else {\n            val from = Int8Array(content, rp, length)\n            dst.set(from, offset)\n        }\n\n        readPosition = rp + length\n    }\n\n    override fun readAvailable(dst: Int8Array, offset: Int, length: Int): Int {\n        val readRemaining = readRemaining\n        if (readRemaining == 0) return -1\n        val size = minOf(readRemaining, length)\n        readFully(dst, offset, size)\n        return size\n    }\n\n    actual final override fun readFully(dst: IoBuffer, length: Int) {\n        if (readRemaining < length) throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length bytes\")\n        if (dst.writeRemaining < length) throw IllegalArgumentException(\"Not enough free space in dst buffer to write $length bytes\")\n\n        val srcBuffer = if (i8.length == length) i8 else Int8Array(content, readPosition, length)\n        dst.i8.set(srcBuffer, dst.writePosition)\n\n        dst.writePosition += length\n        readPosition += length\n    }\n\n    actual final override fun append(csq: CharSequence?, start: Int, end: Int): Appendable {\n        val idx = appendChars(csq ?: \"null\", start, end)\n        if (idx != end) throw IllegalStateException(\"Not enough free space to append char sequence\")\n        return this\n    }\n\n    actual final override fun append(csq: CharSequence?): Appendable {\n        return if (csq == null) append(\"null\") else append(csq, 0, csq.length)\n    }\n\n    actual final override fun append(csq: CharArray, start: Int, end: Int): Appendable {\n        val idx = appendChars(csq, start, end)\n\n        if (idx != end) throw IllegalStateException(\"Not enough free space to append char sequence\")\n        return this\n    }\n\n    actual override fun append(c: Char): Appendable {\n        val wp = writePosition\n        val s = i8.putUtf8Char(c.toInt(), limit - wp, wp)\n        if (s == 0) notEnoughFreeSpace(c)\n        writePosition = wp + s\n        return this\n    }\n\n    private fun notEnoughFreeSpace(c: Char): Nothing {\n        throw IllegalStateException(\"Not Enough free space to append character '$c', remaining $writeRemaining bytes\")\n    }\n\n    actual fun appendChars(csq: CharArray, start: Int, end: Int): Int {\n        val i8 = i8\n        var wp = writePosition\n        val l = limit\n        var rc = end\n\n        for (idx in start until end) {\n            val ch = csq[idx].toInt()\n            if (ch > 0x7f || wp >= l) {\n                rc = idx\n                break\n            }\n\n            i8[wp++] = ch.toByte()\n        }\n\n        if (rc >= end || wp == l) {\n            writePosition = wp\n            return rc\n        }\n\n        return appendCharsUtf8(csq, rc, end, wp)\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    private inline fun Int.isSurrogateCodePoint() = this in 55296..57343\n\n    private fun appendCharsUtf8(csq: CharArray, start: Int, end: Int, wp0: Int): Int {\n        val i8 = i8\n        val l = limit\n        var wp = wp0\n        var idx = start\n\n        while (idx < end) {\n            val ch = csq[idx++].toInt()\n\n            val size = if (ch.isSurrogateCodePoint()) i8.putUtf8CharSurrogate(ch, csq[idx++].toInt(), l - wp, wp)\n            else i8.putUtf8Char(ch, l - wp, wp)\n\n            if (size == 0) {\n                return appendCharFailed(ch, idx, wp)\n            }\n\n            wp += size\n        }\n\n        writePosition = wp\n        return end\n    }\n\n    actual fun appendChars(csq: CharSequence, start: Int, end: Int): Int {\n        val i8 = i8\n        var wp = writePosition\n        val l = limit\n        var rc = end\n\n        for (idx in start until end) {\n            val ch = csq[idx].toInt()\n            if (ch > 0x7f || wp >= l) {\n                rc = idx\n                break\n            }\n\n            i8[wp++] = ch.toByte()\n        }\n\n        if (rc >= end || wp == limit) {\n            writePosition = wp\n            return rc\n        }\n\n        return appendCharsUtf8(csq, rc, end, wp)\n    }\n\n    private fun appendCharsUtf8(csq: CharSequence, start: Int, end: Int, wp0: Int): Int {\n        val i8 = i8\n        val l = limit\n        var wp = wp0\n        var idx = start\n\n        while (idx < end) {\n            val ch = csq[idx++].toInt()\n            val remaining = l - wp\n            val size = if (ch.isSurrogateCodePoint()) i8.putUtf8CharSurrogate(ch, csq[idx++].toInt(), remaining, wp)\n                else i8.putUtf8Char(ch, remaining, wp)\n\n            if (size == 0) {\n                return appendCharFailed(ch, idx, wp)\n            }\n\n            wp += size\n        }\n\n        writePosition = wp\n        return end\n    }\n\n    private fun appendCharFailed(ch: Int, idx: Int, wp: Int): Int {\n        writePosition = wp\n        return if (ch.isSurrogateCodePoint()) idx - 2 else idx - 1\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    private inline fun Int8Array.putUtf8Char(v: Int, remaining: Int, wp: Int): Int {\n        return when {\n            v in 1..0x7f -> {\n                if (remaining < 1) return 0\n                this[wp] = v.toByte()\n                1\n            }\n            v > 0xffff -> {\n                if (remaining < 4) return 0\n                this[wp    ] = (0xf0 or ((v shr 18) and 0x3f)).toByte()\n                this[wp + 1] = (0x80 or ((v shr 12) and 0x3f)).toByte()\n                this[wp + 2] = (0x80 or ((v shr  6) and 0x3f)).toByte()\n                this[wp + 3] = (0x80 or ( v         and 0x3f)).toByte()\n                4\n            }\n            v > 0x7ff -> {\n                if (remaining < 3) return 0\n                this[wp    ] = (0xe0 or ((v shr 12) and 0x0f)).toByte()\n                this[wp + 1] = (0x80 or ((v shr  6) and 0x3f)).toByte()\n                this[wp + 2] = (0x80 or ( v         and 0x3f)).toByte()\n                3\n            }\n            else -> {\n                if (remaining < 2) return 0\n                this[wp    ] = (0xc0 or ((v shr  6) and 0x1f)).toByte()\n                this[wp + 1] = (0x80 or ( v         and 0x3f)).toByte()\n                2\n            }\n        }\n    }\n\n    private fun Int8Array.putUtf8CharSurrogate(high: Int, low: Int, remaining: Int, wp: Int): Int {\n        val highValue = (high and 0x7ff) shl 10\n        val lowValue = (low and 0x3ff)\n        val value = 0x010000 or (highValue or lowValue)\n\n        return putUtf8Char(value, remaining, wp)\n    }\n\n    actual final override fun tryPeek(): Int {\n        val readPosition = readPosition\n        val writePosition = writePosition\n        if (readPosition == writePosition) return -1\n\n        return i8[readPosition].toInt() and 0xff\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    actual final override fun peekTo(buffer: IoBuffer): Int {\n        return peekTo(buffer)\n    }\n\n    @Deprecated(\"Use discardExact instead.\")\n    actual final override fun discard(n: Long): Long {\n        val size = minOf(readRemaining.toLong(), n).toInt()\n        readPosition += size\n        return size.toLong()\n    }\n\n    @Deprecated(\"Use writeFully instead\", level = DeprecationLevel.ERROR)\n    actual fun write(array: ByteArray, offset: Int, length: Int) {\n        writeFully(array, offset, length)\n    }\n\n    fun writeFully(src: ArrayBufferView, offset: Int, length: Int) {\n        if (writeRemaining < length) throw IllegalStateException(\"Not enough space left ($writeRemaining) to write $length bytes\")\n        val wp = writePosition\n        val rem = limit - wp\n        val i8 = i8\n\n        if (length > rem) throw IndexOutOfBoundsException()\n\n        val from = Int8Array(src.buffer, src.byteOffset + offset, length)\n        i8.set(from, wp)\n\n        writePosition = wp + length\n    }\n\n    fun write(src: Int8Array, offset: Int, length: Int) {\n        if (writeRemaining < length) throw IllegalStateException(\"Not enough space left ($writeRemaining) to write $length bytes\")\n        val wp = writePosition\n        val rem = limit - wp\n        val i8 = i8\n\n        if (length > rem) throw IndexOutOfBoundsException()\n        if (offset == 0 && length == src.length) {\n            i8.set(src, wp)\n        } else if (length < 100) {\n            for (i in 0 .. length - 1) {\n                i8[wp + i] = src[offset + i]\n            }\n        } else {\n            val from = Int8Array(src.buffer, src.byteOffset + offset, length)\n            i8.set(from, wp)\n        }\n\n        writePosition = wp + length\n    }\n\n    actual final override fun readLong(): Long {\n        if (readRemaining < 8) throw IllegalStateException(\"Not enough bytes available to read a long\")\n        return readLongUnsafe()\n    }\n\n    private fun readLongUnsafe(): Long {\n        val m = 0xffffffff\n        val a = readIntUnsafe().toLong() and m\n        val b = readIntUnsafe().toLong() and m\n\n        return if (littleEndian) {\n            (b shl 32) or a\n        } else {\n            (a shl 32) or b\n        }\n    }\n\n    actual final override fun writeLong(v: Long) {\n        if (writeRemaining < 8) throw IllegalStateException(\"Not enough space left to write a long\")\n        val m = 0xffffffff\n        val a = (v shr 32).toInt()\n        val b = (v and m).toInt()\n\n        if (littleEndian) {\n            writeInt(b)\n            writeInt(a)\n        } else {\n            writeInt(a)\n            writeInt(b)\n        }\n    }\n\n    actual fun discardExact(n: Int) {\n        require(n >= 0) { \"Number of bytes to be discarded shouldn't be negative: $n\" }\n\n        val rem = readRemaining\n        if (n > rem) {\n            throw IllegalArgumentException(\"Can't discard $n bytes: only $rem bytes available\")\n        }\n\n        readPosition += n\n    }\n\n    actual fun pushBack(n: Int) {\n        if (readPosition < n) throw IllegalStateException(\"Nothing to push back\")\n        readPosition -= n\n    }\n\n    actual fun resetForWrite() {\n        resetForWrite(content.byteLength)\n    }\n\n    actual fun resetForWrite(limit: Int) {\n        require(limit >= 0) { \"Limit shouldn't be negative: $limit\" }\n        require(limit <= content.byteLength) { \"Limit shouldn't be bigger than buffer size: limit = $limit, size = ${content.byteLength}\"}\n\n        readPosition = 0\n        writePosition = 0\n        this.limit = limit\n    }\n\n    actual fun resetForRead() {\n        readPosition = 0\n        limit = content.byteLength\n        writePosition = limit\n    }\n\n    actual fun isExclusivelyOwned(): Boolean = refCount == 1\n\n    actual fun makeView(): IoBuffer {\n        if (this === Empty) return this\n\n        val o = origin ?: this\n        o.acquire()\n\n        val view = IoBuffer(content, o)\n        view.attachment = attachment\n        view.readPosition = readPosition\n        view.writePosition = writePosition\n        view.limit = limit\n\n        return view\n    }\n\n    actual fun release(pool: ObjectPool<IoBuffer>) {\n        if (release()) {\n            resetForWrite()\n\n            if (origin != null) {\n                unlink()\n                origin.release(pool)\n            } else {\n                pool.recycle(this)\n            }\n        }\n    }\n\n    @Deprecated(\"Use writeFully instead\", ReplaceWith(\"writeFully(src, length)\"), level = DeprecationLevel.ERROR)\n    actual fun writeBuffer(src: IoBuffer, length: Int): Int {\n        writeFully(src, length)\n        return length\n    }\n\n    actual final override fun flush() {\n    }\n\n    internal fun readText(decoder: TextDecoder, out: Appendable, lastBuffer: Boolean, max: Int = Int.MAX_VALUE): Int {\n        require(max >= 0) { \"max shouldn't be negative: $max\" }\n\n        if (readRemaining == 0) return 0\n\n        val rawResult = decoder.decodeStream(i8.subarray(readPosition, writePosition), !lastBuffer)\n        val result = if (rawResult.length <= max) {\n            readPosition = writePosition\n            rawResult\n        } else {\n            val actual = rawResult.substring(0, max)\n\n            // as js's text decoder is too stupid, let's guess new readPosition\n            val subDecoder = TextDecoderFatal(decoder.encoding, true)\n            val subArray = Int8Array(1)\n            var subDecoded = 0\n\n            for (i in readPosition until writePosition) {\n                subArray[0] = i8[i]\n                subDecoded += subDecoder.decodeStream(subArray, true).length\n\n                if (subDecoded >= max) {\n                    readPosition = i + 1\n                    break\n                }\n            }\n\n            if (subDecoded < max) {\n                subDecoded += decodeWrap { subDecoder.decode().length }\n\n                if (subDecoded >= max) {\n                    readPosition = writePosition\n                } else {\n                    throw IllegalStateException(\"Failed to readText: don't know how to update read position\")\n                }\n            }\n\n            actual\n        }\n\n        out.append(result)\n\n        return result.length\n    }\n\n    @PublishedApi\n    internal fun readableView(): DataView {\n        val readPosition = readPosition\n        val writePosition = writePosition\n\n        return when {\n            readPosition == writePosition -> EmptyDataView\n            readPosition == 0 && writePosition == content.byteLength -> view\n            else -> DataView(content, readPosition, writePosition - readPosition)\n        }\n    }\n\n    @PublishedApi\n    internal fun writableView(): DataView {\n        val writePosition = writePosition\n        val limit = limit\n\n        return when {\n            writePosition == limit -> EmptyDataView\n            writePosition == 0 && limit == content.byteLength -> view\n            else -> DataView(content, writePosition, limit - writePosition)\n        }\n    }\n\n    @PublishedApi\n    internal fun commitWritten(n: Int) {\n        writePosition += n\n    }\n\n    /**\n     * Apply [block] function on a [DataView] of readable bytes.\n     * The [block] function should return number of consumed bytes.\n     * @return number of bytes consumed\n     */\n    @ExperimentalIoApi\n    inline fun readDirect(block: (DataView) -> Int): Int {\n        val view = readableView()\n        val rc = block(view)\n        check(rc >= 0) { \"The returned value from block function shouldn't be negative: $rc\" }\n        discardExact(rc)\n        return rc\n    }\n\n    /**\n     * Apply [block] function on a [DataView] of the free space.\n     * The [block] function should return number of written bytes.\n     * @return number of bytes written\n     */\n    @ExperimentalIoApi\n    inline fun writeDirect(block: (DataView) -> Int): Int {\n        val view = writableView()\n        val rc = block(view)\n        check(rc >= 0) { \"The returned value from block function shouldn't be negative: $rc\"}\n        check(rc <= writeRemaining) { \"The returned value from block function is too big: $rc > $writeRemaining\" }\n        commitWritten(rc)\n        return rc\n    }\n\n    internal actual fun restoreEndGap(n: Int) {\n        val newLimit = limit - n\n        limit = newLimit\n        if (writePosition > newLimit) {\n            writePosition = newLimit\n        }\n        if (readPosition > newLimit) {\n            readPosition = newLimit\n        }\n    }\n\n    internal actual fun restoreStartGap(n: Int) {\n        val rp = readPosition\n        if (rp < n) {\n            throw IllegalArgumentException(\"Can't restore start gap: $n bytes were not reserved before\")\n        }\n\n        readPosition = rp - n\n    }\n\n    internal actual fun writeBufferPrepend(other: IoBuffer) {\n        val size = other.readRemaining\n        require(size <= startGap) { \"size should be greater than startGap (size = $size, startGap = $startGap)\" }\n\n        val otherEnd = other.readPosition + size\n        val sub = other.i8.subarray(other.readPosition, otherEnd)\n\n        i8.set(sub, readPosition - size)\n        readPosition -= size\n        other.readPosition += size\n    }\n\n    internal actual fun writeBufferAppend(other: IoBuffer, maxSize: Int) {\n        val size = minOf(other.readRemaining, maxSize)\n        require(size <= writeRemaining + endGap) { \"should be greater than write space + end gap (size = $size, \" +\n                \"writeRemaining = $writeRemaining, endGap = $endGap, rem+gap = ${writeRemaining + endGap}\" }\n\n        val otherEnd = other.readPosition + size\n        val sub = other.i8.subarray(other.readPosition, otherEnd)\n\n        i8.set(sub, writePosition)\n        writePosition += size\n        if (writePosition > limit) {\n            limit = writePosition\n        }\n        other.readPosition += size\n    }\n\n    internal fun unlink() {\n        if (refCount != 0) throw IllegalStateException(\"Unable to unlink buffers: buffer view is in use\")\n        content = EmptyBuffer\n        i8 = Empty8\n        i16 = Empty16\n        i32 = Empty32\n        f32 = EmptyF32\n        f64 = EmptyF64\n        view = EmptyDataView\n        resetForWrite()\n    }\n\n    private fun acquire() {\n        val v = refCount\n        if (v == 0) throw IllegalStateException(\"Failed to acquire buffer: buffer has been already released\")\n        refCount = v + 1\n    }\n\n    private fun release(): Boolean {\n        if (this === Empty) throw IllegalStateException(\"attempted to release IoBuffer.Empty\")\n\n        val v = refCount\n        if (v == 0) throw IllegalStateException(\"Unable to release: buffer has been already released\")\n        val newCount = v - 1\n        refCount = newCount\n        return newCount == 0\n    }\n\n    actual override fun close() {\n        throw UnsupportedOperationException(\"close for buffer view is not supported\")\n    }\n\n    override fun toString(): String =\n        \"Buffer[readable = $readRemaining, writable = $writeRemaining, startGap = $startGap, endGap = $endGap]\"\n\n    actual companion object {\n        /**\n         * Number of bytes usually reserved in the end of chunk\n         * when several instances of [IoBuffer] are connected into a chain (usually inside of [ByteReadPacket]\n         * or [BytePacketBuilder])\n         */\n        @Deprecated(\"This implementation detail is going to become internal.\")\n        actual val ReservedSize: Int = 8\n\n        private val EmptyBuffer = ArrayBuffer(0)\n        private val EmptyDataView = DataView(EmptyBuffer)\n        private val Empty8 = Int8Array(0)\n        private val Empty16 = Int16Array(0)\n        private val Empty32 = Int32Array(0)\n        private val EmptyF32 = Float32Array(0)\n        private val EmptyF64 = Float64Array(0)\n\n        actual val Empty = IoBuffer(EmptyBuffer, null)\n        actual val Pool: ObjectPool<IoBuffer> = object: DefaultPool<IoBuffer>(BUFFER_VIEW_POOL_SIZE) {\n            override fun produceInstance(): IoBuffer {\n                return IoBuffer(ArrayBuffer(BUFFER_VIEW_SIZE), null)\n            }\n\n            override fun clearInstance(instance: IoBuffer): IoBuffer {\n                return super.clearInstance(instance).apply {\n                    instance.resetForWrite()\n                    instance.next = null\n                    instance.attachment = null\n\n                    if (instance.refCount != 0) throw IllegalStateException(\"Unable to clear instance: refCount is ${instance.refCount} != 0\")\n                    instance.refCount = 1\n                }\n            }\n\n            override fun validateInstance(instance: IoBuffer) {\n                super.validateInstance(instance)\n\n                require(instance.refCount == 0) { \"unable to recycle buffer: buffer view is in use (refCount = ${instance.refCount})\"}\n                require(instance.origin == null) { \"Unable to recycle buffer view: view copy shouldn't be recycled\" }\n            }\n\n            override fun disposeInstance(instance: IoBuffer) {\n                instance.unlink()\n            }\n        }\n\n        actual val NoPool: ObjectPool<IoBuffer> = object : NoPoolImpl<IoBuffer>() {\n            override fun borrow(): IoBuffer {\n                return IoBuffer(ArrayBuffer(4096), null)\n            }\n        }\n\n        actual val EmptyPool: ObjectPool<IoBuffer> = EmptyBufferPoolImpl\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// NOTE: THIS FILE IS AUTO-GENERATED, DO NOT EDIT!\n// See libraries/tools/idl2k for details\n\n@file:Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npackage org.khronos.webgl\n\nimport kotlin.js.*\nimport org.w3c.css.masking.*\nimport org.w3c.dom.*\nimport org.w3c.dom.clipboard.*\nimport org.w3c.dom.css.*\nimport org.w3c.dom.events.*\nimport org.w3c.dom.mediacapture.*\nimport org.w3c.dom.parsing.*\nimport org.w3c.dom.pointerevents.*\nimport org.w3c.dom.svg.*\nimport org.w3c.dom.url.*\nimport org.w3c.fetch.*\nimport org.w3c.files.*\nimport org.w3c.notifications.*\nimport org.w3c.performance.*\nimport org.w3c.workers.*\nimport org.w3c.xhr.*\n\npublic external interface WebGLContextAttributes {\n    var alpha: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var depth: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var stencil: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var antialias: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var premultipliedAlpha: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var preserveDrawingBuffer: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var preferLowPowerToHighPerformance: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var failIfMajorPerformanceCaveat: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun WebGLContextAttributes(alpha: Boolean? = true, depth: Boolean? = true, stencil: Boolean? = false, antialias: Boolean? = true, premultipliedAlpha: Boolean? = true, preserveDrawingBuffer: Boolean? = false, preferLowPowerToHighPerformance: Boolean? = false, failIfMajorPerformanceCaveat: Boolean? = false): WebGLContextAttributes {\n    val o = js(\"({})\")\n\n    o[\"alpha\"] = alpha\n    o[\"depth\"] = depth\n    o[\"stencil\"] = stencil\n    o[\"antialias\"] = antialias\n    o[\"premultipliedAlpha\"] = premultipliedAlpha\n    o[\"preserveDrawingBuffer\"] = preserveDrawingBuffer\n    o[\"preferLowPowerToHighPerformance\"] = preferLowPowerToHighPerformance\n    o[\"failIfMajorPerformanceCaveat\"] = failIfMajorPerformanceCaveat\n\n    return o\n}\n\npublic external abstract class WebGLObject {\n}\n\n/**\n * Exposes the JavaScript [WebGLBuffer](https://developer.mozilla.org/en/docs/Web/API/WebGLBuffer) to Kotlin\n */\npublic external abstract class WebGLBuffer : WebGLObject {\n}\n\n/**\n * Exposes the JavaScript [WebGLFramebuffer](https://developer.mozilla.org/en/docs/Web/API/WebGLFramebuffer) to Kotlin\n */\npublic external abstract class WebGLFramebuffer : WebGLObject {\n}\n\n/**\n * Exposes the JavaScript [WebGLProgram](https://developer.mozilla.org/en/docs/Web/API/WebGLProgram) to Kotlin\n */\npublic external abstract class WebGLProgram : WebGLObject {\n}\n\n/**\n * Exposes the JavaScript [WebGLRenderbuffer](https://developer.mozilla.org/en/docs/Web/API/WebGLRenderbuffer) to Kotlin\n */\npublic external abstract class WebGLRenderbuffer : WebGLObject {\n}\n\n/**\n * Exposes the JavaScript [WebGLShader](https://developer.mozilla.org/en/docs/Web/API/WebGLShader) to Kotlin\n */\npublic external abstract class WebGLShader : WebGLObject {\n}\n\n/**\n * Exposes the JavaScript [WebGLTexture](https://developer.mozilla.org/en/docs/Web/API/WebGLTexture) to Kotlin\n */\npublic external abstract class WebGLTexture : WebGLObject {\n}\n\n/**\n * Exposes the JavaScript [WebGLUniformLocation](https://developer.mozilla.org/en/docs/Web/API/WebGLUniformLocation) to Kotlin\n */\npublic external abstract class WebGLUniformLocation {\n}\n\n/**\n * Exposes the JavaScript [WebGLActiveInfo](https://developer.mozilla.org/en/docs/Web/API/WebGLActiveInfo) to Kotlin\n */\npublic external abstract class WebGLActiveInfo {\n    open val size: Int\n    open val type: Int\n    open val name: String\n}\n\n/**\n * Exposes the JavaScript [WebGLShaderPrecisionFormat](https://developer.mozilla.org/en/docs/Web/API/WebGLShaderPrecisionFormat) to Kotlin\n */\npublic external abstract class WebGLShaderPrecisionFormat {\n    open val rangeMin: Int\n    open val rangeMax: Int\n    open val precision: Int\n}\n\npublic external interface WebGLRenderingContextBase {\n    val canvas: HTMLCanvasElement\n    val drawingBufferWidth: Int\n    val drawingBufferHeight: Int\n    fun getContextAttributes(): WebGLContextAttributes?\n    fun isContextLost(): Boolean\n    fun getSupportedExtensions(): Array<String>?\n    fun getExtension(name: String): dynamic\n    fun activeTexture(texture: Int): Unit\n    fun attachShader(program: WebGLProgram?, shader: WebGLShader?): Unit\n    fun bindAttribLocation(program: WebGLProgram?, index: Int, name: String): Unit\n    fun bindBuffer(target: Int, buffer: WebGLBuffer?): Unit\n    fun bindFramebuffer(target: Int, framebuffer: WebGLFramebuffer?): Unit\n    fun bindRenderbuffer(target: Int, renderbuffer: WebGLRenderbuffer?): Unit\n    fun bindTexture(target: Int, texture: WebGLTexture?): Unit\n    fun blendColor(red: Float, green: Float, blue: Float, alpha: Float): Unit\n    fun blendEquation(mode: Int): Unit\n    fun blendEquationSeparate(modeRGB: Int, modeAlpha: Int): Unit\n    fun blendFunc(sfactor: Int, dfactor: Int): Unit\n    fun blendFuncSeparate(srcRGB: Int, dstRGB: Int, srcAlpha: Int, dstAlpha: Int): Unit\n    fun bufferData(target: Int, size: Int, usage: Int): Unit\n    fun bufferData(target: Int, data: BufferDataSource?, usage: Int): Unit\n    fun bufferSubData(target: Int, offset: Int, data: BufferDataSource?): Unit\n    fun checkFramebufferStatus(target: Int): Int\n    fun clear(mask: Int): Unit\n    fun clearColor(red: Float, green: Float, blue: Float, alpha: Float): Unit\n    fun clearDepth(depth: Float): Unit\n    fun clearStencil(s: Int): Unit\n    fun colorMask(red: Boolean, green: Boolean, blue: Boolean, alpha: Boolean): Unit\n    fun compileShader(shader: WebGLShader?): Unit\n    fun compressedTexImage2D(target: Int, level: Int, internalformat: Int, width: Int, height: Int, border: Int, data: ArrayBufferView): Unit\n    fun compressedTexSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, width: Int, height: Int, format: Int, data: ArrayBufferView): Unit\n    fun copyTexImage2D(target: Int, level: Int, internalformat: Int, x: Int, y: Int, width: Int, height: Int, border: Int): Unit\n    fun copyTexSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, x: Int, y: Int, width: Int, height: Int): Unit\n    fun createBuffer(): WebGLBuffer?\n    fun createFramebuffer(): WebGLFramebuffer?\n    fun createProgram(): WebGLProgram?\n    fun createRenderbuffer(): WebGLRenderbuffer?\n    fun createShader(type: Int): WebGLShader?\n    fun createTexture(): WebGLTexture?\n    fun cullFace(mode: Int): Unit\n    fun deleteBuffer(buffer: WebGLBuffer?): Unit\n    fun deleteFramebuffer(framebuffer: WebGLFramebuffer?): Unit\n    fun deleteProgram(program: WebGLProgram?): Unit\n    fun deleteRenderbuffer(renderbuffer: WebGLRenderbuffer?): Unit\n    fun deleteShader(shader: WebGLShader?): Unit\n    fun deleteTexture(texture: WebGLTexture?): Unit\n    fun depthFunc(func: Int): Unit\n    fun depthMask(flag: Boolean): Unit\n    fun depthRange(zNear: Float, zFar: Float): Unit\n    fun detachShader(program: WebGLProgram?, shader: WebGLShader?): Unit\n    fun disable(cap: Int): Unit\n    fun disableVertexAttribArray(index: Int): Unit\n    fun drawArrays(mode: Int, first: Int, count: Int): Unit\n    fun drawElements(mode: Int, count: Int, type: Int, offset: Int): Unit\n    fun enable(cap: Int): Unit\n    fun enableVertexAttribArray(index: Int): Unit\n    fun finish(): Unit\n    fun flush(): Unit\n    fun framebufferRenderbuffer(target: Int, attachment: Int, renderbuffertarget: Int, renderbuffer: WebGLRenderbuffer?): Unit\n    fun framebufferTexture2D(target: Int, attachment: Int, textarget: Int, texture: WebGLTexture?, level: Int): Unit\n    fun frontFace(mode: Int): Unit\n    fun generateMipmap(target: Int): Unit\n    fun getActiveAttrib(program: WebGLProgram?, index: Int): WebGLActiveInfo?\n    fun getActiveUniform(program: WebGLProgram?, index: Int): WebGLActiveInfo?\n    fun getAttachedShaders(program: WebGLProgram?): Array<WebGLShader>?\n    fun getAttribLocation(program: WebGLProgram?, name: String): Int\n    fun getBufferParameter(target: Int, pname: Int): Any?\n    fun getParameter(pname: Int): Any?\n    fun getError(): Int\n    fun getFramebufferAttachmentParameter(target: Int, attachment: Int, pname: Int): Any?\n    fun getProgramParameter(program: WebGLProgram?, pname: Int): Any?\n    fun getProgramInfoLog(program: WebGLProgram?): String?\n    fun getRenderbufferParameter(target: Int, pname: Int): Any?\n    fun getShaderParameter(shader: WebGLShader?, pname: Int): Any?\n    fun getShaderPrecisionFormat(shadertype: Int, precisiontype: Int): WebGLShaderPrecisionFormat?\n    fun getShaderInfoLog(shader: WebGLShader?): String?\n    fun getShaderSource(shader: WebGLShader?): String?\n    fun getTexParameter(target: Int, pname: Int): Any?\n    fun getUniform(program: WebGLProgram?, location: WebGLUniformLocation?): Any?\n    fun getUniformLocation(program: WebGLProgram?, name: String): WebGLUniformLocation?\n    fun getVertexAttrib(index: Int, pname: Int): Any?\n    fun getVertexAttribOffset(index: Int, pname: Int): Int\n    fun hint(target: Int, mode: Int): Unit\n    fun isBuffer(buffer: WebGLBuffer?): Boolean\n    fun isEnabled(cap: Int): Boolean\n    fun isFramebuffer(framebuffer: WebGLFramebuffer?): Boolean\n    fun isProgram(program: WebGLProgram?): Boolean\n    fun isRenderbuffer(renderbuffer: WebGLRenderbuffer?): Boolean\n    fun isShader(shader: WebGLShader?): Boolean\n    fun isTexture(texture: WebGLTexture?): Boolean\n    fun lineWidth(width: Float): Unit\n    fun linkProgram(program: WebGLProgram?): Unit\n    fun pixelStorei(pname: Int, param: Int): Unit\n    fun polygonOffset(factor: Float, units: Float): Unit\n    fun readPixels(x: Int, y: Int, width: Int, height: Int, format: Int, type: Int, pixels: ArrayBufferView?): Unit\n    fun renderbufferStorage(target: Int, internalformat: Int, width: Int, height: Int): Unit\n    fun sampleCoverage(value: Float, invert: Boolean): Unit\n    fun scissor(x: Int, y: Int, width: Int, height: Int): Unit\n    fun shaderSource(shader: WebGLShader?, source: String): Unit\n    fun stencilFunc(func: Int, ref: Int, mask: Int): Unit\n    fun stencilFuncSeparate(face: Int, func: Int, ref: Int, mask: Int): Unit\n    fun stencilMask(mask: Int): Unit\n    fun stencilMaskSeparate(face: Int, mask: Int): Unit\n    fun stencilOp(fail: Int, zfail: Int, zpass: Int): Unit\n    fun stencilOpSeparate(face: Int, fail: Int, zfail: Int, zpass: Int): Unit\n    fun texImage2D(target: Int, level: Int, internalformat: Int, width: Int, height: Int, border: Int, format: Int, type: Int, pixels: ArrayBufferView?): Unit\n    fun texImage2D(target: Int, level: Int, internalformat: Int, format: Int, type: Int, source: TexImageSource?): Unit\n    fun texParameterf(target: Int, pname: Int, param: Float): Unit\n    fun texParameteri(target: Int, pname: Int, param: Int): Unit\n    fun texSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, width: Int, height: Int, format: Int, type: Int, pixels: ArrayBufferView?): Unit\n    fun texSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, format: Int, type: Int, source: TexImageSource?): Unit\n    fun uniform1f(location: WebGLUniformLocation?, x: Float): Unit\n    fun uniform1fv(location: WebGLUniformLocation?, v: Float32Array): Unit\n    fun uniform1fv(location: WebGLUniformLocation?, v: Array<Float>): Unit\n    fun uniform1i(location: WebGLUniformLocation?, x: Int): Unit\n    fun uniform1iv(location: WebGLUniformLocation?, v: Int32Array): Unit\n    fun uniform1iv(location: WebGLUniformLocation?, v: Array<Int>): Unit\n    fun uniform2f(location: WebGLUniformLocation?, x: Float, y: Float): Unit\n    fun uniform2fv(location: WebGLUniformLocation?, v: Float32Array): Unit\n    fun uniform2fv(location: WebGLUniformLocation?, v: Array<Float>): Unit\n    fun uniform2i(location: WebGLUniformLocation?, x: Int, y: Int): Unit\n    fun uniform2iv(location: WebGLUniformLocation?, v: Int32Array): Unit\n    fun uniform2iv(location: WebGLUniformLocation?, v: Array<Int>): Unit\n    fun uniform3f(location: WebGLUniformLocation?, x: Float, y: Float, z: Float): Unit\n    fun uniform3fv(location: WebGLUniformLocation?, v: Float32Array): Unit\n    fun uniform3fv(location: WebGLUniformLocation?, v: Array<Float>): Unit\n    fun uniform3i(location: WebGLUniformLocation?, x: Int, y: Int, z: Int): Unit\n    fun uniform3iv(location: WebGLUniformLocation?, v: Int32Array): Unit\n    fun uniform3iv(location: WebGLUniformLocation?, v: Array<Int>): Unit\n    fun uniform4f(location: WebGLUniformLocation?, x: Float, y: Float, z: Float, w: Float): Unit\n    fun uniform4fv(location: WebGLUniformLocation?, v: Float32Array): Unit\n    fun uniform4fv(location: WebGLUniformLocation?, v: Array<Float>): Unit\n    fun uniform4i(location: WebGLUniformLocation?, x: Int, y: Int, z: Int, w: Int): Unit\n    fun uniform4iv(location: WebGLUniformLocation?, v: Int32Array): Unit\n    fun uniform4iv(location: WebGLUniformLocation?, v: Array<Int>): Unit\n    fun uniformMatrix2fv(location: WebGLUniformLocation?, transpose: Boolean, value: Float32Array): Unit\n    fun uniformMatrix2fv(location: WebGLUniformLocation?, transpose: Boolean, value: Array<Float>): Unit\n    fun uniformMatrix3fv(location: WebGLUniformLocation?, transpose: Boolean, value: Float32Array): Unit\n    fun uniformMatrix3fv(location: WebGLUniformLocation?, transpose: Boolean, value: Array<Float>): Unit\n    fun uniformMatrix4fv(location: WebGLUniformLocation?, transpose: Boolean, value: Float32Array): Unit\n    fun uniformMatrix4fv(location: WebGLUniformLocation?, transpose: Boolean, value: Array<Float>): Unit\n    fun useProgram(program: WebGLProgram?): Unit\n    fun validateProgram(program: WebGLProgram?): Unit\n    fun vertexAttrib1f(index: Int, x: Float): Unit\n    fun vertexAttrib1fv(index: Int, values: dynamic): Unit\n    fun vertexAttrib2f(index: Int, x: Float, y: Float): Unit\n    fun vertexAttrib2fv(index: Int, values: dynamic): Unit\n    fun vertexAttrib3f(index: Int, x: Float, y: Float, z: Float): Unit\n    fun vertexAttrib3fv(index: Int, values: dynamic): Unit\n    fun vertexAttrib4f(index: Int, x: Float, y: Float, z: Float, w: Float): Unit\n    fun vertexAttrib4fv(index: Int, values: dynamic): Unit\n    fun vertexAttribPointer(index: Int, size: Int, type: Int, normalized: Boolean, stride: Int, offset: Int): Unit\n    fun viewport(x: Int, y: Int, width: Int, height: Int): Unit\n\n    companion object {\n        val DEPTH_BUFFER_BIT: Int\n        val STENCIL_BUFFER_BIT: Int\n        val COLOR_BUFFER_BIT: Int\n        val POINTS: Int\n        val LINES: Int\n        val LINE_LOOP: Int\n        val LINE_STRIP: Int\n        val TRIANGLES: Int\n        val TRIANGLE_STRIP: Int\n        val TRIANGLE_FAN: Int\n        val ZERO: Int\n        val ONE: Int\n        val SRC_COLOR: Int\n        val ONE_MINUS_SRC_COLOR: Int\n        val SRC_ALPHA: Int\n        val ONE_MINUS_SRC_ALPHA: Int\n        val DST_ALPHA: Int\n        val ONE_MINUS_DST_ALPHA: Int\n        val DST_COLOR: Int\n        val ONE_MINUS_DST_COLOR: Int\n        val SRC_ALPHA_SATURATE: Int\n        val FUNC_ADD: Int\n        val BLEND_EQUATION: Int\n        val BLEND_EQUATION_RGB: Int\n        val BLEND_EQUATION_ALPHA: Int\n        val FUNC_SUBTRACT: Int\n        val FUNC_REVERSE_SUBTRACT: Int\n        val BLEND_DST_RGB: Int\n        val BLEND_SRC_RGB: Int\n        val BLEND_DST_ALPHA: Int\n        val BLEND_SRC_ALPHA: Int\n        val CONSTANT_COLOR: Int\n        val ONE_MINUS_CONSTANT_COLOR: Int\n        val CONSTANT_ALPHA: Int\n        val ONE_MINUS_CONSTANT_ALPHA: Int\n        val BLEND_COLOR: Int\n        val ARRAY_BUFFER: Int\n        val ELEMENT_ARRAY_BUFFER: Int\n        val ARRAY_BUFFER_BINDING: Int\n        val ELEMENT_ARRAY_BUFFER_BINDING: Int\n        val STREAM_DRAW: Int\n        val STATIC_DRAW: Int\n        val DYNAMIC_DRAW: Int\n        val BUFFER_SIZE: Int\n        val BUFFER_USAGE: Int\n        val CURRENT_VERTEX_ATTRIB: Int\n        val FRONT: Int\n        val BACK: Int\n        val FRONT_AND_BACK: Int\n        val CULL_FACE: Int\n        val BLEND: Int\n        val DITHER: Int\n        val STENCIL_TEST: Int\n        val DEPTH_TEST: Int\n        val SCISSOR_TEST: Int\n        val POLYGON_OFFSET_FILL: Int\n        val SAMPLE_ALPHA_TO_COVERAGE: Int\n        val SAMPLE_COVERAGE: Int\n        val NO_ERROR: Int\n        val INVALID_ENUM: Int\n        val INVALID_VALUE: Int\n        val INVALID_OPERATION: Int\n        val OUT_OF_MEMORY: Int\n        val CW: Int\n        val CCW: Int\n        val LINE_WIDTH: Int\n        val ALIASED_POINT_SIZE_RANGE: Int\n        val ALIASED_LINE_WIDTH_RANGE: Int\n        val CULL_FACE_MODE: Int\n        val FRONT_FACE: Int\n        val DEPTH_RANGE: Int\n        val DEPTH_WRITEMASK: Int\n        val DEPTH_CLEAR_VALUE: Int\n        val DEPTH_FUNC: Int\n        val STENCIL_CLEAR_VALUE: Int\n        val STENCIL_FUNC: Int\n        val STENCIL_FAIL: Int\n        val STENCIL_PASS_DEPTH_FAIL: Int\n        val STENCIL_PASS_DEPTH_PASS: Int\n        val STENCIL_REF: Int\n        val STENCIL_VALUE_MASK: Int\n        val STENCIL_WRITEMASK: Int\n        val STENCIL_BACK_FUNC: Int\n        val STENCIL_BACK_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_PASS: Int\n        val STENCIL_BACK_REF: Int\n        val STENCIL_BACK_VALUE_MASK: Int\n        val STENCIL_BACK_WRITEMASK: Int\n        val VIEWPORT: Int\n        val SCISSOR_BOX: Int\n        val COLOR_CLEAR_VALUE: Int\n        val COLOR_WRITEMASK: Int\n        val UNPACK_ALIGNMENT: Int\n        val PACK_ALIGNMENT: Int\n        val MAX_TEXTURE_SIZE: Int\n        val MAX_VIEWPORT_DIMS: Int\n        val SUBPIXEL_BITS: Int\n        val RED_BITS: Int\n        val GREEN_BITS: Int\n        val BLUE_BITS: Int\n        val ALPHA_BITS: Int\n        val DEPTH_BITS: Int\n        val STENCIL_BITS: Int\n        val POLYGON_OFFSET_UNITS: Int\n        val POLYGON_OFFSET_FACTOR: Int\n        val TEXTURE_BINDING_2D: Int\n        val SAMPLE_BUFFERS: Int\n        val SAMPLES: Int\n        val SAMPLE_COVERAGE_VALUE: Int\n        val SAMPLE_COVERAGE_INVERT: Int\n        val COMPRESSED_TEXTURE_FORMATS: Int\n        val DONT_CARE: Int\n        val FASTEST: Int\n        val NICEST: Int\n        val GENERATE_MIPMAP_HINT: Int\n        val BYTE: Int\n        val UNSIGNED_BYTE: Int\n        val SHORT: Int\n        val UNSIGNED_SHORT: Int\n        val INT: Int\n        val UNSIGNED_INT: Int\n        val FLOAT: Int\n        val DEPTH_COMPONENT: Int\n        val ALPHA: Int\n        val RGB: Int\n        val RGBA: Int\n        val LUMINANCE: Int\n        val LUMINANCE_ALPHA: Int\n        val UNSIGNED_SHORT_4_4_4_4: Int\n        val UNSIGNED_SHORT_5_5_5_1: Int\n        val UNSIGNED_SHORT_5_6_5: Int\n        val FRAGMENT_SHADER: Int\n        val VERTEX_SHADER: Int\n        val MAX_VERTEX_ATTRIBS: Int\n        val MAX_VERTEX_UNIFORM_VECTORS: Int\n        val MAX_VARYING_VECTORS: Int\n        val MAX_COMBINED_TEXTURE_IMAGE_UNITS: Int\n        val MAX_VERTEX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_FRAGMENT_UNIFORM_VECTORS: Int\n        val SHADER_TYPE: Int\n        val DELETE_STATUS: Int\n        val LINK_STATUS: Int\n        val VALIDATE_STATUS: Int\n        val ATTACHED_SHADERS: Int\n        val ACTIVE_UNIFORMS: Int\n        val ACTIVE_ATTRIBUTES: Int\n        val SHADING_LANGUAGE_VERSION: Int\n        val CURRENT_PROGRAM: Int\n        val NEVER: Int\n        val LESS: Int\n        val EQUAL: Int\n        val LEQUAL: Int\n        val GREATER: Int\n        val NOTEQUAL: Int\n        val GEQUAL: Int\n        val ALWAYS: Int\n        val KEEP: Int\n        val REPLACE: Int\n        val INCR: Int\n        val DECR: Int\n        val INVERT: Int\n        val INCR_WRAP: Int\n        val DECR_WRAP: Int\n        val VENDOR: Int\n        val RENDERER: Int\n        val VERSION: Int\n        val NEAREST: Int\n        val LINEAR: Int\n        val NEAREST_MIPMAP_NEAREST: Int\n        val LINEAR_MIPMAP_NEAREST: Int\n        val NEAREST_MIPMAP_LINEAR: Int\n        val LINEAR_MIPMAP_LINEAR: Int\n        val TEXTURE_MAG_FILTER: Int\n        val TEXTURE_MIN_FILTER: Int\n        val TEXTURE_WRAP_S: Int\n        val TEXTURE_WRAP_T: Int\n        val TEXTURE_2D: Int\n        val TEXTURE: Int\n        val TEXTURE_CUBE_MAP: Int\n        val TEXTURE_BINDING_CUBE_MAP: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_X: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_X: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Y: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Y: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Z: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Z: Int\n        val MAX_CUBE_MAP_TEXTURE_SIZE: Int\n        val TEXTURE0: Int\n        val TEXTURE1: Int\n        val TEXTURE2: Int\n        val TEXTURE3: Int\n        val TEXTURE4: Int\n        val TEXTURE5: Int\n        val TEXTURE6: Int\n        val TEXTURE7: Int\n        val TEXTURE8: Int\n        val TEXTURE9: Int\n        val TEXTURE10: Int\n        val TEXTURE11: Int\n        val TEXTURE12: Int\n        val TEXTURE13: Int\n        val TEXTURE14: Int\n        val TEXTURE15: Int\n        val TEXTURE16: Int\n        val TEXTURE17: Int\n        val TEXTURE18: Int\n        val TEXTURE19: Int\n        val TEXTURE20: Int\n        val TEXTURE21: Int\n        val TEXTURE22: Int\n        val TEXTURE23: Int\n        val TEXTURE24: Int\n        val TEXTURE25: Int\n        val TEXTURE26: Int\n        val TEXTURE27: Int\n        val TEXTURE28: Int\n        val TEXTURE29: Int\n        val TEXTURE30: Int\n        val TEXTURE31: Int\n        val ACTIVE_TEXTURE: Int\n        val REPEAT: Int\n        val CLAMP_TO_EDGE: Int\n        val MIRRORED_REPEAT: Int\n        val FLOAT_VEC2: Int\n        val FLOAT_VEC3: Int\n        val FLOAT_VEC4: Int\n        val INT_VEC2: Int\n        val INT_VEC3: Int\n        val INT_VEC4: Int\n        val BOOL: Int\n        val BOOL_VEC2: Int\n        val BOOL_VEC3: Int\n        val BOOL_VEC4: Int\n        val FLOAT_MAT2: Int\n        val FLOAT_MAT3: Int\n        val FLOAT_MAT4: Int\n        val SAMPLER_2D: Int\n        val SAMPLER_CUBE: Int\n        val VERTEX_ATTRIB_ARRAY_ENABLED: Int\n        val VERTEX_ATTRIB_ARRAY_SIZE: Int\n        val VERTEX_ATTRIB_ARRAY_STRIDE: Int\n        val VERTEX_ATTRIB_ARRAY_TYPE: Int\n        val VERTEX_ATTRIB_ARRAY_NORMALIZED: Int\n        val VERTEX_ATTRIB_ARRAY_POINTER: Int\n        val VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: Int\n        val IMPLEMENTATION_COLOR_READ_TYPE: Int\n        val IMPLEMENTATION_COLOR_READ_FORMAT: Int\n        val COMPILE_STATUS: Int\n        val LOW_FLOAT: Int\n        val MEDIUM_FLOAT: Int\n        val HIGH_FLOAT: Int\n        val LOW_INT: Int\n        val MEDIUM_INT: Int\n        val HIGH_INT: Int\n        val FRAMEBUFFER: Int\n        val RENDERBUFFER: Int\n        val RGBA4: Int\n        val RGB5_A1: Int\n        val RGB565: Int\n        val DEPTH_COMPONENT16: Int\n        val STENCIL_INDEX: Int\n        val STENCIL_INDEX8: Int\n        val DEPTH_STENCIL: Int\n        val RENDERBUFFER_WIDTH: Int\n        val RENDERBUFFER_HEIGHT: Int\n        val RENDERBUFFER_INTERNAL_FORMAT: Int\n        val RENDERBUFFER_RED_SIZE: Int\n        val RENDERBUFFER_GREEN_SIZE: Int\n        val RENDERBUFFER_BLUE_SIZE: Int\n        val RENDERBUFFER_ALPHA_SIZE: Int\n        val RENDERBUFFER_DEPTH_SIZE: Int\n        val RENDERBUFFER_STENCIL_SIZE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: Int\n        val COLOR_ATTACHMENT0: Int\n        val DEPTH_ATTACHMENT: Int\n        val STENCIL_ATTACHMENT: Int\n        val DEPTH_STENCIL_ATTACHMENT: Int\n        val NONE: Int\n        val FRAMEBUFFER_COMPLETE: Int\n        val FRAMEBUFFER_INCOMPLETE_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_DIMENSIONS: Int\n        val FRAMEBUFFER_UNSUPPORTED: Int\n        val FRAMEBUFFER_BINDING: Int\n        val RENDERBUFFER_BINDING: Int\n        val MAX_RENDERBUFFER_SIZE: Int\n        val INVALID_FRAMEBUFFER_OPERATION: Int\n        val UNPACK_FLIP_Y_WEBGL: Int\n        val UNPACK_PREMULTIPLY_ALPHA_WEBGL: Int\n        val CONTEXT_LOST_WEBGL: Int\n        val UNPACK_COLORSPACE_CONVERSION_WEBGL: Int\n        val BROWSER_DEFAULT_WEBGL: Int\n    }\n}\n\n/**\n * Exposes the JavaScript [WebGLRenderingContext](https://developer.mozilla.org/en/docs/Web/API/WebGLRenderingContext) to Kotlin\n */\npublic external abstract class WebGLRenderingContext : WebGLRenderingContextBase, RenderingContext {\n\n    companion object {\n        val DEPTH_BUFFER_BIT: Int\n        val STENCIL_BUFFER_BIT: Int\n        val COLOR_BUFFER_BIT: Int\n        val POINTS: Int\n        val LINES: Int\n        val LINE_LOOP: Int\n        val LINE_STRIP: Int\n        val TRIANGLES: Int\n        val TRIANGLE_STRIP: Int\n        val TRIANGLE_FAN: Int\n        val ZERO: Int\n        val ONE: Int\n        val SRC_COLOR: Int\n        val ONE_MINUS_SRC_COLOR: Int\n        val SRC_ALPHA: Int\n        val ONE_MINUS_SRC_ALPHA: Int\n        val DST_ALPHA: Int\n        val ONE_MINUS_DST_ALPHA: Int\n        val DST_COLOR: Int\n        val ONE_MINUS_DST_COLOR: Int\n        val SRC_ALPHA_SATURATE: Int\n        val FUNC_ADD: Int\n        val BLEND_EQUATION: Int\n        val BLEND_EQUATION_RGB: Int\n        val BLEND_EQUATION_ALPHA: Int\n        val FUNC_SUBTRACT: Int\n        val FUNC_REVERSE_SUBTRACT: Int\n        val BLEND_DST_RGB: Int\n        val BLEND_SRC_RGB: Int\n        val BLEND_DST_ALPHA: Int\n        val BLEND_SRC_ALPHA: Int\n        val CONSTANT_COLOR: Int\n        val ONE_MINUS_CONSTANT_COLOR: Int\n        val CONSTANT_ALPHA: Int\n        val ONE_MINUS_CONSTANT_ALPHA: Int\n        val BLEND_COLOR: Int\n        val ARRAY_BUFFER: Int\n        val ELEMENT_ARRAY_BUFFER: Int\n        val ARRAY_BUFFER_BINDING: Int\n        val ELEMENT_ARRAY_BUFFER_BINDING: Int\n        val STREAM_DRAW: Int\n        val STATIC_DRAW: Int\n        val DYNAMIC_DRAW: Int\n        val BUFFER_SIZE: Int\n        val BUFFER_USAGE: Int\n        val CURRENT_VERTEX_ATTRIB: Int\n        val FRONT: Int\n        val BACK: Int\n        val FRONT_AND_BACK: Int\n        val CULL_FACE: Int\n        val BLEND: Int\n        val DITHER: Int\n        val STENCIL_TEST: Int\n        val DEPTH_TEST: Int\n        val SCISSOR_TEST: Int\n        val POLYGON_OFFSET_FILL: Int\n        val SAMPLE_ALPHA_TO_COVERAGE: Int\n        val SAMPLE_COVERAGE: Int\n        val NO_ERROR: Int\n        val INVALID_ENUM: Int\n        val INVALID_VALUE: Int\n        val INVALID_OPERATION: Int\n        val OUT_OF_MEMORY: Int\n        val CW: Int\n        val CCW: Int\n        val LINE_WIDTH: Int\n        val ALIASED_POINT_SIZE_RANGE: Int\n        val ALIASED_LINE_WIDTH_RANGE: Int\n        val CULL_FACE_MODE: Int\n        val FRONT_FACE: Int\n        val DEPTH_RANGE: Int\n        val DEPTH_WRITEMASK: Int\n        val DEPTH_CLEAR_VALUE: Int\n        val DEPTH_FUNC: Int\n        val STENCIL_CLEAR_VALUE: Int\n        val STENCIL_FUNC: Int\n        val STENCIL_FAIL: Int\n        val STENCIL_PASS_DEPTH_FAIL: Int\n        val STENCIL_PASS_DEPTH_PASS: Int\n        val STENCIL_REF: Int\n        val STENCIL_VALUE_MASK: Int\n        val STENCIL_WRITEMASK: Int\n        val STENCIL_BACK_FUNC: Int\n        val STENCIL_BACK_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_PASS: Int\n        val STENCIL_BACK_REF: Int\n        val STENCIL_BACK_VALUE_MASK: Int\n        val STENCIL_BACK_WRITEMASK: Int\n        val VIEWPORT: Int\n        val SCISSOR_BOX: Int\n        val COLOR_CLEAR_VALUE: Int\n        val COLOR_WRITEMASK: Int\n        val UNPACK_ALIGNMENT: Int\n        val PACK_ALIGNMENT: Int\n        val MAX_TEXTURE_SIZE: Int\n        val MAX_VIEWPORT_DIMS: Int\n        val SUBPIXEL_BITS: Int\n        val RED_BITS: Int\n        val GREEN_BITS: Int\n        val BLUE_BITS: Int\n        val ALPHA_BITS: Int\n        val DEPTH_BITS: Int\n        val STENCIL_BITS: Int\n        val POLYGON_OFFSET_UNITS: Int\n        val POLYGON_OFFSET_FACTOR: Int\n        val TEXTURE_BINDING_2D: Int\n        val SAMPLE_BUFFERS: Int\n        val SAMPLES: Int\n        val SAMPLE_COVERAGE_VALUE: Int\n        val SAMPLE_COVERAGE_INVERT: Int\n        val COMPRESSED_TEXTURE_FORMATS: Int\n        val DONT_CARE: Int\n        val FASTEST: Int\n        val NICEST: Int\n        val GENERATE_MIPMAP_HINT: Int\n        val BYTE: Int\n        val UNSIGNED_BYTE: Int\n        val SHORT: Int\n        val UNSIGNED_SHORT: Int\n        val INT: Int\n        val UNSIGNED_INT: Int\n        val FLOAT: Int\n        val DEPTH_COMPONENT: Int\n        val ALPHA: Int\n        val RGB: Int\n        val RGBA: Int\n        val LUMINANCE: Int\n        val LUMINANCE_ALPHA: Int\n        val UNSIGNED_SHORT_4_4_4_4: Int\n        val UNSIGNED_SHORT_5_5_5_1: Int\n        val UNSIGNED_SHORT_5_6_5: Int\n        val FRAGMENT_SHADER: Int\n        val VERTEX_SHADER: Int\n        val MAX_VERTEX_ATTRIBS: Int\n        val MAX_VERTEX_UNIFORM_VECTORS: Int\n        val MAX_VARYING_VECTORS: Int\n        val MAX_COMBINED_TEXTURE_IMAGE_UNITS: Int\n        val MAX_VERTEX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_FRAGMENT_UNIFORM_VECTORS: Int\n        val SHADER_TYPE: Int\n        val DELETE_STATUS: Int\n        val LINK_STATUS: Int\n        val VALIDATE_STATUS: Int\n        val ATTACHED_SHADERS: Int\n        val ACTIVE_UNIFORMS: Int\n        val ACTIVE_ATTRIBUTES: Int\n        val SHADING_LANGUAGE_VERSION: Int\n        val CURRENT_PROGRAM: Int\n        val NEVER: Int\n        val LESS: Int\n        val EQUAL: Int\n        val LEQUAL: Int\n        val GREATER: Int\n        val NOTEQUAL: Int\n        val GEQUAL: Int\n        val ALWAYS: Int\n        val KEEP: Int\n        val REPLACE: Int\n        val INCR: Int\n        val DECR: Int\n        val INVERT: Int\n        val INCR_WRAP: Int\n        val DECR_WRAP: Int\n        val VENDOR: Int\n        val RENDERER: Int\n        val VERSION: Int\n        val NEAREST: Int\n        val LINEAR: Int\n        val NEAREST_MIPMAP_NEAREST: Int\n        val LINEAR_MIPMAP_NEAREST: Int\n        val NEAREST_MIPMAP_LINEAR: Int\n        val LINEAR_MIPMAP_LINEAR: Int\n        val TEXTURE_MAG_FILTER: Int\n        val TEXTURE_MIN_FILTER: Int\n        val TEXTURE_WRAP_S: Int\n        val TEXTURE_WRAP_T: Int\n        val TEXTURE_2D: Int\n        val TEXTURE: Int\n        val TEXTURE_CUBE_MAP: Int\n        val TEXTURE_BINDING_CUBE_MAP: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_X: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_X: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Y: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Y: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Z: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Z: Int\n        val MAX_CUBE_MAP_TEXTURE_SIZE: Int\n        val TEXTURE0: Int\n        val TEXTURE1: Int\n        val TEXTURE2: Int\n        val TEXTURE3: Int\n        val TEXTURE4: Int\n        val TEXTURE5: Int\n        val TEXTURE6: Int\n        val TEXTURE7: Int\n        val TEXTURE8: Int\n        val TEXTURE9: Int\n        val TEXTURE10: Int\n        val TEXTURE11: Int\n        val TEXTURE12: Int\n        val TEXTURE13: Int\n        val TEXTURE14: Int\n        val TEXTURE15: Int\n        val TEXTURE16: Int\n        val TEXTURE17: Int\n        val TEXTURE18: Int\n        val TEXTURE19: Int\n        val TEXTURE20: Int\n        val TEXTURE21: Int\n        val TEXTURE22: Int\n        val TEXTURE23: Int\n        val TEXTURE24: Int\n        val TEXTURE25: Int\n        val TEXTURE26: Int\n        val TEXTURE27: Int\n        val TEXTURE28: Int\n        val TEXTURE29: Int\n        val TEXTURE30: Int\n        val TEXTURE31: Int\n        val ACTIVE_TEXTURE: Int\n        val REPEAT: Int\n        val CLAMP_TO_EDGE: Int\n        val MIRRORED_REPEAT: Int\n        val FLOAT_VEC2: Int\n        val FLOAT_VEC3: Int\n        val FLOAT_VEC4: Int\n        val INT_VEC2: Int\n        val INT_VEC3: Int\n        val INT_VEC4: Int\n        val BOOL: Int\n        val BOOL_VEC2: Int\n        val BOOL_VEC3: Int\n        val BOOL_VEC4: Int\n        val FLOAT_MAT2: Int\n        val FLOAT_MAT3: Int\n        val FLOAT_MAT4: Int\n        val SAMPLER_2D: Int\n        val SAMPLER_CUBE: Int\n        val VERTEX_ATTRIB_ARRAY_ENABLED: Int\n        val VERTEX_ATTRIB_ARRAY_SIZE: Int\n        val VERTEX_ATTRIB_ARRAY_STRIDE: Int\n        val VERTEX_ATTRIB_ARRAY_TYPE: Int\n        val VERTEX_ATTRIB_ARRAY_NORMALIZED: Int\n        val VERTEX_ATTRIB_ARRAY_POINTER: Int\n        val VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: Int\n        val IMPLEMENTATION_COLOR_READ_TYPE: Int\n        val IMPLEMENTATION_COLOR_READ_FORMAT: Int\n        val COMPILE_STATUS: Int\n        val LOW_FLOAT: Int\n        val MEDIUM_FLOAT: Int\n        val HIGH_FLOAT: Int\n        val LOW_INT: Int\n        val MEDIUM_INT: Int\n        val HIGH_INT: Int\n        val FRAMEBUFFER: Int\n        val RENDERBUFFER: Int\n        val RGBA4: Int\n        val RGB5_A1: Int\n        val RGB565: Int\n        val DEPTH_COMPONENT16: Int\n        val STENCIL_INDEX: Int\n        val STENCIL_INDEX8: Int\n        val DEPTH_STENCIL: Int\n        val RENDERBUFFER_WIDTH: Int\n        val RENDERBUFFER_HEIGHT: Int\n        val RENDERBUFFER_INTERNAL_FORMAT: Int\n        val RENDERBUFFER_RED_SIZE: Int\n        val RENDERBUFFER_GREEN_SIZE: Int\n        val RENDERBUFFER_BLUE_SIZE: Int\n        val RENDERBUFFER_ALPHA_SIZE: Int\n        val RENDERBUFFER_DEPTH_SIZE: Int\n        val RENDERBUFFER_STENCIL_SIZE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: Int\n        val COLOR_ATTACHMENT0: Int\n        val DEPTH_ATTACHMENT: Int\n        val STENCIL_ATTACHMENT: Int\n        val DEPTH_STENCIL_ATTACHMENT: Int\n        val NONE: Int\n        val FRAMEBUFFER_COMPLETE: Int\n        val FRAMEBUFFER_INCOMPLETE_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_DIMENSIONS: Int\n        val FRAMEBUFFER_UNSUPPORTED: Int\n        val FRAMEBUFFER_BINDING: Int\n        val RENDERBUFFER_BINDING: Int\n        val MAX_RENDERBUFFER_SIZE: Int\n        val INVALID_FRAMEBUFFER_OPERATION: Int\n        val UNPACK_FLIP_Y_WEBGL: Int\n        val UNPACK_PREMULTIPLY_ALPHA_WEBGL: Int\n        val CONTEXT_LOST_WEBGL: Int\n        val UNPACK_COLORSPACE_CONVERSION_WEBGL: Int\n        val BROWSER_DEFAULT_WEBGL: Int\n    }\n}\n\n/**\n * Exposes the JavaScript [WebGLContextEvent](https://developer.mozilla.org/en/docs/Web/API/WebGLContextEvent) to Kotlin\n */\npublic external open class WebGLContextEvent(type: String, eventInit: WebGLContextEventInit = definedExternally) : Event {\n    open val statusMessage: String\n}\n\npublic external interface WebGLContextEventInit : EventInit {\n    var statusMessage: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun WebGLContextEventInit(statusMessage: String? = \"\", bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): WebGLContextEventInit {\n    val o = js(\"({})\")\n\n    o[\"statusMessage\"] = statusMessage\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [ArrayBuffer](https://developer.mozilla.org/en/docs/Web/API/ArrayBuffer) to Kotlin\n */\npublic external open class ArrayBuffer(length: Int) : BufferDataSource {\n    open val byteLength: Int\n    fun slice(begin: Int, end: Int = definedExternally): ArrayBuffer\n\n    companion object {\n        fun isView(value: Any?): Boolean\n    }\n}\n\n/**\n * Exposes the JavaScript [ArrayBufferView](https://developer.mozilla.org/en/docs/Web/API/ArrayBufferView) to Kotlin\n */\npublic external interface ArrayBufferView : BufferDataSource {\n    val buffer: ArrayBuffer\n    val byteOffset: Int\n    val byteLength: Int\n}\n\n/**\n * Exposes the JavaScript [Int8Array](https://developer.mozilla.org/en/docs/Web/API/Int8Array) to Kotlin\n */\npublic external open class Int8Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Int8Array)\n    constructor(array: Array<Byte>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Int8Array, offset: Int = definedExternally): Unit\n    fun set(array: Array<Byte>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Int8Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Int8Array.get(index: Int): Byte = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Int8Array.set(index: Int, value: Byte): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [Uint8Array](https://developer.mozilla.org/en/docs/Web/API/Uint8Array) to Kotlin\n */\npublic external open class Uint8Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint8Array)\n    constructor(array: Array<Byte>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint8Array, offset: Int = definedExternally): Unit\n    fun set(array: Array<Byte>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Uint8Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Uint8Array.get(index: Int): Byte = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Uint8Array.set(index: Int, value: Byte): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [Uint8ClampedArray](https://developer.mozilla.org/en/docs/Web/API/Uint8ClampedArray) to Kotlin\n */\npublic external open class Uint8ClampedArray : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint8ClampedArray)\n    constructor(array: Array<Byte>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint8ClampedArray, offset: Int = definedExternally): Unit\n    fun set(array: Array<Byte>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Uint8ClampedArray\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Uint8ClampedArray.get(index: Int): Byte = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Uint8ClampedArray.set(index: Int, value: Byte): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [Int16Array](https://developer.mozilla.org/en/docs/Web/API/Int16Array) to Kotlin\n */\npublic external open class Int16Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Int16Array)\n    constructor(array: Array<Short>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Int16Array, offset: Int = definedExternally): Unit\n    fun set(array: Array<Short>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Int16Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Int16Array.get(index: Int): Short = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Int16Array.set(index: Int, value: Short): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [Uint16Array](https://developer.mozilla.org/en/docs/Web/API/Uint16Array) to Kotlin\n */\npublic external open class Uint16Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint16Array)\n    constructor(array: Array<Short>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint16Array, offset: Int = definedExternally): Unit\n    fun set(array: Array<Short>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Uint16Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Uint16Array.get(index: Int): Short = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Uint16Array.set(index: Int, value: Short): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [Int32Array](https://developer.mozilla.org/en/docs/Web/API/Int32Array) to Kotlin\n */\npublic external open class Int32Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Int32Array)\n    constructor(array: Array<Int>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Int32Array, offset: Int = definedExternally): Unit\n    fun set(array: Array<Int>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Int32Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Int32Array.get(index: Int): Int = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Int32Array.set(index: Int, value: Int): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [Uint32Array](https://developer.mozilla.org/en/docs/Web/API/Uint32Array) to Kotlin\n */\npublic external open class Uint32Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint32Array)\n    constructor(array: Array<Int>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint32Array, offset: Int = definedExternally): Unit\n    fun set(array: Array<Int>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Uint32Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Uint32Array.get(index: Int): Int = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Uint32Array.set(index: Int, value: Int): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [Float32Array](https://developer.mozilla.org/en/docs/Web/API/Float32Array) to Kotlin\n */\npublic external open class Float32Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Float32Array)\n    constructor(array: Array<Float>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Float32Array, offset: Int = definedExternally): Unit\n    fun set(array: Array<Float>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Float32Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Float32Array.get(index: Int): Float = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Float32Array.set(index: Int, value: Float): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [Float64Array](https://developer.mozilla.org/en/docs/Web/API/Float64Array) to Kotlin\n */\npublic external open class Float64Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Float64Array)\n    constructor(array: Array<Double>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Float64Array, offset: Int = definedExternally): Unit\n    fun set(array: Array<Double>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Float64Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Float64Array.get(index: Int): Double = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Float64Array.set(index: Int, value: Double): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [DataView](https://developer.mozilla.org/en/docs/Web/API/DataView) to Kotlin\n */\npublic external open class DataView(buffer: ArrayBuffer, byteOffset: Int = definedExternally, byteLength: Int = definedExternally) : ArrayBufferView {\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun getInt8(byteOffset: Int): Byte\n    fun getUint8(byteOffset: Int): Byte\n    fun getInt16(byteOffset: Int, littleEndian: Boolean = definedExternally): Short\n    fun getUint16(byteOffset: Int, littleEndian: Boolean = definedExternally): Short\n    fun getInt32(byteOffset: Int, littleEndian: Boolean = definedExternally): Int\n    fun getUint32(byteOffset: Int, littleEndian: Boolean = definedExternally): Int\n    fun getFloat32(byteOffset: Int, littleEndian: Boolean = definedExternally): Float\n    fun getFloat64(byteOffset: Int, littleEndian: Boolean = definedExternally): Double\n    fun setInt8(byteOffset: Int, value: Byte): Unit\n    fun setUint8(byteOffset: Int, value: Byte): Unit\n    fun setInt16(byteOffset: Int, value: Short, littleEndian: Boolean = definedExternally): Unit\n    fun setUint16(byteOffset: Int, value: Short, littleEndian: Boolean = definedExternally): Unit\n    fun setInt32(byteOffset: Int, value: Int, littleEndian: Boolean = definedExternally): Unit\n    fun setUint32(byteOffset: Int, value: Int, littleEndian: Boolean = definedExternally): Unit\n    fun setFloat32(byteOffset: Int, value: Float, littleEndian: Boolean = definedExternally): Unit\n    fun setFloat64(byteOffset: Int, value: Double, littleEndian: Boolean = definedExternally): Unit\n}\n\npublic external @marker interface BufferDataSource {\n}\n\npublic external @marker interface TexImageSource {\n}\n\n","package kotlinx.io.core\n\nimport org.khronos.webgl.*\n\nactual enum class ByteOrder {\n    BIG_ENDIAN, LITTLE_ENDIAN;\n\n    actual companion object {\n        private val native: ByteOrder\n\n        init {\n            val buffer = ArrayBuffer(4)\n            val arr = Int32Array(buffer)\n            val view = DataView(buffer)\n\n            arr[0] = 0x11223344\n\n            native = if (view.getInt32(0, true) == 0x11223344) LITTLE_ENDIAN else BIG_ENDIAN\n        }\n\n        actual fun nativeOrder(): ByteOrder = native\n    }\n}\n","package kotlinx.io.core\n\nimport kotlinx.io.core.internal.*\nimport kotlinx.io.pool.*\n\n@DangerousInternalIoApi\n@Deprecated(\"Will be removed in future releases.\", level = DeprecationLevel.ERROR)\n@Suppress(\"DEPRECATION_ERROR\")\nactual abstract class BytePacketBuilderPlatformBase\ninternal actual constructor(pool: ObjectPool<IoBuffer>) : BytePacketBuilderBase(pool) {\n\n}\n","package kotlinx.io.core\n\nimport kotlinx.io.core.internal.*\nimport kotlinx.io.pool.*\nimport org.khronos.webgl.*\n\n@DangerousInternalIoApi\nactual abstract class ByteReadPacketPlatformBase\nprotected actual constructor(head: IoBuffer, remaining: Long, pool: ObjectPool<IoBuffer>) : ByteReadPacketBase(head, remaining, pool), Input {\n\n    override fun readFully(dst: Int8Array, offset: Int, length: Int) {\n        if (remaining < length) throw IllegalArgumentException(\"Not enough bytes available ($remaining) to read $length bytes\")\n        var copied = 0\n\n        takeWhile { buffer: IoBuffer ->\n            val rc = buffer.readAvailable(dst, offset + copied, length - copied)\n            if (rc > 0) copied += rc\n            copied < length\n        }\n    }\n\n    override fun readFully(dst: ArrayBuffer, offset: Int, length: Int) {\n        if (remaining < length) throw IllegalArgumentException(\"Not enough bytes available ($remaining) to read $length bytes\")\n        var copied = 0\n\n        takeWhile { buffer: IoBuffer ->\n            val rc = buffer.readAvailable(dst, offset + copied, length - copied)\n            if (rc > 0) copied += rc\n            copied < length\n        }\n    }\n\n    override fun readFully(dst: ArrayBufferView, offset: Int, length: Int) {\n        if (remaining < length) throw IllegalArgumentException(\"Not enough bytes available ($remaining) to read $length bytes\")\n        var copied = 0\n\n        takeWhile { buffer: IoBuffer ->\n            val rc = buffer.readAvailable(dst, offset + copied, length - copied)\n            if (rc > 0) copied += rc\n            copied < length\n        }\n    }\n\n    override fun readAvailable(dst: Int8Array, offset: Int, length: Int): Int {\n        val remaining = remaining\n        if (remaining == 0L) return -1\n        val size = minOf(remaining, length.toLong()).toInt()\n        readFully(dst, offset, size)\n        return size\n    }\n\n    override fun readAvailable(dst: ArrayBuffer, offset: Int, length: Int): Int {\n        val remaining = remaining\n        if (remaining == 0L) return -1\n        val size = minOf(remaining, length.toLong()).toInt()\n        readFully(dst, offset, size)\n        return size\n    }\n\n    override fun readAvailable(dst: ArrayBufferView, offset: Int, length: Int): Int {\n        val remaining = remaining\n        if (remaining == 0L) return -1\n        val size = minOf(remaining, length.toLong()).toInt()\n        readFully(dst, offset, size)\n        return size\n    }\n\n}\n\nactual class ByteReadPacket\n    internal actual constructor(head: IoBuffer, remaining: Long, pool: ObjectPool<IoBuffer>) : ByteReadPacketPlatformBase(head, remaining, pool), Input {\n    actual constructor(head: IoBuffer, pool: ObjectPool<IoBuffer>) : this(head, head.remainingAll(), pool)\n\n    init {\n        markNoMoreChunksAvailable()\n    }\n\n    final override fun fill() = null\n\n    override fun closeSource() {\n    }\n\n    actual companion object {\n        actual val Empty: ByteReadPacket\n            get() = ByteReadPacket(IoBuffer.Empty, object : NoPoolImpl<IoBuffer>() {\n                override fun borrow() = IoBuffer.Empty\n            })\n\n        @Deprecated(\"This implementation detail is going to become internal.\")\n        actual inline val ReservedSize get() = IoBuffer.ReservedSize\n    }\n}\n\nactual fun ByteReadPacket(array: ByteArray, offset: Int, length: Int, block: (ByteArray) -> Unit): ByteReadPacket {\n    val content = array.asDynamic() as Int8Array\n    val sub = when {\n        offset == 0 && length == array.size -> content.buffer\n        else -> content.buffer.slice(offset, offset + length)\n    }\n\n    val pool = object : SingleInstancePool<IoBuffer>() {\n        override fun produceInstance(): IoBuffer {\n            return IoBuffer(sub, null)\n        }\n\n        override fun disposeInstance(instance: IoBuffer) {\n            block(array)\n        }\n    }\n\n    return ByteReadPacket(pool.borrow().apply { resetForRead() }, pool)\n}\n","package kotlinx.io.core\n\nactual interface Closeable {\n    actual fun close()\n}\n\n@PublishedApi\ninternal actual fun Throwable.addSuppressedInternal(other: Throwable) {\n}\n","package kotlinx.io.core\n\nimport kotlinx.io.core.internal.*\nimport org.khronos.webgl.*\n\n/**\n * Shouldn't be implemented directly. Inherit [AbstractInput] instead.\n */\nactual interface Input : Closeable {\n    @Deprecated(\n        \"Implementing this interface is highly experimental. Extend AbstractInput instead.\",\n        level = DeprecationLevel.HIDDEN\n    )\n    @Suppress(\"unused\")\n    actual val doNotImplementInputButExtendAbstractInputInstead: Nothing\n\n    @Deprecated(\"Use readXXXLittleEndian or readXXX then X.reverseByteOrder() instead.\")\n    actual var byteOrder: ByteOrder\n    actual val endOfInput: Boolean\n\n    actual fun readByte(): Byte\n    actual fun readShort(): Short\n    actual fun readInt(): Int\n    actual fun readLong(): Long\n    actual fun readFloat(): Float\n    actual fun readDouble(): Double\n\n    actual fun readFully(dst: ByteArray, offset: Int, length: Int)\n    actual fun readFully(dst: ShortArray, offset: Int, length: Int)\n    actual fun readFully(dst: IntArray, offset: Int, length: Int)\n    actual fun readFully(dst: LongArray, offset: Int, length: Int)\n    actual fun readFully(dst: FloatArray, offset: Int, length: Int)\n    actual fun readFully(dst: DoubleArray, offset: Int, length: Int)\n    actual fun readFully(dst: IoBuffer, length: Int)\n\n    fun readFully(dst: Int8Array, offset: Int, length: Int)\n    fun readFully(dst: ArrayBuffer, offset: Int, length: Int)\n    fun readFully(dst: ArrayBufferView, offset: Int, length: Int)\n\n    actual fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int\n    actual fun readAvailable(dst: ShortArray, offset: Int, length: Int): Int\n    actual fun readAvailable(dst: IntArray, offset: Int, length: Int): Int\n    actual fun readAvailable(dst: LongArray, offset: Int, length: Int): Int\n    actual fun readAvailable(dst: FloatArray, offset: Int, length: Int): Int\n    actual fun readAvailable(dst: DoubleArray, offset: Int, length: Int): Int\n    actual fun readAvailable(dst: IoBuffer, length: Int): Int\n\n    fun readAvailable(dst: Int8Array, offset: Int, length: Int): Int\n    fun readAvailable(dst: ArrayBuffer, offset: Int, length: Int): Int\n    fun readAvailable(dst: ArrayBufferView, offset: Int, length: Int): Int\n\n    /*\n     * Returns next byte (unsigned) or `-1` if no more bytes available\n     */\n    actual fun tryPeek(): Int\n\n    /**\n     * Copy available bytes to the specified [buffer] but keep them available.\n     * If the underlying implementation could trigger\n     * bytes population from the underlying source and block until any bytes available\n     *\n     * Very similar to [readAvailable] but don't discard copied bytes.\n     *\n     * @return number of bytes were copied\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    actual fun peekTo(buffer: IoBuffer): Int\n\n    @Deprecated(\"Use discardExact instead.\")\n    actual fun discard(n: Long): Long\n\n    actual override fun close()\n}\n","package kotlinx.io.core\n\nactual val PACKET_MAX_COPY_SIZE: Int = 200\ninternal const val BUFFER_VIEW_POOL_SIZE = 100\ninternal const val BUFFER_VIEW_SIZE = 4096\n\nactual fun BytePacketBuilder(headerSizeHint: Int) = BytePacketBuilder(headerSizeHint, IoBuffer.Pool)\n\nactual typealias EOFException = kotlinx.io.errors.EOFException\n\n","package kotlinx.io.core\n\nimport org.khronos.webgl.*\n\ninternal actual fun IoBuffer.discardUntilDelimiterImpl(delimiter: Byte): Int {\n    val content = Int8Array(content)\n    var idx = readPosition\n    val end = writePosition\n\n    while (idx < end) {\n        if (content[idx] == delimiter) break\n        idx++\n    }\n\n    val start = readPosition\n    readPosition = idx\n    return idx - start\n}\n\ninternal actual fun IoBuffer.discardUntilDelimitersImpl(delimiter1: Byte, delimiter2: Byte): Int {\n    val content = Int8Array(content)\n    var idx = readPosition\n    val end = writePosition\n\n    while (idx < end) {\n        val v = content[idx]\n        if (v == delimiter1 || v == delimiter2) break\n        idx++\n    }\n\n    val start = readPosition\n    readPosition = idx\n    return idx - start\n}\n\n\ninternal actual fun IoBuffer.readUntilDelimiterImpl(delimiter: Byte,\n                                                    dst: ByteArray, offset: Int, length: Int): Int {\n    check(offset >= 0)\n    check(length >= 0)\n    check(offset + length <= dst.size)\n\n    return readUntilImpl({ it == delimiter }, dst, offset, length)\n}\n\ninternal actual fun IoBuffer.readUntilDelimitersImpl(delimiter1: Byte, delimiter2: Byte,\n                                                     dst: ByteArray, offset: Int, length: Int): Int {\n    check(offset >= 0)\n    check(length >= 0)\n    check(offset + length <= dst.size)\n    check(delimiter1 != delimiter2)\n\n    return readUntilImpl({ it == delimiter1 || it == delimiter2 }, dst, offset, length)\n}\n\ninternal actual fun IoBuffer.readUntilDelimiterImpl(delimiter: Byte, dst: Output): Int {\n    return readUntilImpl({ it == delimiter }, dst)\n}\n\ninternal actual fun IoBuffer.readUntilDelimitersImpl(delimiter1: Byte, delimiter2: Byte, dst: Output): Int {\n    check(delimiter1 != delimiter2)\n\n    return readUntilImpl({ it == delimiter1 || it == delimiter2 }, dst)\n}\n\nprivate inline fun IoBuffer.readUntilImpl(predicate: (Byte) -> Boolean,\n                                          dst: ByteArray, offset: Int, length: Int): Int {\n\n    val array = Int8Array(content)\n    val start = readPosition\n    var i = start\n    val end = i + minOf(length, readRemaining)\n\n    while (i < end) {\n        if (predicate(array[i])) break\n        i++\n    }\n\n    val copied = i - start\n    val dstArray = dst.asDynamic() as Int8Array\n    dstArray.set(array.subarray(start, end), offset)\n    readPosition = i\n\n    return copied\n}\n\nprivate inline fun IoBuffer.readUntilImpl(predicate: (Byte) -> Boolean,\n                                          dst: Output): Int {\n    val array = Int8Array(content)\n    var i = readPosition\n    var copiedTotal = 0\n\n    dst.writeWhile { chunk ->\n        chunk.writeFully(chunk, 0)\n        val start = i\n        val end = minOf(i + chunk.writeRemaining, writePosition)\n\n        while (i < end) {\n            if (predicate(array[i])) break\n            i++\n        }\n\n        val size = i - start\n\n        Int8Array(chunk.content).set(array.subarray(start, i), chunk.writePosition)\n        chunk.writePosition += size\n        copiedTotal += size\n\n        chunk.writeRemaining == 0 && i < end\n    }\n\n    readPosition = i\n    return copiedTotal\n}","package kotlinx.io.core\n\nimport kotlinx.io.charsets.*\nimport org.khronos.webgl.*\n\nactual fun String(bytes: ByteArray, offset: Int, length: Int, charset: Charset): String {\n    if (offset < 0 || length < 0 || offset + length > bytes.size) {\n        checkIndices(offset, length, bytes)\n    }\n\n    @Suppress(\"UnsafeCastFromDynamic\")\n    val i8: Int8Array = bytes.asDynamic() // we know that K/JS generates Int8Array for ByteBuffer\n    val bufferOffset = i8.byteOffset + offset\n    val buffer = i8.buffer.slice(bufferOffset, bufferOffset + length)\n\n    val view = IoBuffer(buffer, null)\n    view.resetForRead()\n    val packet = ByteReadPacket(view, IoBuffer.NoPool)\n\n    return charset.newDecoder().decode(packet, Int.MAX_VALUE)\n}\n\nfun checkIndices(offset: Int, length: Int, bytes: ByteArray): Nothing {\n    require(offset >= 0) { throw IndexOutOfBoundsException(\"offset ($offset) shouldn't be negative\") }\n    require(length >= 0) { throw IndexOutOfBoundsException(\"length ($length) shouldn't be negative\") }\n    require(offset + length <= bytes.size) {\n        throw IndexOutOfBoundsException(\"offset ($offset) + length ($length) > bytes.size (${bytes.size})\")\n    }\n\n    throw IndexOutOfBoundsException()\n}\n\ninternal actual fun String.getCharsInternal(dst: CharArray, dstOffset: Int) {\n    val length = length\n    require(dstOffset + length <= dst.size)\n\n    var dstIndex = dstOffset\n    for (srcIndex in 0 until length) {\n        dst[dstIndex++] = this[srcIndex]\n    }\n}\n","package kotlinx.io.errors\n\nactual open class IOException actual constructor(message: String, cause: Throwable?) : Exception(message, cause) {\n    actual constructor(message: String) : this(message, null)\n}\n\nactual open class EOFException actual constructor(message: String) : IOException(message)\n","package kotlinx.io.js\n\nimport org.khronos.webgl.*\n\ninternal external class TextEncoder() {\n    val encoding: String\n\n    fun encode(input: String): Uint8Array\n}\n\ninternal fun TextEncoderCtor(): TextEncoder {\n    // PhantomJS does not support TextEncoder yet so we use node module text-encoding for tests\n    if (js(\"typeof TextEncoder\") == \"undefined\") {\n        val module = js(\"require('text-encoding')\")\n        if (module.TextEncoder === undefined) throw IllegalStateException(\"TextEncoder is not supported by your browser and no text-encoding module found\")\n        val ctor = module.TextEncoder\n        val objPrototype = js(\"Object\").create(ctor.prototype)\n\n        @Suppress(\"UnsafeCastFromDynamic\")\n        return ctor.call(objPrototype)\n    }\n\n    return TextEncoder()\n}\n","package kotlinx.io.js\n\nimport kotlinx.io.core.*\nimport org.khronos.webgl.*\n\n/**\n * Read exactly [n] bytes to a new array buffer instance\n */\nfun ByteReadPacket.readArrayBuffer(\n    n: Int = remaining.coerceAtMostMaxIntOrFail(\"Unable to make a new ArrayBuffer: packet is too big\")\n): ArrayBuffer {\n    val buffer = ArrayBuffer(n)\n    readFully(buffer, 0, n)\n    return buffer\n}\n\n/**\n * Write exactly [length] bytes from the specified [src] array buffer\n */\nfun BytePacketBuilder.writeFully(src: ArrayBuffer, offset: Int = 0, length: Int = src.byteLength - offset) {\n    writeFully(Int8Array(src), offset, length)\n}\n\n/**\n * Write exactly [length] bytes from the specified [src] typed array\n */\nfun BytePacketBuilder.writeFully(src: Int8Array, offset: Int = 0, length: Int = src.length - offset) {\n    var written = 0\n    var rem = length\n\n    while (rem > 0) {\n        write(1) { bb: IoBuffer ->\n            val size = minOf(bb.writeRemaining, rem)\n            bb.write(src, written + offset, size)\n            written += size\n            rem -= size\n            size\n        }\n    }\n}\n","package kotlinx.io.js\n\nimport kotlinx.io.core.*\nimport org.khronos.webgl.*\nimport org.w3c.dom.*\n\nfun WebSocket.sendPacket(packet: ByteReadPacket) {\n    send(packet.readArrayBuffer())\n}\n\ninline fun WebSocket.sendPacket(block: BytePacketBuilder.() -> Unit) {\n    sendPacket(buildPacket(block = block))\n}\n\ninline fun MessageEvent.packet(): ByteReadPacket {\n    @Suppress(\"NON_PUBLIC_CALL_FROM_PUBLIC_INLINE\", \"UnsafeCastFromDynamic\")\n    return ByteReadPacket(IoBuffer(data.asDynamic(), null), IoBuffer.NoPool)\n}\n\n\n\n\n","package kotlinx.io.js\n\nimport kotlinx.io.core.*\nimport org.w3c.xhr.*\n\ninline fun XMLHttpRequest.sendPacket(block: BytePacketBuilder.() -> Unit) {\n    sendPacket(buildPacket(block = block))\n}\n\nfun XMLHttpRequest.sendPacket(packet: ByteReadPacket) {\n    send(packet.readArrayBuffer())\n}\n\n@Suppress(\"UnsafeCastFromDynamic\")\nfun XMLHttpRequest.responsePacket(): ByteReadPacket = when (responseType) {\n    XMLHttpRequestResponseType.ARRAYBUFFER -> ByteReadPacket(IoBuffer(response.asDynamic(), null), IoBuffer.NoPool)\n    XMLHttpRequestResponseType.EMPTY -> ByteReadPacket.Empty\n    else -> throw IllegalStateException(\"Incompatible type ${responseType}: only ARRAYBUFFER and EMPTY are supported\")\n}\n\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// NOTE: THIS FILE IS AUTO-GENERATED, DO NOT EDIT!\n// See libraries/tools/idl2k for details\n\n@file:Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npackage org.w3c.xhr\n\nimport kotlin.js.*\nimport org.khronos.webgl.*\nimport org.w3c.css.masking.*\nimport org.w3c.dom.*\nimport org.w3c.dom.clipboard.*\nimport org.w3c.dom.css.*\nimport org.w3c.dom.events.*\nimport org.w3c.dom.mediacapture.*\nimport org.w3c.dom.parsing.*\nimport org.w3c.dom.pointerevents.*\nimport org.w3c.dom.svg.*\nimport org.w3c.dom.url.*\nimport org.w3c.fetch.*\nimport org.w3c.files.*\nimport org.w3c.notifications.*\nimport org.w3c.performance.*\nimport org.w3c.workers.*\n\n/**\n * Exposes the JavaScript [XMLHttpRequestEventTarget](https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequestEventTarget) to Kotlin\n */\npublic external abstract class XMLHttpRequestEventTarget : EventTarget {\n    open var onloadstart: ((ProgressEvent) -> dynamic)?\n    open var onprogress: ((ProgressEvent) -> dynamic)?\n    open var onabort: ((Event) -> dynamic)?\n    open var onerror: ((Event) -> dynamic)?\n    open var onload: ((Event) -> dynamic)?\n    open var ontimeout: ((Event) -> dynamic)?\n    open var onloadend: ((Event) -> dynamic)?\n}\n\npublic external abstract class XMLHttpRequestUpload : XMLHttpRequestEventTarget {\n}\n\n/**\n * Exposes the JavaScript [XMLHttpRequest](https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest) to Kotlin\n */\npublic external open class XMLHttpRequest : XMLHttpRequestEventTarget {\n    var onreadystatechange: ((Event) -> dynamic)?\n    open val readyState: Short\n    var timeout: Int\n    var withCredentials: Boolean\n    open val upload: XMLHttpRequestUpload\n    open val responseURL: String\n    open val status: Short\n    open val statusText: String\n    var responseType: XMLHttpRequestResponseType\n    open val response: Any?\n    open val responseText: String\n    open val responseXML: Document?\n    fun open(method: String, url: String): Unit\n    fun open(method: String, url: String, async: Boolean, username: String? = definedExternally, password: String? = definedExternally): Unit\n    fun setRequestHeader(name: String, value: String): Unit\n    fun send(body: dynamic = definedExternally): Unit\n    fun abort(): Unit\n    fun getResponseHeader(name: String): String?\n    fun getAllResponseHeaders(): String\n    fun overrideMimeType(mime: String): Unit\n\n    companion object {\n        val UNSENT: Short\n        val OPENED: Short\n        val HEADERS_RECEIVED: Short\n        val LOADING: Short\n        val DONE: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [FormData](https://developer.mozilla.org/en/docs/Web/API/FormData) to Kotlin\n */\npublic external open class FormData(form: HTMLFormElement = definedExternally) {\n    fun append(name: String, value: String): Unit\n    fun append(name: String, value: Blob, filename: String = definedExternally): Unit\n    fun delete(name: String): Unit\n    fun get(name: String): dynamic\n    fun getAll(name: String): Array<dynamic>\n    fun has(name: String): Boolean\n    fun set(name: String, value: String): Unit\n    fun set(name: String, value: Blob, filename: String = definedExternally): Unit\n}\n\n/**\n * Exposes the JavaScript [ProgressEvent](https://developer.mozilla.org/en/docs/Web/API/ProgressEvent) to Kotlin\n */\npublic external open class ProgressEvent(type: String, eventInitDict: ProgressEventInit = definedExternally) : Event {\n    open val lengthComputable: Boolean\n    open val loaded: Int\n    open val total: Int\n}\n\npublic external interface ProgressEventInit : EventInit {\n    var lengthComputable: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var loaded: Int? /* = 0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var total: Int? /* = 0 */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ProgressEventInit(lengthComputable: Boolean? = false, loaded: Int? = 0, total: Int? = 0, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): ProgressEventInit {\n    val o = js(\"({})\")\n\n    o[\"lengthComputable\"] = lengthComputable\n    o[\"loaded\"] = loaded\n    o[\"total\"] = total\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/* please, don't implement this interface! */\npublic external interface XMLHttpRequestResponseType {\n    companion object\n}\npublic inline val XMLHttpRequestResponseType.Companion.EMPTY: XMLHttpRequestResponseType get() = \"\".asDynamic().unsafeCast<XMLHttpRequestResponseType>()\npublic inline val XMLHttpRequestResponseType.Companion.ARRAYBUFFER: XMLHttpRequestResponseType get() = \"arraybuffer\".asDynamic().unsafeCast<XMLHttpRequestResponseType>()\npublic inline val XMLHttpRequestResponseType.Companion.BLOB: XMLHttpRequestResponseType get() = \"blob\".asDynamic().unsafeCast<XMLHttpRequestResponseType>()\npublic inline val XMLHttpRequestResponseType.Companion.DOCUMENT: XMLHttpRequestResponseType get() = \"document\".asDynamic().unsafeCast<XMLHttpRequestResponseType>()\npublic inline val XMLHttpRequestResponseType.Companion.JSON: XMLHttpRequestResponseType get() = \"json\".asDynamic().unsafeCast<XMLHttpRequestResponseType>()\npublic inline val XMLHttpRequestResponseType.Companion.TEXT: XMLHttpRequestResponseType get() = \"text\".asDynamic().unsafeCast<XMLHttpRequestResponseType>()\n\n","package kotlinx.io.pool\n\nactual abstract class DefaultPool<T : Any> actual constructor(actual final override val capacity: Int) : ObjectPool<T> {\n    private val instances = arrayOfNulls<Any?>(capacity)\n    private var size = 0\n\n    protected actual abstract fun produceInstance(): T\n    protected actual open fun disposeInstance(instance: T) {}\n\n    protected actual open fun clearInstance(instance: T): T = instance\n    protected actual open fun validateInstance(instance: T) {}\n\n    actual final override fun borrow(): T {\n        if (size == 0) return produceInstance()\n        val idx = --size\n\n        @Suppress(\"UNCHECKED_CAST\")\n        val instance = instances[idx] as T\n        instances[idx] = null\n\n        return clearInstance(instance)\n    }\n\n    actual final override fun recycle(instance: T) {\n        validateInstance(instance)\n        if (size == capacity) {\n            disposeInstance(instance)\n        } else {\n            instances[size++] = instance\n        }\n    }\n\n    actual final override fun dispose() {\n        for (i in 0 until size) {\n            @Suppress(\"UNCHECKED_CAST\")\n            val instance = instances[i] as T\n            instances[i] = null\n            disposeInstance(instance)\n        }\n        size = 0\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;oBA2QA,oB;kBCqBA,kB;mBCeA,mB;YCtKY,uB;;2BCvHZ,6C;mCCmEA,gD;;WC+NiD,gB;;;;;;;;;;;;;;;;;eClIjD,I;;iCCjCmB,qB;;;;;;oBC0T0B,+B;;;;;;;;6BLjc7C,qC;;;;;;;oBM0BkG,sB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICL1D,OXsPK,gBWtPK,mBXqJT,cWrJS,CXsPL,C;EWtPL,C;;IAMJ,OVqQG,cUrQK,mBVgKP,cUhKO,CVqQL,C;EUrQH,C;;IAME,OT8QI,eS9QK,mBTqKR,cSrKQ,CT8QL,C;ES9QJ,C;;IRdjC,wBAAa,GAAb,EAAkB,KAAlB,EAAyB,SAAzB,EAAoC,OAApC,C;EACL,C;;;IAeI,yB;MAAA,YAAiB,C;IACjB,uB;MAAA,UAAe,KAAM,O;IAErB,OAAO,6BAAkB,KAAlB,EAAyB,SAAzB,EAAoC,OAApC,C;EACX,C;;IAM+C,yB;MAAA,YAAiB,C;IAAG,uB;MAAA,UAAe,KAAM,O;IAAU,sB;IS5C9F,cAAc,oBAD2B,CAC3B,C;;MT6Cd,wBS3CU,OT2CV,4B;MS1CI,qBAAO,OAAQ,Q;;;MACjB,gC;QACE,OAAQ,U;QACR,MAAM,C;;;QALV,O;;IT2C8F,yB;EAAA,C;;IAK3C,sB;ISjDnD,cAAc,oBAD2B,CAC3B,C;;MTkDd,+BShDU,OTgDV,C;MS/CI,qBAAO,OAAQ,Q;;;MACjB,gC;QACE,OAAQ,U;QACR,MAAM,C;;;QALV,O;;ITgDmD,yB;EAAA,C;;IAef,mB;MAAA,MAAW,U;IAAqC,QAAU,oBAAJ,GAAI,C;IAAV,QAA0B,aAAN,KAAM,C;IClDtF,kBAAxB,mBDkD8H,CIuHnH,kBAAK,CAAL,MAAJ,GAAY,CAAZ,GAAmB,CJvHoG,SClD9H,C;IDmDA,2BUMA,WVNA,M;IADwE,OUQjE,WT1DsC,W;EDkD2B,C;;IAiCxE,yB;MAAA,YAAiB,C;IACjB,uB;MAAA,UAAe,KAAM,O;IAErB,YAAY,S;IACZ,IAAI,SAAS,OAAb,C;MAAsB,OAAO,c;IAC7B,aAAa,gCAAS,KAAK,S;;MAGvB,gCAAS,O;MACT,S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"}